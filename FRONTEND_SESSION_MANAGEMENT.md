# Frontend Session Management Guide

## Overview

This backend acts as a **proxy only** - it does not generate or store session IDs. All session IDs are created and managed by the upstream Genies API. The frontend is responsible for:

1. Requesting new session IDs from the backend (which proxies to Genies API)
2. Storing session IDs locally in the browser
3. Managing one session ID per character per user
4. Reusing existing session IDs across page refreshes

## Key Concepts

- **Each browser/user needs their own session IDs** - sessions are not shared across browsers
- **Each character conversation needs its own session ID** - different characters have different sessions
- **Session IDs persist across page refreshes** - stored in localStorage
- **Session IDs are generated by the Genies API** - the backend only proxies requests

## Implementation Pattern

### 1. Storage Strategy

Store session IDs in `localStorage` keyed by character config ID:

```javascript
// Storage key format: `session_${config_id}`
const SESSION_KEY_PREFIX = 'session_';

function getSessionKey(configId) {
  return `${SESSION_KEY_PREFIX}${configId}`;
}
```

### 2. Get or Create Session

Always check for existing session before creating a new one:

```javascript
/**
 * Get existing session ID for a character, or create a new one
 * @param {string} configId - Character configuration ID
 * @param {string} apiBaseUrl - Base URL of the proxy API (e.g., 'http://localhost:3000')
 * @returns {Promise<string>} Session ID
 */
async function getOrCreateSession(configId, apiBaseUrl = 'http://localhost:3000') {
  // Check localStorage for existing session
  const sessionKey = getSessionKey(configId);
  const existingSessionId = localStorage.getItem(sessionKey);
  
  if (existingSessionId) {
    console.log(`Using existing session for ${configId}: ${existingSessionId}`);
    return existingSessionId;
  }
  
  // Create new session
  console.log(`Creating new session for ${configId}`);
  try {
    const response = await fetch(`${apiBaseUrl}/api/sessions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        config_id: configId,
      }),
    });
    
    if (!response.ok) {
      throw new Error(`Failed to create session: ${response.status}`);
    }
    
    const session = await response.json();
    const sessionId = session.session_id; // Note: field name from API
    
    // Store in localStorage for future use
    localStorage.setItem(sessionKey, sessionId);
    
    console.log(`Created and stored session: ${sessionId}`);
    return sessionId;
  } catch (error) {
    console.error('Error creating session:', error);
    throw error;
  }
}
```

### 3. Send Chat Message

Use the session ID when sending chat messages:

```javascript
/**
 * Send a chat message to a character
 * @param {string} configId - Character configuration ID
 * @param {string} message - User's message
 * @param {string} apiBaseUrl - Base URL of the proxy API
 * @returns {Promise<object>} Chat response
 */
async function sendChatMessage(configId, message, apiBaseUrl = 'http://localhost:3000') {
  // Get or create session
  const sessionId = await getOrCreateSession(configId, apiBaseUrl);
  
  // Send chat message
  const response = await fetch(`${apiBaseUrl}/api/chat`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      session_id: sessionId,
      config_id: configId,
      input: message,
    }),
  });
  
  if (!response.ok) {
    throw new Error(`Failed to send chat: ${response.status}`);
  }
  
  const chatResponse = await response.json();
  
  // Update session ID if it changed (shouldn't happen, but be safe)
  if (chatResponse.session_id && chatResponse.session_id !== sessionId) {
    const sessionKey = getSessionKey(configId);
    localStorage.setItem(sessionKey, chatResponse.session_id);
  }
  
  return chatResponse;
}
```

### 4. Complete Example

Here's a complete example for a React component:

```javascript
import { useState, useEffect } from 'react';

const API_BASE_URL = 'http://localhost:3000';

function ChatComponent({ configId }) {
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const [sessionId, setSessionId] = useState(null);
  const [loading, setLoading] = useState(false);

  // Initialize session on mount
  useEffect(() => {
    initializeSession();
  }, [configId]);

  async function initializeSession() {
    try {
      const sessionKey = `session_${configId}`;
      const existingSessionId = localStorage.getItem(sessionKey);
      
      if (existingSessionId) {
        setSessionId(existingSessionId);
        return;
      }
      
      // Create new session
      const response = await fetch(`${API_BASE_URL}/api/sessions`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ config_id: configId }),
      });
      
      if (!response.ok) {
        throw new Error('Failed to create session');
      }
      
      const session = await response.json();
      const newSessionId = session.session_id;
      
      localStorage.setItem(sessionKey, newSessionId);
      setSessionId(newSessionId);
    } catch (error) {
      console.error('Error initializing session:', error);
    }
  }

  async function handleSendMessage() {
    if (!input.trim() || !sessionId) return;
    
    setLoading(true);
    const userMessage = input;
    setInput('');
    
    // Add user message to UI
    setMessages(prev => [...prev, { role: 'user', content: userMessage }]);
    
    try {
      const response = await fetch(`${API_BASE_URL}/api/chat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          session_id: sessionId,
          config_id: configId,
          input: userMessage,
        }),
      });
      
      if (!response.ok) {
        throw new Error('Failed to send message');
      }
      
      const chatResponse = await response.json();
      
      // Add AI response to UI
      setMessages(prev => [...prev, { 
        role: 'assistant', 
        content: chatResponse.ai 
      }]);
    } catch (error) {
      console.error('Error sending message:', error);
      setMessages(prev => [...prev, { 
        role: 'error', 
        content: 'Failed to send message. Please try again.' 
      }]);
    } finally {
      setLoading(false);
    }
  }

  return (
    <div>
      <div className="messages">
        {messages.map((msg, idx) => (
          <div key={idx} className={msg.role}>
            {msg.content}
          </div>
        ))}
      </div>
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}
        disabled={loading || !sessionId}
      />
      <button onClick={handleSendMessage} disabled={loading || !sessionId}>
        Send
      </button>
    </div>
  );
}
```

### 5. Handling Multiple Characters

When managing multiple character conversations, each character should have its own session:

```javascript
class SessionManager {
  constructor(apiBaseUrl = 'http://localhost:3000') {
    this.apiBaseUrl = apiBaseUrl;
    this.sessions = new Map(); // In-memory cache
  }

  async getSession(configId) {
    // Check cache first
    if (this.sessions.has(configId)) {
      return this.sessions.get(configId);
    }

    // Check localStorage
    const sessionKey = `session_${configId}`;
    const existingSessionId = localStorage.getItem(sessionKey);
    
    if (existingSessionId) {
      this.sessions.set(configId, existingSessionId);
      return existingSessionId;
    }

    // Create new session
    const response = await fetch(`${this.apiBaseUrl}/api/sessions`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ config_id: configId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to create session: ${response.status}`);
    }

    const session = await response.json();
    const sessionId = session.session_id;

    // Store in both cache and localStorage
    this.sessions.set(configId, sessionId);
    localStorage.setItem(sessionKey, sessionId);

    return sessionId;
  }

  clearSession(configId) {
    // Remove from cache
    this.sessions.delete(configId);
    
    // Remove from localStorage
    const sessionKey = `session_${configId}`;
    localStorage.removeItem(sessionKey);
  }

  clearAllSessions() {
    // Clear cache
    this.sessions.clear();
    
    // Clear all session-related items from localStorage
    Object.keys(localStorage).forEach(key => {
      if (key.startsWith('session_')) {
        localStorage.removeItem(key);
      }
    });
  }
}

// Usage
const sessionManager = new SessionManager();

// Get session for character 1
const session1 = await sessionManager.getSession('CHAR_xxx');

// Get session for character 2 (different session)
const session2 = await sessionManager.getSession('CHAR_yyy');
```

## Session Response Structure

The `/api/sessions` endpoint returns:

```typescript
{
  session_id: string;      // The session ID to use for chat
  config_id: string;        // Character configuration ID
  user_id: string;         // User identifier from Genies API
  session_status: string;  // Session status (e.g., "active")
  updated_at: number;      // Unix timestamp
}
```

## Error Handling

Handle common errors:

```javascript
async function getOrCreateSession(configId, apiBaseUrl) {
  try {
    // ... existing code ...
  } catch (error) {
    // Handle network errors
    if (error.message.includes('Failed to fetch')) {
      throw new Error('Network error: Unable to connect to server');
    }
    
    // Handle API errors
    if (error.message.includes('status')) {
      const status = error.message.match(/\d+/)?.[0];
      if (status === '401') {
        throw new Error('Authentication error: Please refresh the page');
      }
      if (status === '500') {
        throw new Error('Server error: Please try again later');
      }
    }
    
    throw error;
  }
}
```

## Best Practices

1. **Always check localStorage first** - Don't create new sessions unnecessarily
2. **Store immediately after creation** - Save session ID to localStorage as soon as you receive it
3. **Handle session expiration** - If the API returns an error about invalid session, clear it and create a new one
4. **One session per character** - Each character should have its own session ID
5. **Clean up on logout** - Optionally clear sessions when user logs out (if applicable)

## Session Lifecycle

```
User opens chat with Character A
  ↓
Check localStorage for session_A
  ↓
[If exists] Use existing session
[If not] POST /api/sessions → Store session_id in localStorage
  ↓
Use session_id for all chat messages with Character A
  ↓
Session persists across page refreshes
  ↓
[Optional] Clear session on logout or when starting fresh conversation
```

## Notes

- Sessions are managed entirely by the Genies API
- The backend only proxies requests - it does not store or manage sessions
- Session IDs are unique per character and per user/browser
- Sessions persist until explicitly cleared or expired by the Genies API
- If you need to start a fresh conversation, you can clear the session from localStorage and create a new one

