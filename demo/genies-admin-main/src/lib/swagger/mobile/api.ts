/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Genies Mobile API
 * Genies Composer server.
 *
 * OpenAPI spec version: 1.7.3
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from 'url';
import * as isomorphicFetch from 'isomorphic-fetch';
import { Configuration } from './configuration';

const BASE_PATH =
  'https://virtserver.swaggerhub.com/Genies/Migrated_Genies_Composer_API/1.7.3'.replace(
    /\/+$/,
    '',
  );

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = isomorphicFetch,
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name = 'RequiredError';
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 * Activity of in app notifications for a user
 * @export
 * @interface ActivityResponse
 */
export interface ActivityResponse {
  /**
   *
   * @type {Array<FeedLikeResponse>}
   * @memberof ActivityResponse
   */
  activity?: Array<FeedLikeResponse>;
  /**
   *
   * @type {Array<FollowActivityResponse>}
   * @memberof ActivityResponse
   */
  followingActivity?: Array<FollowActivityResponse>;
  /**
   * Key to iterate through multiple pages of the response.
   * @type {string}
   * @memberof ActivityResponse
   */
  nextCursor?: string;
}
/**
 * Activity of in app notifications for a user
 * @export
 * @interface ActivityResponseV2
 */
export interface ActivityResponseV2 {
  /**
   *
   * @type {Array<FeedTagActivityResponse | FollowActivityResponseV2 | LeaderboardActivity | RewardActivity | ThriftActivity | FeedThriftActivity>}
   * @memberof ActivityResponseV2
   */
  activity?: Array<
    | FeedTagActivityResponse
    | FollowActivityResponseV2
    | LeaderboardActivity
    | RewardActivity
    | ThriftActivity
    | FeedThriftActivity
  >;
  /**
   * Key to iterate through multiple pages of the response.
   * @type {string}
   * @memberof ActivityResponseV2
   */
  nextCursor?: string;
}
/**
 * Represents properties to add an edition.
 * @export
 * @interface AddEditionInput
 */
export interface AddEditionInput {
  /**
   * Uuid used to prevent duplicate requests
   * @type {string}
   * @memberof AddEditionInput
   */
  idempotencyKey: string;
  /**
   *
   * @type {string}
   * @memberof AddEditionInput
   */
  designSlot?: AddEditionInput.DesignSlotEnum;
  /**
   * Name of the edition
   * @type {string}
   * @memberof AddEditionInput
   */
  name?: string;
  /**
   * Unique flow id of the collection used to mint the edition for
   * @type {number}
   * @memberof AddEditionInput
   */
  collectionFlowId?: number;
  /**
   *
   * @type {string}
   * @memberof AddEditionInput
   */
  rarity?: AddEditionInput.RarityEnum;
  /**
   *
   * @type {string}
   * @memberof AddEditionInput
   */
  type?: AddEditionInput.TypeEnum;
}

/**
 * @export
 * @namespace AddEditionInput
 */
export namespace AddEditionInput {
  /**
   * @export
   * @enum {string}
   */
  export enum DesignSlotEnum {
    NIL = <any>'EDITION_DESIGN_SLOT_NIL',
    GLASSES = <any>'EDITION_DESIGN_SLOT_GLASSES',
    HELMET = <any>'EDITION_DESIGN_SLOT_HELMET',
    MASK = <any>'EDITION_DESIGN_SLOT_MASK',
    SHIRT = <any>'EDITION_DESIGN_SLOT_SHIRT',
    JACKET = <any>'EDITION_DESIGN_SLOT_JACKET',
    PANTS = <any>'EDITION_DESIGN_SLOT_PANTS',
    SHOES = <any>'EDITION_DESIGN_SLOT_SHOES',
    DRESS = <any>'EDITION_DESIGN_SLOT_DRESS',
    HAT = <any>'EDITION_DESIGN_SLOT_HAT',
    HOODIE = <any>'EDITION_DESIGN_SLOT_HOODIE',
    SKIRT = <any>'EDITION_DESIGN_SLOT_SKIRT',
    SHORTS = <any>'EDITION_DESIGN_SLOT_SHORTS',
    BRACELET = <any>'EDITION_DESIGN_SLOT_BRACELET',
    WATCH = <any>'EDITION_DESIGN_SLOT_WATCH',
    NECKLACE = <any>'EDITION_DESIGN_SLOT_NECKLACE',
    RING = <any>'EDITION_DESIGN_SLOT_RING',
    SANDALS = <any>'EDITION_DESIGN_SLOT_SANDALS',
    EARRINGS = <any>'EDITION_DESIGN_SLOT_EARRINGS',
  }
  /**
   * @export
   * @enum {string}
   */
  export enum RarityEnum {
    NIL = <any>'EDITION_RARITY_NIL',
    UNIQUE = <any>'EDITION_RARITY_UNIQUE',
    LEGENDARY = <any>'EDITION_RARITY_LEGENDARY',
    EPIC = <any>'EDITION_RARITY_EPIC',
    RARE = <any>'EDITION_RARITY_RARE',
    STANDARD = <any>'EDITION_RARITY_STANDARD',
    COMMON = <any>'EDITION_RARITY_COMMON',
  }
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    EDITIONTYPEAVATARWEARABLE = <any>'EDITION_TYPE_AVATAR_WEARABLE',
  }
}
/**
 * Represents an individual avatar.
 * @export
 * @interface Avatar
 */
export interface Avatar {
  /**
   * Avatar UUID
   * @type {string}
   * @memberof Avatar
   */
  avatarId: string;
  /**
   * User UUID
   * @type {string}
   * @memberof Avatar
   */
  userId: string;
  /**
   *
   * @type {number}
   * @memberof Avatar
   */
  created?: number;
  /**
   *
   * @type {number}
   * @memberof Avatar
   */
  lastModified?: number;
  /**
   * Placeholder status values
   * @type {string}
   * @memberof Avatar
   */
  status?: Avatar.StatusEnum;
  /**
   * Avatar gender:  * `male`  * `female`  * `nonbinary`
   * @type {string}
   * @memberof Avatar
   */
  gender?: Avatar.GenderEnum;
  /**
   * Type of avatar definition:  * `normal` - regular avatar definition as managed by the composer app  * `vip` - special avatar definition with limited editing available
   * @type {string}
   * @memberof Avatar
   */
  defType?: Avatar.DefTypeEnum;
  /**
   * JSON data describing the construction of the avatar
   * @type {string}
   * @memberof Avatar
   */
  definition?: string;
  /**
   * cloudfront url that points to the low res avatar
   * @type {string}
   * @memberof Avatar
   */
  lodUrl?: string;
}

/**
 * @export
 * @namespace Avatar
 */
export namespace Avatar {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    Disabled = <any>'disabled',
    Hidden = <any>'hidden',
    Visible = <any>'visible',
  }
  /**
   * @export
   * @enum {string}
   */
  export enum GenderEnum {
    Male = <any>'male',
    Female = <any>'female',
    Nonbinary = <any>'nonbinary',
  }
  /**
   * @export
   * @enum {string}
   */
  export enum DefTypeEnum {
    Normal = <any>'normal',
    Vip = <any>'vip',
  }
}
/**
 *
 * @export
 * @interface ClosetItem
 */
export interface ClosetItem {
  /**
   *
   * @type {ClosetItemNFT}
   * @memberof ClosetItem
   */
  nfts?: ClosetItemNFT;
  /**
   *
   * @type {ClosetItemWearable}
   * @memberof ClosetItem
   */
  wearables?: ClosetItemWearable;
  /**
   *
   * @type {ClosetItemThings}
   * @memberof ClosetItem
   */
  things?: ClosetItemThings;
  /**
   *
   * @type {ClosetItemGears}
   * @memberof ClosetItem
   */
  gears?: ClosetItemGears;
}
/**
 *
 * @export
 * @interface ClosetItemGears
 */
export interface ClosetItemGears {
  /**
   *
   * @type {string}
   * @memberof ClosetItemGears
   */
  gearId?: string;
  /**
   *
   * @type {string}
   * @memberof ClosetItemGears
   */
  latestVersionId?: string;
}
/**
 *
 * @export
 * @interface ClosetItemNFT
 */
export interface ClosetItemNFT {
  /**
   * incremental id, ex \"1\"
   * @type {string}
   * @memberof ClosetItemNFT
   */
  nftId?: string;
  /**
   * incremental id with respect to the edition, ex \"1\", (the first minted nft)
   * @type {string}
   * @memberof ClosetItemNFT
   */
  nftSerialNumber?: string;
  /**
   *
   * @type {string}
   * @memberof ClosetItemNFT
   */
  guid?: string;
  /**
   *
   * @type {string}
   * @memberof ClosetItemNFT
   */
  wallet?: ClosetItemNFT.WalletEnum;
  /**
   *
   * @type {number}
   * @memberof ClosetItemNFT
   */
  updated?: number;
}

/**
 * @export
 * @namespace ClosetItemNFT
 */
export namespace ClosetItemNFT {
  /**
   * @export
   * @enum {string}
   */
  export enum WalletEnum {
    Flow = <any>'flow',
  }
}
/**
 *
 * @export
 * @interface ClosetItemResponse
 */
export interface ClosetItemResponse {
  /**
   *
   * @type {Array<ClosetItemNFT>}
   * @memberof ClosetItemResponse
   */
  nfts?: Array<ClosetItemNFT>;
  /**
   *
   * @type {Array<ClosetItemWearable>}
   * @memberof ClosetItemResponse
   */
  wearables?: Array<ClosetItemWearable>;
  /**
   *
   * @type {Array<ClosetItemThings>}
   * @memberof ClosetItemResponse
   */
  things?: Array<ClosetItemThings>;
}
/**
 *
 * @export
 * @interface ClosetItemThings
 */
export interface ClosetItemThings {
  /**
   *
   * @type {string}
   * @memberof ClosetItemThings
   */
  thingId?: string;
  /**
   *
   * @type {string}
   * @memberof ClosetItemThings
   */
  latestVersionId?: string;
  /**
   *
   * @type {string}
   * @memberof ClosetItemThings
   */
  latestMatchingVersionId?: string;
}
/**
 *
 * @export
 * @interface ClosetItemWearable
 */
export interface ClosetItemWearable {
  /**
   *
   * @type {number}
   * @memberof ClosetItemWearable
   */
  updated?: number;
  /**
   *
   * @type {string}
   * @memberof ClosetItemWearable
   */
  wearableId?: string;
  /**
   *
   * @type {string}
   * @memberof ClosetItemWearable
   */
  fullAssetName?: string;
  /**
   *
   * @type {string}
   * @memberof ClosetItemWearable
   */
  createdBy?: string;
}
/**
 * Manipulating assets owned by a user.
 * @export
 * @interface ClosetUpdate
 */
export interface ClosetUpdate {
  /**
   *
   * @type {Array<ClosetUpdateClosetUpdates>}
   * @memberof ClosetUpdate
   */
  closetUpdates?: Array<ClosetUpdateClosetUpdates>;
}
/**
 *
 * @export
 * @interface ClosetUpdateClosetUpdates
 */
export interface ClosetUpdateClosetUpdates {
  /**
   *
   * @type {string}
   * @memberof ClosetUpdateClosetUpdates
   */
  op?: ClosetUpdateClosetUpdates.OpEnum;
  /**
   *
   * @type {ClosetItem}
   * @memberof ClosetUpdateClosetUpdates
   */
  item?: ClosetItem;
}

/**
 * @export
 * @namespace ClosetUpdateClosetUpdates
 */
export namespace ClosetUpdateClosetUpdates {
  /**
   * @export
   * @enum {string}
   */
  export enum OpEnum {
    Deposit = <any>'deposit',
    Withdraw = <any>'withdraw',
  }
}
/**
 * Represents the count data from a user
 * @export
 * @interface CountUser
 */
export interface CountUser {
  /**
   * Type of data that is counted
   * @type {string}
   * @memberof CountUser
   */
  countType?: string;
  /**
   * Total of counts for the countType
   * @type {number}
   * @memberof CountUser
   */
  count?: number;
}
/**
 *
 * @export
 * @interface ErrorMessage
 */
export interface ErrorMessage {
  /**
   *
   * @type {string}
   * @memberof ErrorMessage
   */
  error?: string;
}
/**
 * Represents the feed object.
 * @export
 * @interface Feed
 */
export interface Feed {
  /**
   * Feed unique identifier
   * @type {string}
   * @memberof Feed
   */
  feedId?: string;
  /**
   * Epoch time of creation
   * @type {number}
   * @memberof Feed
   */
  created?: number;
  /**
   * Cognito ID of the user who created the feed
   * @type {string}
   * @memberof Feed
   */
  creatorId?: string;
  /**
   * Username of the user who created the feed
   * @type {string}
   * @memberof Feed
   */
  creatorPreferredUsername?: string;
  /**
   * Total count of the number of likes on a feed
   * @type {number}
   * @memberof Feed
   */
  countOfLikes?: number;
  /**
   * Boolean of if the user has already liked the feed
   * @type {boolean}
   * @memberof Feed
   */
  likedByUser?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof Feed
   */
  taggedByUser?: Array<string>;
  /**
   *
   * @type {Look}
   * @memberof Feed
   */
  look?: Look;
  /**
   *
   * @type {Array<FeedTag>}
   * @memberof Feed
   */
  tags?: Array<FeedTag>;
  /**
   * Total number of looks that have been published (feeds) for the creator of this feed
   * @type {number}
   * @memberof Feed
   */
  outfitCount?: number;
  /**
   * List of wearables metadata from the look if they are thriftable.
   * @type {Array<Wearable>}
   * @memberof Feed
   */
  thriftables?: Array<Wearable>;
}
/**
 * Represents request to create a feed.
 * @export
 * @interface FeedCreate
 */
export interface FeedCreate {
  /**
   * Look identifier that the feed is created for. If not present, this will create a feed and an id for it.
   * @type {string}
   * @memberof FeedCreate
   */
  lookId?: string;
  /**
   * Addressable id for the animation
   * @type {string}
   * @memberof FeedCreate
   */
  animationId?: string;
  /**
   * Definition for the doll, similar to avatarDefinition
   * @type {string}
   * @memberof FeedCreate
   */
  dollDefinition?: string;
  /**
   * Addressable id for the scene
   * @type {string}
   * @memberof FeedCreate
   */
  sceneId?: string;
  /**
   * Definition for the avatar
   * @type {string}
   * @memberof FeedCreate
   */
  avatarDefinition?: string;
  /**
   * URL for the thumbnail image of the look
   * @type {string}
   * @memberof FeedCreate
   */
  thumbnail?: string;
  /**
   * URL for the video clip of the look
   * @type {string}
   * @memberof FeedCreate
   */
  videoClip?: string;
}
/**
 * Represents response to create a feed.
 * @export
 * @interface FeedCreateResponse
 */
export interface FeedCreateResponse {
  /**
   * Unique identifier for a feed.
   * @type {string}
   * @memberof FeedCreateResponse
   */
  feedId?: string;
}
/**
 * Represents the data on a single feed such as the usernames who liked the feed.
 * @export
 * @interface FeedLikeData
 */
export interface FeedLikeData {
  /**
   * Type of reaction object
   * @type {string}
   * @memberof FeedLikeData
   */
  type?: string;
  /**
   * Feed unique identifier
   * @type {string}
   * @memberof FeedLikeData
   */
  feedId?: string;
  /**
   * The user who sent the like
   * @type {string}
   * @memberof FeedLikeData
   */
  senderId?: string;
  /**
   * The username of the sender who liked the feed
   * @type {string}
   * @memberof FeedLikeData
   */
  senderUsername?: string;
  /**
   * Epoch time of creation of the like
   * @type {number}
   * @memberof FeedLikeData
   */
  created?: number;
}
/**
 * Response object containing the like data and cursor
 * @export
 * @interface FeedLikeDataResponse
 */
export interface FeedLikeDataResponse {
  /**
   *
   * @type {Array<FeedLikeData>}
   * @memberof FeedLikeDataResponse
   */
  likes: Array<FeedLikeData>;
  /**
   * Key to iterate through multiple pages of the response.
   * @type {string}
   * @memberof FeedLikeDataResponse
   */
  nextCursor?: string;
}
/**
 * Represents the feed object response.
 * @export
 * @interface FeedLikeResponse
 */
export interface FeedLikeResponse {
  /**
   * Feed unique identifier
   * @type {string}
   * @memberof FeedLikeResponse
   */
  feedId?: string;
  /**
   * The user who sent the like
   * @type {string}
   * @memberof FeedLikeResponse
   */
  senderId?: string;
  /**
   * The user who made the feed and is getting the like on the feed
   * @type {string}
   * @memberof FeedLikeResponse
   */
  receiverId?: string;
  /**
   * The username of the sender who liked the feed,
   * @type {string}
   * @memberof FeedLikeResponse
   */
  senderUsername?: string;
  /**
   * Epoch time of creation
   * @type {number}
   * @memberof FeedLikeResponse
   */
  created?: number;
}
/**
 * List of feeds that the user can get
 * @export
 * @interface FeedListResponse
 */
export interface FeedListResponse {
  /**
   *
   * @type {Array<Feed>}
   * @memberof FeedListResponse
   */
  data?: Array<Feed>;
  /**
   * Pagination key used to get the next page.
   * @type {string}
   * @memberof FeedListResponse
   */
  nextCursor?: string;
}
/**
 * Represents the feed object response.
 * @export
 * @interface FeedSaveResponse
 */
export interface FeedSaveResponse {
  /**
   * Feed unique identifier
   * @type {string}
   * @memberof FeedSaveResponse
   */
  feedId?: string;
  /**
   * The user who sent the save
   * @type {string}
   * @memberof FeedSaveResponse
   */
  senderId?: string;
  /**
   * The user who made the feed and who's feed is being saved
   * @type {string}
   * @memberof FeedSaveResponse
   */
  receiverId?: string;
  /**
   * The username of the sender who saved the feed,
   * @type {string}
   * @memberof FeedSaveResponse
   */
  senderUsername?: string;
  /**
   * Epoch time of creation
   * @type {number}
   * @memberof FeedSaveResponse
   */
  created?: number;
}
/**
 * Represents the tag data on a single feed item
 * @export
 * @interface FeedTag
 */
export interface FeedTag {
  /**
   * Type of tag
   * @type {string}
   * @memberof FeedTag
   */
  tagType?: string;
  /**
   * Count of tags received
   * @type {number}
   * @memberof FeedTag
   */
  count?: number;
}
/**
 * Represents the feed tag object response.
 * @export
 * @interface FeedTagActivityResponse
 */
export interface FeedTagActivityResponse {
  /**
   * Type of activity
   * @type {string}
   * @memberof FeedTagActivityResponse
   */
  type?: FeedTagActivityResponse.TypeEnum;
  /**
   * Type of tag
   * @type {string}
   * @memberof FeedTagActivityResponse
   */
  tagType?: string;
  /**
   * Feed unique identifier
   * @type {string}
   * @memberof FeedTagActivityResponse
   */
  feedId?: string;
  /**
   * The user who sent the tag
   * @type {string}
   * @memberof FeedTagActivityResponse
   */
  senderId?: string;
  /**
   * Display username of the tag sender
   * @type {string}
   * @memberof FeedTagActivityResponse
   */
  senderUsername?: string;
  /**
   * Epoch time of creation
   * @type {number}
   * @memberof FeedTagActivityResponse
   */
  created?: number;
}

/**
 * @export
 * @namespace FeedTagActivityResponse
 */
export namespace FeedTagActivityResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    TAG = <any>'TAG',
  }
}
/**
 * Represents the feed tag object response.
 * @export
 * @interface FeedTagResponse
 */
export interface FeedTagResponse {
  /**
   * Type of tag
   * @type {string}
   * @memberof FeedTagResponse
   */
  tagType?: string;
  /**
   * Feed unique identifier
   * @type {string}
   * @memberof FeedTagResponse
   */
  feedId?: string;
  /**
   * The user who sent the tag
   * @type {string}
   * @memberof FeedTagResponse
   */
  senderId?: string;
  /**
   * The user who made the feed and is getting the tag on the feed
   * @type {string}
   * @memberof FeedTagResponse
   */
  receiverId?: string;
  /**
   * Epoch time of creation
   * @type {number}
   * @memberof FeedTagResponse
   */
  created?: number;
}
/**
 * Represents metadata used to be sent for in app notification
 * @export
 * @interface FeedThriftActivity
 */
export interface FeedThriftActivity {
  /**
   * Type of notification, \"THRIFTINGFEED\" for this one
   * @type {string}
   * @memberof FeedThriftActivity
   */
  type?: FeedThriftActivity.TypeEnum;
  /**
   * The user who posted a feed with a thrifted wearable
   * @type {string}
   * @memberof FeedThriftActivity
   */
  senderId?: string;
  /**
   * Display username of the user who posted a feed with a thrifted wearable
   * @type {string}
   * @memberof FeedThriftActivity
   */
  senderUsername?: string;
  /**
   * Unique identifier for the feed
   * @type {string}
   * @memberof FeedThriftActivity
   */
  feedId?: string;
  /**
   * Image url of feed thumbnail
   * @type {string}
   * @memberof FeedThriftActivity
   */
  feedThumbnail?: string;
  /**
   * Timestamp of creation
   * @type {number}
   * @memberof FeedThriftActivity
   */
  created?: number;
}

/**
 * @export
 * @namespace FeedThriftActivity
 */
export namespace FeedThriftActivity {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    THRIFTINGFEED = <any>'THRIFTINGFEED',
  }
}
/**
 * Response object listing each follow update
 * @export
 * @interface FollowActivityResponse
 */
export interface FollowActivityResponse {
  /**
   * UserId of the requestor
   * @type {string}
   * @memberof FollowActivityResponse
   */
  followeeId?: string;
  /**
   * UserId of the user who followed the requestor
   * @type {string}
   * @memberof FollowActivityResponse
   */
  followerId?: string;
  /**
   * Timestamp of object activity
   * @type {number}
   * @memberof FollowActivityResponse
   */
  created?: number;
  /**
   * Display username of the follower
   * @type {string}
   * @memberof FollowActivityResponse
   */
  followerUsername?: string;
}
/**
 * Response object listing each follow update
 * @export
 * @interface FollowActivityResponseV2
 */
export interface FollowActivityResponseV2 {
  /**
   * Type of activity
   * @type {string}
   * @memberof FollowActivityResponseV2
   */
  type?: FollowActivityResponseV2.TypeEnum;
  /**
   * UserId of the requestor
   * @type {string}
   * @memberof FollowActivityResponseV2
   */
  followeeId?: string;
  /**
   * UserId of the user who followed the requestor
   * @type {string}
   * @memberof FollowActivityResponseV2
   */
  followerId?: string;
  /**
   * Timestamp of object activity
   * @type {number}
   * @memberof FollowActivityResponseV2
   */
  created?: number;
  /**
   * Display username of the follower
   * @type {string}
   * @memberof FollowActivityResponseV2
   */
  followerUsername?: string;
}

/**
 * @export
 * @namespace FollowActivityResponseV2
 */
export namespace FollowActivityResponseV2 {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    FOLLOW = <any>'FOLLOW',
  }
}
/**
 * Represents the data on of a user to follow
 * @export
 * @interface FollowGetRecommendUser
 */
export interface FollowGetRecommendUser {
  /**
   * Type of reaction object
   * @type {string}
   * @memberof FollowGetRecommendUser
   */
  userId?: string;
  /**
   * Feed unique identifier
   * @type {string}
   * @memberof FollowGetRecommendUser
   */
  username?: string;
}
/**
 * Response object listing the users to recommend to follow
 * @export
 * @interface FollowGetResponse
 */
export interface FollowGetResponse {
  /**
   *
   * @type {Array<FollowGetRecommendUser>}
   * @memberof FollowGetResponse
   */
  users: Array<FollowGetRecommendUser>;
}
/**
 * Represents the get friends response
 * @export
 * @interface FriendsGetResponse
 */
export interface FriendsGetResponse {
  /**
   *
   * @type {Array<UserFriend>}
   * @memberof FriendsGetResponse
   */
  existing?: Array<UserFriend>;
  /**
   *
   * @type {Array<UserFriend>}
   * @memberof FriendsGetResponse
   */
  incoming?: Array<UserFriend>;
  /**
   *
   * @type {Array<UserFriend>}
   * @memberof FriendsGetResponse
   */
  sent?: Array<UserFriend>;
  /**
   *
   * @type {Array<UserFriend>}
   * @memberof FriendsGetResponse
   */
  friendOfFriend?: Array<UserFriend>;
  /**
   *
   * @type {Array<UserFriend>}
   * @memberof FriendsGetResponse
   */
  friended?: Array<UserFriend>;
  /**
   *
   * @type {Array<UserPending>}
   * @memberof FriendsGetResponse
   */
  pending?: Array<UserPending>;
  /**
   * Key to iterate through multiple pages of the response.
   * @type {string}
   * @memberof FriendsGetResponse
   */
  nextCursor?: string;
}
/**
 * Represents the handle incoming friends response
 * @export
 * @interface FriendsHandleResponse
 */
export interface FriendsHandleResponse {
  /**
   *
   * @type {number}
   * @memberof FriendsHandleResponse
   */
  senderAccountCreation?: number;
  /**
   *
   * @type {number}
   * @memberof FriendsHandleResponse
   */
  senderFriendsCount?: number;
  /**
   *
   * @type {number}
   * @memberof FriendsHandleResponse
   */
  receiverAccountCreation?: number;
  /**
   *
   * @type {number}
   * @memberof FriendsHandleResponse
   */
  receiverFriendsCount?: number;
}
/**
 * represent the game feature entity
 * @export
 * @interface GameFeature
 */
export interface GameFeature {
  /**
   *
   * @type {string}
   * @memberof GameFeature
   */
  gameFeatureId: string;
  /**
   *
   * @type {string}
   * @memberof GameFeature
   */
  gameFeatureType: GameFeature.GameFeatureTypeEnum;
  /**
   *
   * @type {string}
   * @memberof GameFeature
   */
  gameFeatureDefinitionJson: string;
}

/**
 * @export
 * @namespace GameFeature
 */
export namespace GameFeature {
  /**
   * @export
   * @enum {string}
   */
  export enum GameFeatureTypeEnum {
    UgcStyles = <any>'UgcStyles',
    UgcCustomPatterns = <any>'UgcCustomPatterns',
    UgcCustomHair = <any>'UgcCustomHair',
    UgcCustomSkin = <any>'UgcCustomSkin',
    UserState = <any>'UserState',
  }
}
/**
 * Represents properties to create a game feature.
 * @export
 * @interface GameFeatureCreate
 */
export interface GameFeatureCreate {
  /**
   *
   * @type {Array<GameFeature>}
   * @memberof GameFeatureCreate
   */
  gameFeatures: Array<GameFeature>;
}
/**
 * Represents properties to update a game feature.
 * @export
 * @interface GameFeatureUpdate
 */
export interface GameFeatureUpdate {
  /**
   *
   * @type {GameFeature}
   * @memberof GameFeatureUpdate
   */
  gameFeature: GameFeature;
}
/**
 * Represents the response from getting blocked list of a user
 * @export
 * @interface GetBidirectionalBlockedUserListResponse
 */
export interface GetBidirectionalBlockedUserListResponse {
  /**
   *
   * @type {Array<UserObject>}
   * @memberof GetBidirectionalBlockedUserListResponse
   */
  blockedUsers?: Array<UserObject>;
  /**
   *
   * @type {Array<UserObject>}
   * @memberof GetBidirectionalBlockedUserListResponse
   */
  blockedByUsers?: Array<UserObject>;
}
/**
 *
 * @export
 * @interface GetChatStatusResponse
 */
export interface GetChatStatusResponse {
  /**
   *
   * @type {string}
   * @memberof GetChatStatusResponse
   */
  status?: GetChatStatusResponse.StatusEnum;
  /**
   *
   * @type {string}
   * @memberof GetChatStatusResponse
   */
  lastAiMessage?: string;
}

/**
 * @export
 * @namespace GetChatStatusResponse
 */
export namespace GetChatStatusResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    ACTIVE = <any>'ACTIVE',
    END = <any>'END',
    NOTSTARTED = <any>'NOT_STARTED',
  }
}
/**
 *
 * @export
 * @interface GetPromptResponse
 */
export interface GetPromptResponse {
  /**
   *
   * @type {Array<GetPromptResponsePrompts>}
   * @memberof GetPromptResponse
   */
  prompts?: Array<GetPromptResponsePrompts>;
}
/**
 *
 * @export
 * @interface GetPromptResponsePrompts
 */
export interface GetPromptResponsePrompts {
  /**
   *
   * @type {string}
   * @memberof GetPromptResponsePrompts
   */
  promptId?: string;
  /**
   *
   * @type {string}
   * @memberof GetPromptResponsePrompts
   */
  promptDescription?: string;
}
/**
 *
 * @export
 * @interface Group
 */
export interface Group {
  /**
   *
   * @type {string}
   * @memberof Group
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Group
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Group
   */
  createdAt?: string;
}
/**
 *
 * @export
 * @interface GroupMembersResponse
 */
export interface GroupMembersResponse {
  /**
   *
   * @type {Array<GroupMembersResponseMembers>}
   * @memberof GroupMembersResponse
   */
  members?: Array<GroupMembersResponseMembers>;
  /**
   *
   * @type {string}
   * @memberof GroupMembersResponse
   */
  nextCursor?: string;
}
/**
 *
 * @export
 * @interface GroupMembersResponseMembers
 */
export interface GroupMembersResponseMembers {
  /**
   *
   * @type {string}
   * @memberof GroupMembersResponseMembers
   */
  userId?: string;
  /**
   *
   * @type {string}
   * @memberof GroupMembersResponseMembers
   */
  nickName?: string;
  /**
   *
   * @type {string}
   * @memberof GroupMembersResponseMembers
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof GroupMembersResponseMembers
   */
  lastName?: string;
}
/**
 *
 * @export
 * @interface GroupsResponse
 */
export interface GroupsResponse {
  /**
   *
   * @type {Array<Group>}
   * @memberof GroupsResponse
   */
  groups?: Array<Group>;
  /**
   *
   * @type {string}
   * @memberof GroupsResponse
   */
  nextCursor?: string;
}
/**
 * Accept or remove friend request
 * @export
 * @interface HandleFriendRequest
 */
export interface HandleFriendRequest {
  /**
   *
   * @type {string}
   * @memberof HandleFriendRequest
   */
  operation?: HandleFriendRequest.OperationEnum;
}

/**
 * @export
 * @namespace HandleFriendRequest
 */
export namespace HandleFriendRequest {
  /**
   * @export
   * @enum {string}
   */
  export enum OperationEnum {
    ACCEPT = <any>'ACCEPT',
    REMOVE = <any>'REMOVE',
  }
}
/**
 *
 * @export
 * @interface ImageResponse
 */
export interface ImageResponse {
  /**
   *
   * @type {string}
   * @memberof ImageResponse
   */
  presignedUrl?: string;
  /**
   *
   * @type {string}
   * @memberof ImageResponse
   */
  distributionUrl?: string;
}
/**
 * Contains subpath of image in s3 bucket
 * @export
 * @interface ImageUpload
 */
export interface ImageUpload {
  /**
   * path of the image located in the same s3 bucket as userImage. users/{userId}/{path}
   * @type {string}
   * @memberof ImageUpload
   */
  path: string;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse200
   */
  message?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse2001
   */
  message?: boolean;
}
/**
 * Represents request to invite a user
 * @export
 * @interface InviteUserRequest
 */
export interface InviteUserRequest {
  /**
   * Phone number of user to generate invite link for
   * @type {string}
   * @memberof InviteUserRequest
   */
  inviteePhoneNumber?: string;
}
/**
 * Represents response to invite a user
 * @export
 * @interface InviteUserResponse
 */
export interface InviteUserResponse {
  /**
   * Unique id of the invitation
   * @type {string}
   * @memberof InviteUserResponse
   */
  inviteId?: string;
  /**
   * UserId of the user who created the invite link
   * @type {string}
   * @memberof InviteUserResponse
   */
  inviterId?: string;
  /**
   * UserId of the user who received the invite
   * @type {string}
   * @memberof InviteUserResponse
   */
  inviteeId?: string;
  /**
   * Phone number of user to generate invite link for
   * @type {string}
   * @memberof InviteUserResponse
   */
  inviteePhoneNumber?: string;
  /**
   * Status of the invitation
   * @type {string}
   * @memberof InviteUserResponse
   */
  status?: InviteUserResponse.StatusEnum;
  /**
   * URL of the invitation
   * @type {string}
   * @memberof InviteUserResponse
   */
  inviteLink?: string;
  /**
   * Time of invitation creation
   * @type {number}
   * @memberof InviteUserResponse
   */
  created?: number;
}

/**
 * @export
 * @namespace InviteUserResponse
 */
export namespace InviteUserResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    Pending = <any>'pending',
    Accepted = <any>'accepted',
    Unknown = <any>'unknown',
  }
}
/**
 * Represents request to update invite of a user
 * @export
 * @interface InviteUserUpdateRequest
 */
export interface InviteUserUpdateRequest {
  /**
   * The userId of the person who is sent the invite request.
   * @type {string}
   * @memberof InviteUserUpdateRequest
   */
  inviterId?: string;
  /**
   * The userId of the invitation that was accepted.
   * @type {string}
   * @memberof InviteUserUpdateRequest
   */
  inviteId?: string;
}
/**
 * Represents response of invites sent
 * @export
 * @interface InvitesSent
 */
export interface InvitesSent {
  /**
   * Unique id of the invitation
   * @type {string}
   * @memberof InvitesSent
   */
  inviteId?: string;
  /**
   * UserId of the user who received the invite
   * @type {string}
   * @memberof InvitesSent
   */
  inviteeId?: string;
  /**
   * Phone number of user to generate invite link for
   * @type {string}
   * @memberof InvitesSent
   */
  inviteePhoneNumber?: string;
  /**
   * Status of the invitation
   * @type {string}
   * @memberof InvitesSent
   */
  status?: InvitesSent.StatusEnum;
  /**
   * Time of invitation creation
   * @type {number}
   * @memberof InvitesSent
   */
  created?: number;
}

/**
 * @export
 * @namespace InvitesSent
 */
export namespace InvitesSent {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    Pending = <any>'pending',
    Accepted = <any>'accepted',
    Unknown = <any>'unknown',
  }
}
/**
 * Response object of the invites sent
 * @export
 * @interface InvitesSentResponse
 */
export interface InvitesSentResponse {
  /**
   *
   * @type {Array<InvitesSent>}
   * @memberof InvitesSentResponse
   */
  invites?: Array<InvitesSent>;
}
/**
 * Represents an individual leaderboard.
 * @export
 * @interface Leaderboard
 */
export interface Leaderboard {
  /**
   * Url for the user's profile picture
   * @type {string}
   * @memberof Leaderboard
   */
  profileImageUrl?: string;
  /**
   * Cognito sub of the user for this position
   * @type {string}
   * @memberof Leaderboard
   */
  userId?: string;
  /**
   * User created display name they gave themselves
   * @type {string}
   * @memberof Leaderboard
   */
  preferredUsername?: string;
  /**
   * Position of this user for the requested tag
   * @type {number}
   * @memberof Leaderboard
   */
  rank?: number;
  /**
   * Total number of looks the user in this position has posted
   * @type {number}
   * @memberof Leaderboard
   */
  outfitCount?: number;
  /**
   * Total number of rates for this user on this tag
   * @type {number}
   * @memberof Leaderboard
   */
  rates?: number;
}
/**
 * Represents an individual leaderboard activity.
 * @export
 * @interface LeaderboardActivity
 */
export interface LeaderboardActivity {
  /**
   * Type of activity
   * @type {string}
   * @memberof LeaderboardActivity
   */
  type?: LeaderboardActivity.TypeEnum;
  /**
   * Type of tag
   * @type {string}
   * @memberof LeaderboardActivity
   */
  tagType?: string;
  /**
   * Position of this user for the requested tag
   * @type {number}
   * @memberof LeaderboardActivity
   */
  rank?: number;
  /**
   * Total number of looks the user in this position has posted
   * @type {number}
   * @memberof LeaderboardActivity
   */
  outfitCount?: number;
  /**
   * timestamp milliseconds
   * @type {number}
   * @memberof LeaderboardActivity
   */
  created?: number;
}

/**
 * @export
 * @namespace LeaderboardActivity
 */
export namespace LeaderboardActivity {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    LEADERBOARD = <any>'LEADERBOARD',
  }
}
/**
 * Represents a response for the list of the users on the leaderboard for a tag.
 * @export
 * @interface LeaderboardResponse
 */
export interface LeaderboardResponse {
  /**
   * Type of tag
   * @type {string}
   * @memberof LeaderboardResponse
   */
  tagType?: string;
  /**
   *
   * @type {Array<Leaderboard>}
   * @memberof LeaderboardResponse
   */
  leaderboard?: Array<Leaderboard>;
  /**
   *
   * @type {Leaderboard}
   * @memberof LeaderboardResponse
   */
  requestorRank?: Leaderboard;
}
/**
 * Represents an individual look.
 * @export
 * @interface Look
 */
export interface Look {
  /**
   * Look UUID
   * @type {string}
   * @memberof Look
   */
  lookId?: string;
  /**
   * User UUID generated from cognito
   * @type {string}
   * @memberof Look
   */
  userId?: string;
  /**
   * Epoch time of creation
   * @type {number}
   * @memberof Look
   */
  created?: number;
  /**
   * Epoch time of last modified this object
   * @type {number}
   * @memberof Look
   */
  lastModified?: number;
  /**
   * Addressable id for the animation
   * @type {string}
   * @memberof Look
   */
  animationId?: string;
  /**
   * Definition for the doll, similar to avatarDefinition
   * @type {string}
   * @memberof Look
   */
  dollDefinition?: string;
  /**
   * Addressable id for the scene
   * @type {string}
   * @memberof Look
   */
  sceneId?: string;
  /**
   * Definition for the avatar
   * @type {string}
   * @memberof Look
   */
  avatarDefinition?: string;
  /**
   * URL for the thumbnail image of the look
   * @type {string}
   * @memberof Look
   */
  thumbnail?: string;
  /**
   * URL for the video clip of the look
   * @type {string}
   * @memberof Look
   */
  videoClip?: string;
  /**
   * Status of the look can be draft or published, when published it will mean it has been created as a feed.
   * @type {string}
   * @memberof Look
   */
  status?: Look.StatusEnum;
  /**
   * Timestamp when the look was exported
   * @type {number}
   * @memberof Look
   */
  exportedAt?: number;
}

/**
 * @export
 * @namespace Look
 */
export namespace Look {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    Default = <any>'default',
    Draft = <any>'draft',
    Published = <any>'published',
  }
}
/**
 * Represents request to create a look.
 * @export
 * @interface LookCreate
 */
export interface LookCreate {
  /**
   * Addressable id for the animation
   * @type {string}
   * @memberof LookCreate
   */
  animationId: string;
  /**
   * Definition for the doll, similar to avatarDefinition
   * @type {string}
   * @memberof LookCreate
   */
  dollDefinition?: string;
  /**
   * Addressable id for the scene
   * @type {string}
   * @memberof LookCreate
   */
  sceneId: string;
  /**
   * Definition for the avatar
   * @type {string}
   * @memberof LookCreate
   */
  avatarDefinition: string;
  /**
   * URL for the thumbnail image of the look
   * @type {string}
   * @memberof LookCreate
   */
  thumbnail?: string;
  /**
   * URL for the video clip of the look
   * @type {string}
   * @memberof LookCreate
   */
  videoClip?: string;
}
/**
 * List of looks.
 * @export
 * @interface LookList
 */
export interface LookList {
  /**
   *
   * @type {Array<Look>}
   * @memberof LookList
   */
  looks: Array<Look>;
}
/**
 * List of looks with pagination.
 * @export
 * @interface LookListPagination
 */
export interface LookListPagination {
  /**
   *
   * @type {Array<Look>}
   * @memberof LookListPagination
   */
  looks?: Array<Look>;
  /**
   * Key to iterate through multiple pages of the response.
   * @type {string}
   * @memberof LookListPagination
   */
  nextCursor?: string;
}
/**
 * Represents request to update a look.
 * @export
 * @interface LookUpdate
 */
export interface LookUpdate {
  /**
   * Addressable id for the animation
   * @type {string}
   * @memberof LookUpdate
   */
  animationId?: string;
  /**
   * Definition for the doll, similar to avatarDefinition
   * @type {string}
   * @memberof LookUpdate
   */
  dollDefinition?: string;
  /**
   * Addressable id for the scene
   * @type {string}
   * @memberof LookUpdate
   */
  sceneId?: string;
  /**
   * Definition for the avatar
   * @type {string}
   * @memberof LookUpdate
   */
  avatarDefinition?: string;
  /**
   * Timestamp the look was shared/exported
   * @type {number}
   * @memberof LookUpdate
   */
  exportedAt?: number;
  /**
   * URL for the thumbnail image of the look
   * @type {string}
   * @memberof LookUpdate
   */
  thumbnail?: string;
  /**
   * URL for the video clip of the look
   * @type {string}
   * @memberof LookUpdate
   */
  videoClip?: string;
}
/**
 *
 * @export
 * @interface MessageResponse
 */
export interface MessageResponse {
  /**
   *
   * @type {string}
   * @memberof MessageResponse
   */
  message?: string;
}
/**
 * Represents properties to mint an nft.
 * @export
 * @interface MintNftInput
 */
export interface MintNftInput {
  /**
   * Uuid used to prevent duplicate requests
   * @type {string}
   * @memberof MintNftInput
   */
  idempotencyKey: string;
  /**
   * User's wallet to recieve this minted nft
   * @type {string}
   * @memberof MintNftInput
   */
  flowReceiverAddress?: string;
  /**
   * Flow identifier of the edition to use to mint from
   * @type {number}
   * @memberof MintNftInput
   */
  editionFlowId?: number;
  /**
   * Amount to mint
   * @type {number}
   * @memberof MintNftInput
   */
  quantity?: number;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  message?: string;
}
/**
 * Mood
 * @export
 * @interface MoodAddRequest
 */
export interface MoodAddRequest {
  /**
   *
   * @type {string}
   * @memberof MoodAddRequest
   */
  sessionId?: string;
}
/**
 * Mood Add
 * @export
 * @interface MoodAddResponse
 */
export interface MoodAddResponse {
  /**
   *
   * @type {string}
   * @memberof MoodAddResponse
   */
  content?: string;
  /**
   *
   * @type {string}
   * @memberof MoodAddResponse
   */
  moodType?: string;
}
/**
 * Mood
 * @export
 * @interface MoodGetResponse
 */
export interface MoodGetResponse {
  /**
   *
   * @type {string}
   * @memberof MoodGetResponse
   */
  mood?: string;
  /**
   *
   * @type {string}
   * @memberof MoodGetResponse
   */
  color?: string;
}
/**
 * Mood
 * @export
 * @interface MoodResponse
 */
export interface MoodResponse {
  /**
   *
   * @type {boolean}
   * @memberof MoodResponse
   */
  moodExists?: boolean;
  /**
   *
   * @type {string}
   * @memberof MoodResponse
   */
  mood?: string;
  /**
   *
   * @type {string}
   * @memberof MoodResponse
   */
  moodType?: string;
}
/**
 * Represents properties to mint a list of Nfts.
 * @export
 * @interface PurchaseNftInput
 */
export interface PurchaseNftInput {
  /**
   * Uuid used to prevent duplicate requests
   * @type {string}
   * @memberof PurchaseNftInput
   */
  idempotencyKey: string;
  /**
   * List of nft flow ids to purchase
   * @type {Array<number>}
   * @memberof PurchaseNftInput
   */
  nfts?: Array<number>;
}
/**
 * Represents reward object
 * @export
 * @interface Reward
 */
export interface Reward {
  /**
   * Unique identifier for the reward condition and its associated item(s).
   * @type {string}
   * @memberof Reward
   */
  rewardId?: string;
  /**
   * Type of reward (wearable/base asset)
   * @type {string}
   * @memberof Reward
   */
  rewardType?: string;
  /**
   * Unique id from mobile cms (airtable)
   * @type {string}
   * @memberof Reward
   */
  rewardItemId?: string;
  /**
   * Addressable id for the item
   * @type {string}
   * @memberof Reward
   */
  assetAddress?: string;
  /**
   * Total number of counts across all events for the reward
   * @type {number}
   * @memberof Reward
   */
  totalActionsRequired?: number;
  /**
   * Current number of events met
   * @type {number}
   * @memberof Reward
   */
  currentActionsMet?: number;
  /**
   * Check if user has acknowleged they received the reward
   * @type {boolean}
   * @memberof Reward
   */
  claimed?: boolean;
  /**
   * Timestamp of update
   * @type {number}
   * @memberof Reward
   */
  updated?: number;
}
/**
 * Represents the reward activity for in app notification
 * @export
 * @interface RewardActivity
 */
export interface RewardActivity {
  /**
   * Type of notification, \"REWARD\" for this one
   * @type {string}
   * @memberof RewardActivity
   */
  type?: RewardActivity.TypeEnum;
  /**
   * Type of reward
   * @type {string}
   * @memberof RewardActivity
   */
  rewardType?: string;
  /**
   * Unique identifier for the reward condition and its associated item(s).
   * @type {string}
   * @memberof RewardActivity
   */
  rewardId?: string;
  /**
   * id from mobile cms (airtable)
   * @type {string}
   * @memberof RewardActivity
   */
  rewardItemId?: string;
  /**
   * Timestamp of creation
   * @type {number}
   * @memberof RewardActivity
   */
  created?: number;
}

/**
 * @export
 * @namespace RewardActivity
 */
export namespace RewardActivity {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    REWARD = <any>'REWARD',
  }
}
/**
 * Represents the response for the get endpoint
 * @export
 * @interface RewardStatusResponse
 */
export interface RewardStatusResponse {
  /**
   *
   * @type {Array<Reward>}
   * @memberof RewardStatusResponse
   */
  rewards?: Array<Reward>;
}
/**
 *
 * @export
 * @interface SendChatMessage
 */
export interface SendChatMessage {
  /**
   *
   * @type {string}
   * @memberof SendChatMessage
   */
  input?: string;
}
/**
 *
 * @export
 * @interface SendChatMessageResponse
 */
export interface SendChatMessageResponse {
  /**
   *
   * @type {string}
   * @memberof SendChatMessageResponse
   */
  ai?: string;
  /**
   *
   * @type {string}
   * @memberof SendChatMessageResponse
   */
  status?: SendChatMessageResponse.StatusEnum;
  /**
   *
   * @type {Array<string>}
   * @memberof SendChatMessageResponse
   */
  traitIds?: Array<string>;
}

/**
 * @export
 * @namespace SendChatMessageResponse
 */
export namespace SendChatMessageResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    ACTIVE = <any>'ACTIVE',
    END = <any>'END',
    NOTSTARTED = <any>'NOT_STARTED',
  }
}
/**
 *
 * @export
 * @interface Space
 */
export interface Space {
  /**
   *
   * @type {string}
   * @memberof Space
   */
  definition?: string;
  /**
   *
   * @type {string}
   * @memberof Space
   */
  initiatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof Space
   */
  lastModifiedBy?: Space.LastModifiedByEnum;
  /**
   *
   * @type {number}
   * @memberof Space
   */
  createdAt?: number;
  /**
   *
   * @type {string}
   * @memberof Space
   */
  createdBy?: string;
}

/**
 * @export
 * @namespace Space
 */
export namespace Space {
  /**
   * @export
   * @enum {string}
   */
  export enum LastModifiedByEnum {
    SYSTEM = <any>'SYSTEM',
    USER = <any>'USER',
  }
}
/**
 *
 * @export
 * @interface SpaceCreateRequest
 */
export interface SpaceCreateRequest {
  /**
   *
   * @type {string}
   * @memberof SpaceCreateRequest
   */
  definition?: string;
}
/**
 *
 * @export
 * @interface SpaceFeed
 */
export interface SpaceFeed {
  /**
   *
   * @type {string}
   * @memberof SpaceFeed
   */
  definition?: string;
  /**
   *
   * @type {string}
   * @memberof SpaceFeed
   */
  initiatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof SpaceFeed
   */
  lastModifiedAt?: number;
  /**
   *
   * @type {number}
   * @memberof SpaceFeed
   */
  createdAt?: number;
  /**
   *
   * @type {string}
   * @memberof SpaceFeed
   */
  createdBy?: string;
  /**
   *
   * @type {Avatar}
   * @memberof SpaceFeed
   */
  avatar?: Avatar;
}
/**
 *
 * @export
 * @interface SpaceFeeds
 */
export interface SpaceFeeds {
  /**
   *
   * @type {Array<SpaceFeed>}
   * @memberof SpaceFeeds
   */
  feed?: Array<SpaceFeed>;
  /**
   *
   * @type {number}
   * @memberof SpaceFeeds
   */
  offset?: number;
}
/**
 *
 * @export
 * @interface SpaceUpdate
 */
export interface SpaceUpdate {
  /**
   *
   * @type {string}
   * @memberof SpaceUpdate
   */
  definition?: string;
  /**
   *
   * @type {string}
   * @memberof SpaceUpdate
   */
  initiatedBy?: SpaceUpdate.InitiatedByEnum;
  /**
   *
   * @type {number}
   * @memberof SpaceUpdate
   */
  lastModifiedBy?: number;
  /**
   *
   * @type {number}
   * @memberof SpaceUpdate
   */
  createdBy?: number;
}

/**
 * @export
 * @namespace SpaceUpdate
 */
export namespace SpaceUpdate {
  /**
   * @export
   * @enum {string}
   */
  export enum InitiatedByEnum {
    SYSTEM = <any>'SYSTEM',
    USER = <any>'USER',
  }
}
/**
 * Represents properties to add a user in a Statsig segment.
 * @export
 * @interface StatsigSegmentListUpdate
 */
export interface StatsigSegmentListUpdate {
  /**
   * segment name. ex. \"some segment name\"
   * @type {string}
   * @memberof StatsigSegmentListUpdate
   */
  segmentName: string;
  /**
   * cognito userId of the user
   * @type {string}
   * @memberof StatsigSegmentListUpdate
   */
  userId: string;
}
/**
 * Represents a single thing
 * @export
 * @interface Thing
 */
export interface Thing {
  /**
   * id of the thing
   * @type {string}
   * @memberof Thing
   */
  thingId?: string;
  /**
   * creator id for thing
   * @type {string}
   * @memberof Thing
   */
  creatorId?: string;
  /**
   *
   * @type {ThingVersion}
   * @memberof Thing
   */
  latestThingVersion?: ThingVersion;
}
/**
 * Response object returing the newly created thing id
 * @export
 * @interface ThingCreateResponse
 */
export interface ThingCreateResponse {
  /**
   * id for the newly created thing
   * @type {string}
   * @memberof ThingCreateResponse
   */
  thingId?: string;
}
/**
 * Response object listing the things associated with the users id
 * @export
 * @interface ThingGetResponse
 */
export interface ThingGetResponse {
  /**
   *
   * @type {Array<Thing>}
   * @memberof ThingGetResponse
   */
  things?: Array<Thing>;
}
/**
 *
 * @export
 * @interface ThingMap
 */
export interface ThingMap {
  /**
   *
   * @type {string}
   * @memberof ThingMap
   */
  key?: string;
  /**
   *
   * @type {string}
   * @memberof ThingMap
   */
  value?: string;
}
/**
 * an array of [key,value] pairs
 * @export
 * @interface ThingMapUpdate
 */
export interface ThingMapUpdate {
  /**
   *
   * @type {Array<ThingMap>}
   * @memberof ThingMapUpdate
   */
  map?: Array<ThingMap>;
}
/**
 * response object of the updated thing version
 * @export
 * @interface ThingMapUpdateResponse
 */
export interface ThingMapUpdateResponse {
  /**
   *
   * @type {string}
   * @memberof ThingMapUpdateResponse
   */
  message?: string;
}
/**
 * Represents metadata associated with thing version
 * @export
 * @interface ThingVersion
 */
export interface ThingVersion {
  /**
   * thing version id
   * @type {string}
   * @memberof ThingVersion
   */
  id?: string;
  /**
   * thing id
   * @type {string}
   * @memberof ThingVersion
   */
  thingId?: string;
  /**
   * review status
   * @type {string}
   * @memberof ThingVersion
   */
  status?: string;
  /**
   * sdk version of thing
   * @type {number}
   * @memberof ThingVersion
   */
  sdkVersion?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof ThingVersion
   */
  protocolIds?: Array<string>;
  /**
   * thing name
   * @type {string}
   * @memberof ThingVersion
   */
  name?: string;
  /**
   * thing description
   * @type {string}
   * @memberof ThingVersion
   */
  description?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ThingVersion
   */
  iconUrl?: Array<string>;
  /**
   * cms id for asset
   * @type {string}
   * @memberof ThingVersion
   */
  cmsId?: string;
  /**
   * user id for reviewer
   * @type {string}
   * @memberof ThingVersion
   */
  reviewerId?: string;
  /**
   * reviewer comment
   * @type {string}
   * @memberof ThingVersion
   */
  reviewerComment?: string;
  /**
   * url for asset in s3
   * @type {string}
   * @memberof ThingVersion
   */
  s3Key?: string;
  /**
   * full sdk string
   * @type {string}
   * @memberof ThingVersion
   */
  fullSdkVersion?: string;
  /**
   * timestamp of creation
   * @type {number}
   * @memberof ThingVersion
   */
  createdAt?: number;
  /**
   * timestamp of last modification
   * @type {number}
   * @memberof ThingVersion
   */
  lastModifiedAt?: number;
  /**
   * version number
   * @type {string}
   * @memberof ThingVersion
   */
  version?: string;
}
/**
 * represents the object to create a new thing version
 * @export
 * @interface ThingVersionCreate
 */
export interface ThingVersionCreate {
  /**
   *
   * @type {string}
   * @memberof ThingVersionCreate
   */
  thingId?: string;
  /**
   *
   * @type {string}
   * @memberof ThingVersionCreate
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ThingVersionCreate
   */
  description?: string;
  /**
   *
   * @type {boolean}
   * @memberof ThingVersionCreate
   */
  isNewAsset?: boolean;
}
/**
 * response object to newly created thing version
 * @export
 * @interface ThingVersionCreateResponse
 */
export interface ThingVersionCreateResponse {
  /**
   *
   * @type {string}
   * @memberof ThingVersionCreateResponse
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ThingVersionCreateResponse
   */
  presignedUrl?: string;
}
/**
 * Response object listing the things versions associated with the thing id
 * @export
 * @interface ThingVersionGetResponse
 */
export interface ThingVersionGetResponse {
  /**
   *
   * @type {Array<ThingVersion>}
   * @memberof ThingVersionGetResponse
   */
  thingVersions?: Array<ThingVersion>;
}
/**
 * represents the object to update a thing version
 * @export
 * @interface ThingVersionPipelineUpdate
 */
export interface ThingVersionPipelineUpdate {
  /**
   *
   * @type {string}
   * @memberof ThingVersionPipelineUpdate
   */
  thingVersionId?: string;
  /**
   *
   * @type {string}
   * @memberof ThingVersionPipelineUpdate
   */
  thingId?: string;
  /**
   *
   * @type {string}
   * @memberof ThingVersionPipelineUpdate
   */
  status?: string;
  /**
   *
   * @type {number}
   * @memberof ThingVersionPipelineUpdate
   */
  sdkVersion?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof ThingVersionPipelineUpdate
   */
  protocolIds?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ThingVersionPipelineUpdate
   */
  iconUrl?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ThingVersionPipelineUpdate
   */
  cmsId?: string;
  /**
   *
   * @type {string}
   * @memberof ThingVersionPipelineUpdate
   */
  reviewerId?: string;
  /**
   *
   * @type {string}
   * @memberof ThingVersionPipelineUpdate
   */
  reviewerComment?: string;
  /**
   *
   * @type {string}
   * @memberof ThingVersionPipelineUpdate
   */
  s3Key?: string;
  /**
   *
   * @type {number}
   * @memberof ThingVersionPipelineUpdate
   */
  contentVersion?: number;
  /**
   *
   * @type {string}
   * @memberof ThingVersionPipelineUpdate
   */
  errorMessage?: string;
  /**
   *
   * @type {string}
   * @memberof ThingVersionPipelineUpdate
   */
  buildStatus?: ThingVersionPipelineUpdate.BuildStatusEnum;
}

/**
 * @export
 * @namespace ThingVersionPipelineUpdate
 */
export namespace ThingVersionPipelineUpdate {
  /**
   * @export
   * @enum {string}
   */
  export enum BuildStatusEnum {
    QUEUED = <any>'QUEUED',
    FAILED = <any>'FAILED',
    WARNING = <any>'WARNING',
    SUCCESS = <any>'SUCCESS',
  }
}
/**
 * represents the object to update a thing version
 * @export
 * @interface ThingVersionUpdate
 */
export interface ThingVersionUpdate {
  /**
   *
   * @type {string}
   * @memberof ThingVersionUpdate
   */
  thingVersionId?: string;
  /**
   *
   * @type {string}
   * @memberof ThingVersionUpdate
   */
  thingId?: string;
  /**
   *
   * @type {string}
   * @memberof ThingVersionUpdate
   */
  status?: string;
  /**
   *
   * @type {number}
   * @memberof ThingVersionUpdate
   */
  sdkVersion?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof ThingVersionUpdate
   */
  protocolIds?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ThingVersionUpdate
   */
  iconUrl?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ThingVersionUpdate
   */
  cmsId?: string;
  /**
   *
   * @type {string}
   * @memberof ThingVersionUpdate
   */
  reviewerId?: string;
  /**
   *
   * @type {string}
   * @memberof ThingVersionUpdate
   */
  reviewerComment?: string;
  /**
   *
   * @type {string}
   * @memberof ThingVersionUpdate
   */
  s3Key?: string;
}
/**
 * response object of the updated thing version
 * @export
 * @interface ThingVersionUpdateResponse
 */
export interface ThingVersionUpdateResponse {
  /**
   *
   * @type {string}
   * @memberof ThingVersionUpdateResponse
   */
  message?: string;
}
/**
 * Response object listing the things associated with the users id
 * @export
 * @interface ThingsAdminGetResponse
 */
export interface ThingsAdminGetResponse {
  /**
   *
   * @type {Array<Thing>}
   * @memberof ThingsAdminGetResponse
   */
  things?: Array<Thing>;
  /**
   *
   * @type {string}
   * @memberof ThingsAdminGetResponse
   */
  cursor?: string;
}
/**
 * Represents metadata used to be sent for in app notification
 * @export
 * @interface ThriftActivity
 */
export interface ThriftActivity {
  /**
   * Type of notification, \"THRIFTING\" for this one
   * @type {string}
   * @memberof ThriftActivity
   */
  type?: ThriftActivity.TypeEnum;
  /**
   * The user who thrifted the wearable
   * @type {string}
   * @memberof ThriftActivity
   */
  senderId?: string;
  /**
   * Display username of the thrift sender
   * @type {string}
   * @memberof ThriftActivity
   */
  senderUsername?: string;
  /**
   * Image url of the wearable icon
   * @type {string}
   * @memberof ThriftActivity
   */
  wearableIconUrl?: string;
  /**
   * Timestamp of creation
   * @type {number}
   * @memberof ThriftActivity
   */
  created?: number;
}

/**
 * @export
 * @namespace ThriftActivity
 */
export namespace ThriftActivity {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    THRIFTING = <any>'THRIFTING',
  }
}
/**
 * Toggle hide or unhide user from comparison list
 * @export
 * @interface ToggleHideComparisonList
 */
export interface ToggleHideComparisonList {
  /**
   *
   * @type {string}
   * @memberof ToggleHideComparisonList
   */
  operation?: ToggleHideComparisonList.OperationEnum;
}

/**
 * @export
 * @namespace ToggleHideComparisonList
 */
export namespace ToggleHideComparisonList {
  /**
   * @export
   * @enum {string}
   */
  export enum OperationEnum {
    HIDE = <any>'HIDE',
    UNHIDE = <any>'UNHIDE',
  }
}
/**
 *
 * @export
 * @interface TokenRequestBody
 */
export interface TokenRequestBody {
  /**
   *
   * @type {string}
   * @memberof TokenRequestBody
   */
  provider?: TokenRequestBody.ProviderEnum;
  /**
   *
   * @type {string}
   * @memberof TokenRequestBody
   */
  refreshToken?: string;
  /**
   *
   * @type {string}
   * @memberof TokenRequestBody
   */
  accessToken?: string;
  /**
   *
   * @type {string}
   * @memberof TokenRequestBody
   */
  tokenType?: string;
  /**
   *
   * @type {string}
   * @memberof TokenRequestBody
   */
  scope?: string;
  /**
   *
   * @type {number}
   * @memberof TokenRequestBody
   */
  updatedAt?: number;
  /**
   *
   * @type {number}
   * @memberof TokenRequestBody
   */
  expireAt?: number;
}

/**
 * @export
 * @namespace TokenRequestBody
 */
export namespace TokenRequestBody {
  /**
   * @export
   * @enum {string}
   */
  export enum ProviderEnum {
    SPOTIFY = <any>'SPOTIFY',
  }
}
/**
 *
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
  /**
   *
   * @type {string}
   * @memberof TokenResponse
   */
  refreshToken?: string;
  /**
   *
   * @type {string}
   * @memberof TokenResponse
   */
  accessToken?: string;
  /**
   *
   * @type {string}
   * @memberof TokenResponse
   */
  tokenType?: string;
  /**
   *
   * @type {string}
   * @memberof TokenResponse
   */
  scope?: string;
  /**
   *
   * @type {number}
   * @memberof TokenResponse
   */
  updatedAt?: number;
  /**
   *
   * @type {number}
   * @memberof TokenResponse
   */
  expireAt?: number;
  /**
   *
   * @type {string}
   * @memberof TokenResponse
   */
  provider?: string;
}
/**
 * Represents the response to a request that blocks a user
 * @export
 * @interface UpdateBlockUserResponse
 */
export interface UpdateBlockUserResponse {
  /**
   * type of action
   * @type {string}
   * @memberof UpdateBlockUserResponse
   */
  type?: string;
  /**
   * userid the action is applied to
   * @type {string}
   * @memberof UpdateBlockUserResponse
   */
  blockedUserId?: string;
}
/**
 * Represents an individual user.
 * @export
 * @interface User
 */
export interface User {
  /**
   * User UUID
   * @type {string}
   * @memberof User
   */
  userId?: string;
  /**
   * Account status
   * @type {string}
   * @memberof User
   */
  accountStatus?: string;
  /**
   *
   * @type {number}
   * @memberof User
   */
  created?: number;
  /**
   *
   * @type {number}
   * @memberof User
   */
  lastModified?: number;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email?: string;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  emailVerified?: boolean;
  /**
   *
   * @type {string}
   * @memberof User
   */
  phoneNumber?: string;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  phoneNumberVerified?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof User
   */
  groups?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof User
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  preferredUsername?: string;
}
/**
 * Represents a single user to compare
 * @export
 * @interface UserComparison
 */
export interface UserComparison {
  /**
   * Unique identifier for the user from cognito
   * @type {string}
   * @memberof UserComparison
   */
  userId?: string;
  /**
   * User defined username for them (preferred username from cognito)
   * @type {string}
   * @memberof UserComparison
   */
  username?: string;
  /**
   * User defined first name
   * @type {string}
   * @memberof UserComparison
   */
  firstName?: string;
  /**
   * User defined last name
   * @type {string}
   * @memberof UserComparison
   */
  lastName?: string;
}
/**
 * Represents a list of users to compare
 * @export
 * @interface UserComparisonList
 */
export interface UserComparisonList {
  /**
   *
   * @type {Array<UserComparison>}
   * @memberof UserComparisonList
   */
  comparisonList?: Array<UserComparison>;
}
/**
 * Represents a single user contact
 * @export
 * @interface UserContact
 */
export interface UserContact {
  /**
   * Unique identifier for the user from cognito
   * @type {string}
   * @memberof UserContact
   */
  sub?: string;
  /**
   * User defined username for them (preferred username from cognito)
   * @type {string}
   * @memberof UserContact
   */
  username?: string;
  /**
   * Phone number of the user
   * @type {string}
   * @memberof UserContact
   */
  phoneNumber?: string;
  /**
   * User defined first name
   * @type {string}
   * @memberof UserContact
   */
  firstName?: string;
  /**
   * User defined last name
   * @type {string}
   * @memberof UserContact
   */
  lastName?: string;
}
/**
 * Represents the request body to check the user's contacts
 * @export
 * @interface UserContactRequest
 */
export interface UserContactRequest {
  /**
   *
   * @type {Array<UserContactRequestContacts>}
   * @memberof UserContactRequest
   */
  contacts?: Array<UserContactRequestContacts>;
}
/**
 *
 * @export
 * @interface UserContactRequestContacts
 */
export interface UserContactRequestContacts {
  /**
   *
   * @type {string}
   * @memberof UserContactRequestContacts
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof UserContactRequestContacts
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof UserContactRequestContacts
   */
  lastName?: string;
}
/**
 * Represents the response that to checked the user's contacts
 * @export
 * @interface UserContactResponse
 */
export interface UserContactResponse {
  /**
   *
   * @type {Array<UserContact>}
   * @memberof UserContactResponse
   */
  contacts?: Array<UserContact>;
}
/**
 * Represents a single friend
 * @export
 * @interface UserFriend
 */
export interface UserFriend {
  /**
   * Unique identifier for the user from cognito
   * @type {string}
   * @memberof UserFriend
   */
  userId?: string;
  /**
   * User defined username for them (preferred username from cognito)
   * @type {string}
   * @memberof UserFriend
   */
  username?: string;
  /**
   * User defined first name
   * @type {string}
   * @memberof UserFriend
   */
  firstName?: string;
  /**
   * User defined last name
   * @type {string}
   * @memberof UserFriend
   */
  lastName?: string;
  /**
   * Time last updated in epoch
   * @type {number}
   * @memberof UserFriend
   */
  updatedAt?: number;
}
/**
 * Represents properties of a user's expressive trait.
 * @export
 * @interface UserGetArchetypeResponse
 */
export interface UserGetArchetypeResponse {
  /**
   *
   * @type {string}
   * @memberof UserGetArchetypeResponse
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof UserGetArchetypeResponse
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof UserGetArchetypeResponse
   */
  cmsId?: string;
  /**
   *
   * @type {string}
   * @memberof UserGetArchetypeResponse
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof UserGetArchetypeResponse
   */
  created?: number;
}
/**
 * Represents properties of a user's expressive trait.
 * @export
 * @interface UserGetExpressiveTrait
 */
export interface UserGetExpressiveTrait {
  /**
   *
   * @type {string}
   * @memberof UserGetExpressiveTrait
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof UserGetExpressiveTrait
   */
  title?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof UserGetExpressiveTrait
   */
  associatedTraitIds?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof UserGetExpressiveTrait
   */
  description?: Array<string>;
  /**
   *
   * @type {number}
   * @memberof UserGetExpressiveTrait
   */
  created?: number;
}
/**
 * Represents properties of a user's expressive traitresponse.
 * @export
 * @interface UserGetExpressiveTraitResponse
 */
export interface UserGetExpressiveTraitResponse {
  /**
   *
   * @type {Array<UserGetExpressiveTrait>}
   * @memberof UserGetExpressiveTraitResponse
   */
  expressive?: Array<UserGetExpressiveTrait>;
}
/**
 *
 * @export
 * @interface UserGetTraitsResponse
 */
export interface UserGetTraitsResponse {
  /**
   *
   * @type {Array<UserGetTraitsResponseTraits>}
   * @memberof UserGetTraitsResponse
   */
  traits?: Array<UserGetTraitsResponseTraits>;
}
/**
 *
 * @export
 * @interface UserGetTraitsResponseTraits
 */
export interface UserGetTraitsResponseTraits {
  /**
   *
   * @type {string}
   * @memberof UserGetTraitsResponseTraits
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof UserGetTraitsResponseTraits
   */
  type?: UserGetTraitsResponseTraits.TypeEnum;
  /**
   *
   * @type {string}
   * @memberof UserGetTraitsResponseTraits
   */
  cmsId?: string;
  /**
   *
   * @type {string}
   * @memberof UserGetTraitsResponseTraits
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof UserGetTraitsResponseTraits
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof UserGetTraitsResponseTraits
   */
  percentage?: number;
  /**
   *
   * @type {number}
   * @memberof UserGetTraitsResponseTraits
   */
  score?: number;
}

/**
 * @export
 * @namespace UserGetTraitsResponseTraits
 */
export namespace UserGetTraitsResponseTraits {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    PERSONAL = <any>'PERSONAL',
    PHYSICAL = <any>'PHYSICAL',
    EXPRESS = <any>'EXPRESS',
  }
}
/**
 * Represents a user image to be uploaded
 * @export
 * @interface UserImageUpload
 */
export interface UserImageUpload {
  /**
   * User image to store as base64 bytes.
   * @type {Blob}
   * @memberof UserImageUpload
   */
  image: Blob;
  /**
   *
   * @type {string}
   * @memberof UserImageUpload
   */
  imgType: UserImageUpload.ImgTypeEnum;
}

/**
 * @export
 * @namespace UserImageUpload
 */
export namespace UserImageUpload {
  /**
   * @export
   * @enum {string}
   */
  export enum ImgTypeEnum {
    AvatarProfile = <any>'avatar_profile',
  }
}
/**
 * Represents a single user contact
 * @export
 * @interface UserObject
 */
export interface UserObject {
  /**
   * User defined username for them (preferred username from cognito)
   * @type {string}
   * @memberof UserObject
   */
  username?: string;
  /**
   * id of the user
   * @type {string}
   * @memberof UserObject
   */
  userId?: string;
}
/**
 * Represents response of a pending user invite
 * @export
 * @interface UserPending
 */
export interface UserPending {
  /**
   * Unique id of the invitation
   * @type {string}
   * @memberof UserPending
   */
  inviteId?: string;
  /**
   * UserId of the user who received the invite
   * @type {string}
   * @memberof UserPending
   */
  inviteeId?: string;
  /**
   * Phone number of user to generate invite link for
   * @type {string}
   * @memberof UserPending
   */
  inviteePhoneNumber?: string;
  /**
   * Time of invitation creation
   * @type {number}
   * @memberof UserPending
   */
  updatedAt?: number;
}
/**
 * Represents the response to the user's stats
 * @export
 * @interface UserStatsResponse
 */
export interface UserStatsResponse {
  /**
   * List of tags that the user has received and their associated count
   * @type {Array<FeedTag>}
   * @memberof UserStatsResponse
   */
  tags?: Array<FeedTag>;
  /**
   * 'OUTFIT' count of feeds posted. 'SAVE' count of feeds saved/liked. 'WEARABLES' count of wearables created. 'THRIFTED_ITEMS' number of times other users has thrifted from this user on the profile page.
   * @type {Array<CountUser>}
   * @memberof UserStatsResponse
   */
  counts?: Array<CountUser>;
}
/**
 *
 * @export
 * @interface UserTraitsUpdate
 */
export interface UserTraitsUpdate {
  /**
   *
   * @type {Array<UserTraitsUpdateTraits>}
   * @memberof UserTraitsUpdate
   */
  traits?: Array<UserTraitsUpdateTraits>;
}
/**
 *
 * @export
 * @interface UserTraitsUpdateTraits
 */
export interface UserTraitsUpdateTraits {
  /**
   *
   * @type {string}
   * @memberof UserTraitsUpdateTraits
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof UserTraitsUpdateTraits
   */
  size?: UserTraitsUpdateTraits.SizeEnum;
}

/**
 * @export
 * @namespace UserTraitsUpdateTraits
 */
export namespace UserTraitsUpdateTraits {
  /**
   * @export
   * @enum {string}
   */
  export enum SizeEnum {
    S = <any>'S',
    M = <any>'M',
    L = <any>'L',
  }
}
/**
 * Represents properties a user can update
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
  /**
   *
   * @type {string}
   * @memberof UserUpdate
   */
  preferredUsername?: string;
}
/**
 *
 * @export
 * @interface WalletAsyncResponse
 */
export interface WalletAsyncResponse {
  /**
   * Blockchain transaction id of the operation, pending to be finished.
   * @type {string}
   * @memberof WalletAsyncResponse
   */
  txnId?: string;
}
/**
 * Represents properties to create wallet.
 * @export
 * @interface WalletCreate
 */
export interface WalletCreate {
  /**
   * Blockchain to create wallet for
   * @type {string}
   * @memberof WalletCreate
   */
  blockchain: WalletCreate.BlockchainEnum;
  /**
   * Uuid used to prevent duplicate requests
   * @type {string}
   * @memberof WalletCreate
   */
  idempotencyKey: string;
}

/**
 * @export
 * @namespace WalletCreate
 */
export namespace WalletCreate {
  /**
   * @export
   * @enum {string}
   */
  export enum BlockchainEnum {
    Flow = <any>'flow',
  }
}
/**
 * Represents properties of a wallet.
 * @export
 * @interface WalletData
 */
export interface WalletData {
  /**
   * Blockchain to create wallet for
   * @type {string}
   * @memberof WalletData
   */
  blockchain?: WalletData.BlockchainEnum;
  /**
   * Cognito sub of the owner
   * @type {string}
   * @memberof WalletData
   */
  userId?: string;
  /**
   * Address of the wallet on the blockchain
   * @type {string}
   * @memberof WalletData
   */
  address?: string;
}

/**
 * @export
 * @namespace WalletData
 */
export namespace WalletData {
  /**
   * @export
   * @enum {string}
   */
  export enum BlockchainEnum {
    Flow = <any>'flow',
  }
}
/**
 * Represents response of delete wallet.
 * @export
 * @interface WalletDeleteResponse
 */
export interface WalletDeleteResponse {
  /**
   * Blockchain to create wallet for
   * @type {string}
   * @memberof WalletDeleteResponse
   */
  blockchain?: WalletDeleteResponse.BlockchainEnum;
  /**
   * Cognito sub of the owner
   * @type {string}
   * @memberof WalletDeleteResponse
   */
  userId?: string;
}

/**
 * @export
 * @namespace WalletDeleteResponse
 */
export namespace WalletDeleteResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum BlockchainEnum {
    Flow = <any>'flow',
  }
}
/**
 * Represents properties of a wallet payment.
 * @export
 * @interface WalletPaymentData
 */
export interface WalletPaymentData {
  /**
   * Payment identifier for the user
   * @type {string}
   * @memberof WalletPaymentData
   */
  paymentAccountId?: string;
}
/**
 * Represents properties of a user's wallet and payment.
 * @export
 * @interface WalletUserData
 */
export interface WalletUserData {
  /**
   * Wallet data
   * @type {Array<WalletData>}
   * @memberof WalletUserData
   */
  wallets?: Array<WalletData>;
  /**
   *
   * @type {WalletPaymentData}
   * @memberof WalletUserData
   */
  payments?: WalletPaymentData;
}
/**
 * Represents an individual wearable.
 * @export
 * @interface Wearable
 */
export interface Wearable {
  /**
   * Wearable unique identifier for the skin
   * @type {string}
   * @memberof Wearable
   */
  wearableId: string;
  /**
   *
   * @type {number}
   * @memberof Wearable
   */
  created: number;
  /**
   *
   * @type {number}
   * @memberof Wearable
   */
  lastModified: number;
  /**
   * Internal name of asset with skin uuid
   * @type {string}
   * @memberof Wearable
   */
  fullAssetName: string;
  /**
   *
   * @type {string}
   * @memberof Wearable
   */
  displayName?: string;
  /**
   * Internal name of asset
   * @type {string}
   * @memberof Wearable
   */
  baseAssetName?: string;
  /**
   *
   * @type {string}
   * @memberof Wearable
   */
  category?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Wearable
   */
  tags?: Array<string>;
  /**
   * Cloudfront url of the icon.
   * @type {string}
   * @memberof Wearable
   */
  iconUrl?: string;
  /**
   * Description of asset
   * @type {string}
   * @memberof Wearable
   */
  description?: string;
  /**
   * JSON string representation of the wearable definition
   * @type {string}
   * @memberof Wearable
   */
  wearableDefinition: string;
  /**
   * Cognito unique identifier for a user who made this wearable
   * @type {string}
   * @memberof Wearable
   */
  createdBy: string;
  /**
   * Status if the wearable is able to be thrifted or not
   * @type {boolean}
   * @memberof Wearable
   */
  thriftable?: boolean;
}
/**
 * Represents properties to create wearable.
 * @export
 * @interface WearableCreate
 */
export interface WearableCreate {
  /**
   * Wearable unique identifier for the skin
   * @type {string}
   * @memberof WearableCreate
   */
  wearableId?: string;
  /**
   *
   * @type {string}
   * @memberof WearableCreate
   */
  displayName?: string;
  /**
   * Pass this to update an existing wearable
   * @type {string}
   * @memberof WearableCreate
   */
  fullAssetName?: string;
  /**
   * Internal name of asset
   * @type {string}
   * @memberof WearableCreate
   */
  baseAssetName: string;
  /**
   *
   * @type {string}
   * @memberof WearableCreate
   */
  category?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof WearableCreate
   */
  tags?: Array<string>;
  /**
   * Icon image to store as base64 bytes.
   * @type {Blob}
   * @memberof WearableCreate
   */
  icon?: Blob;
  /**
   * Description of asset
   * @type {string}
   * @memberof WearableCreate
   */
  description?: string;
  /**
   * JSON string representation of the wearable definition
   * @type {string}
   * @memberof WearableCreate
   */
  wearableDefinition: string;
  /**
   * Cognito unique identifier for a user who made this wearable
   * @type {string}
   * @memberof WearableCreate
   */
  createdBy: string;
  /**
   * a flag to set a wearable as thriftable/nonthriftable
   * @type {boolean}
   * @memberof WearableCreate
   */
  thriftable?: boolean;
}
/**
 * List of wearables.
 * @export
 * @interface WearableList
 */
export interface WearableList {
  /**
   *
   * @type {Array<Wearable>}
   * @memberof WearableList
   */
  wearables: Array<Wearable>;
}
/**
 * List of wearables for thirft shop.
 * @export
 * @interface WearableThriftList
 */
export interface WearableThriftList {
  /**
   *
   * @type {Array<Wearable>}
   * @memberof WearableThriftList
   */
  wearables: Array<Wearable>;
  /**
   * Total count of all thriftable wearables
   * @type {number}
   * @memberof WearableThriftList
   */
  count?: number;
  /**
   *
   * @type {string}
   * @memberof WearableThriftList
   */
  nextCursor?: string;
}
/**
 * Represents properties to update wearable.
 * @export
 * @interface WearableUpdate
 */
export interface WearableUpdate {
  /**
   * Wearable unique identifier for the skin
   * @type {string}
   * @memberof WearableUpdate
   */
  wearableId: string;
  /**
   *
   * @type {string}
   * @memberof WearableUpdate
   */
  displayName?: string;
  /**
   * Description of wearable
   * @type {string}
   * @memberof WearableUpdate
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof WearableUpdate
   */
  thriftable?: WearableUpdate.ThriftableEnum;
}

/**
 * @export
 * @namespace WearableUpdate
 */
export namespace WearableUpdate {
  /**
   * @export
   * @enum {string}
   */
  export enum ThriftableEnum {
    THRIFTABLE = <any>'THRIFTABLE',
    NONTHRIFTABLE = <any>'NONTHRIFTABLE',
  }
}
/**
 * List of wearable updates.
 * @export
 * @interface WearableUpdateList
 */
export interface WearableUpdateList {
  /**
   *
   * @type {Array<WearableUpdate>}
   * @memberof WearableUpdateList
   */
  wearables: Array<WearableUpdate>;
}
/**
 * AvatarApi - fetch parameter creator
 * @export
 */
export const AvatarApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Creates a new avatar. If no ownerId (userId) is specified, the avatar is associated with the currently authorized user.
     * @summary Create a new avatar
     * @param {Avatar} body Avatar object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAvatar(body: Avatar, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createAvatar.',
        );
      }
      const localVarPath = `/avatar`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'Avatar' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes an avatar if it exists
     * @param {string} avatarId Avatar ID to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAvatar(avatarId: string, options: any = {}): FetchArgs {
      // verify required parameter 'avatarId' is not null or undefined
      if (avatarId === null || avatarId === undefined) {
        throw new RequiredError(
          'avatarId',
          'Required parameter avatarId was null or undefined when calling deleteAvatar.',
        );
      }
      const localVarPath = `/avatar/{avatarId}`.replace(
        `{${'avatarId'}}`,
        encodeURIComponent(String(avatarId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns an avatar
     * @summary Get avatar by ID
     * @param {string} avatarId ID of avatar to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAvatar(avatarId: string, options: any = {}): FetchArgs {
      // verify required parameter 'avatarId' is not null or undefined
      if (avatarId === null || avatarId === undefined) {
        throw new RequiredError(
          'avatarId',
          'Required parameter avatarId was null or undefined when calling getAvatar.',
        );
      }
      const localVarPath = `/avatar/{avatarId}`.replace(
        `{${'avatarId'}}`,
        encodeURIComponent(String(avatarId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of avatar IDs
     * @summary Get available avatars from a user
     * @param {string} [userId] The owning userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAvatars(userId?: string, options: any = {}): FetchArgs {
      const localVarPath = `/avatar`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update an existing avatar
     * @param {Avatar} body Avatar object
     * @param {string} avatarId ID of avatar to update
     * @param {string} [userId] The owning userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAvatar(
      body: Avatar,
      avatarId: string,
      userId?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateAvatar.',
        );
      }
      // verify required parameter 'avatarId' is not null or undefined
      if (avatarId === null || avatarId === undefined) {
        throw new RequiredError(
          'avatarId',
          'Required parameter avatarId was null or undefined when calling updateAvatar.',
        );
      }
      const localVarPath = `/avatar/{avatarId}`.replace(
        `{${'avatarId'}}`,
        encodeURIComponent(String(avatarId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'Avatar' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AvatarApi - functional programming interface
 * @export
 */
export const AvatarApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Creates a new avatar. If no ownerId (userId) is specified, the avatar is associated with the currently authorized user.
     * @summary Create a new avatar
     * @param {Avatar} body Avatar object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAvatar(
      body: Avatar,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Avatar> {
      const localVarFetchArgs = AvatarApiFetchParamCreator(
        configuration,
      ).createAvatar(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Deletes an avatar if it exists
     * @param {string} avatarId Avatar ID to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAvatar(
      avatarId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
      const localVarFetchArgs = AvatarApiFetchParamCreator(
        configuration,
      ).deleteAvatar(avatarId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns an avatar
     * @summary Get avatar by ID
     * @param {string} avatarId ID of avatar to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAvatar(
      avatarId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Avatar> {
      const localVarFetchArgs = AvatarApiFetchParamCreator(
        configuration,
      ).getAvatar(avatarId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of avatar IDs
     * @summary Get available avatars from a user
     * @param {string} [userId] The owning userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAvatars(
      userId?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Avatar>> {
      const localVarFetchArgs = AvatarApiFetchParamCreator(
        configuration,
      ).getAvatars(userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update an existing avatar
     * @param {Avatar} body Avatar object
     * @param {string} avatarId ID of avatar to update
     * @param {string} [userId] The owning userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAvatar(
      body: Avatar,
      avatarId: string,
      userId?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = AvatarApiFetchParamCreator(
        configuration,
      ).updateAvatar(body, avatarId, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * AvatarApi - factory interface
 * @export
 */
export const AvatarApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Creates a new avatar. If no ownerId (userId) is specified, the avatar is associated with the currently authorized user.
     * @summary Create a new avatar
     * @param {Avatar} body Avatar object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAvatar(body: Avatar, options?: any) {
      return AvatarApiFp(configuration).createAvatar(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Deletes an avatar if it exists
     * @param {string} avatarId Avatar ID to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAvatar(avatarId: string, options?: any) {
      return AvatarApiFp(configuration).deleteAvatar(avatarId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Returns an avatar
     * @summary Get avatar by ID
     * @param {string} avatarId ID of avatar to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAvatar(avatarId: string, options?: any) {
      return AvatarApiFp(configuration).getAvatar(avatarId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Returns a list of avatar IDs
     * @summary Get available avatars from a user
     * @param {string} [userId] The owning userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAvatars(userId?: string, options?: any) {
      return AvatarApiFp(configuration).getAvatars(userId, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Update an existing avatar
     * @param {Avatar} body Avatar object
     * @param {string} avatarId ID of avatar to update
     * @param {string} [userId] The owning userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAvatar(
      body: Avatar,
      avatarId: string,
      userId?: string,
      options?: any,
    ) {
      return AvatarApiFp(configuration).updateAvatar(
        body,
        avatarId,
        userId,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * AvatarApi - object-oriented interface
 * @export
 * @class AvatarApi
 * @extends {BaseAPI}
 */
export class AvatarApi extends BaseAPI {
  /**
   * Creates a new avatar. If no ownerId (userId) is specified, the avatar is associated with the currently authorized user.
   * @summary Create a new avatar
   * @param {Avatar} body Avatar object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AvatarApi
   */
  public createAvatar(body: Avatar, options?: any) {
    return AvatarApiFp(this.configuration).createAvatar(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Deletes an avatar if it exists
   * @param {string} avatarId Avatar ID to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AvatarApi
   */
  public deleteAvatar(avatarId: string, options?: any) {
    return AvatarApiFp(this.configuration).deleteAvatar(avatarId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Returns an avatar
   * @summary Get avatar by ID
   * @param {string} avatarId ID of avatar to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AvatarApi
   */
  public getAvatar(avatarId: string, options?: any) {
    return AvatarApiFp(this.configuration).getAvatar(avatarId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Returns a list of avatar IDs
   * @summary Get available avatars from a user
   * @param {string} [userId] The owning userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AvatarApi
   */
  public getAvatars(userId?: string, options?: any) {
    return AvatarApiFp(this.configuration).getAvatars(userId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Update an existing avatar
   * @param {Avatar} body Avatar object
   * @param {string} avatarId ID of avatar to update
   * @param {string} [userId] The owning userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AvatarApi
   */
  public updateAvatar(
    body: Avatar,
    avatarId: string,
    userId?: string,
    options?: any,
  ) {
    return AvatarApiFp(this.configuration).updateAvatar(
      body,
      avatarId,
      userId,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * ChatApi - fetch parameter creator
 * @export
 */
export const ChatApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * (uses chat domain chat.{env}.genies.com)
     * @summary Get the chat status given a prompt id.
     * @param {string} promptId id of the prompt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChatStatus(promptId: string, options: any = {}): FetchArgs {
      // verify required parameter 'promptId' is not null or undefined
      if (promptId === null || promptId === undefined) {
        throw new RequiredError(
          'promptId',
          'Required parameter promptId was null or undefined when calling getChatStatus.',
        );
      }
      const localVarPath = `/chat/status/{promptId}`.replace(
        `{${'promptId'}}`,
        encodeURIComponent(String(promptId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (uses chat domain chat.{env}.genies.com)
     * @summary Send a message to the chat service.
     * @param {SendChatMessage} body Chat message object
     * @param {string} promptId id of the prompt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendChatMessage(
      body: SendChatMessage,
      promptId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling sendChatMessage.',
        );
      }
      // verify required parameter 'promptId' is not null or undefined
      if (promptId === null || promptId === undefined) {
        throw new RequiredError(
          'promptId',
          'Required parameter promptId was null or undefined when calling sendChatMessage.',
        );
      }
      const localVarPath = `/chat/{promptId}`.replace(
        `{${'promptId'}}`,
        encodeURIComponent(String(promptId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'SendChatMessage' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ChatApi - functional programming interface
 * @export
 */
export const ChatApiFp = function (configuration?: Configuration) {
  return {
    /**
     * (uses chat domain chat.{env}.genies.com)
     * @summary Get the chat status given a prompt id.
     * @param {string} promptId id of the prompt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChatStatus(
      promptId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GetChatStatusResponse> {
      const localVarFetchArgs = ChatApiFetchParamCreator(
        configuration,
      ).getChatStatus(promptId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * (uses chat domain chat.{env}.genies.com)
     * @summary Send a message to the chat service.
     * @param {SendChatMessage} body Chat message object
     * @param {string} promptId id of the prompt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendChatMessage(
      body: SendChatMessage,
      promptId: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<SendChatMessageResponse> {
      const localVarFetchArgs = ChatApiFetchParamCreator(
        configuration,
      ).sendChatMessage(body, promptId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ChatApi - factory interface
 * @export
 */
export const ChatApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * (uses chat domain chat.{env}.genies.com)
     * @summary Get the chat status given a prompt id.
     * @param {string} promptId id of the prompt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChatStatus(promptId: string, options?: any) {
      return ChatApiFp(configuration).getChatStatus(promptId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * (uses chat domain chat.{env}.genies.com)
     * @summary Send a message to the chat service.
     * @param {SendChatMessage} body Chat message object
     * @param {string} promptId id of the prompt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendChatMessage(body: SendChatMessage, promptId: string, options?: any) {
      return ChatApiFp(configuration).sendChatMessage(
        body,
        promptId,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * ChatApi - object-oriented interface
 * @export
 * @class ChatApi
 * @extends {BaseAPI}
 */
export class ChatApi extends BaseAPI {
  /**
   * (uses chat domain chat.{env}.genies.com)
   * @summary Get the chat status given a prompt id.
   * @param {string} promptId id of the prompt
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatApi
   */
  public getChatStatus(promptId: string, options?: any) {
    return ChatApiFp(this.configuration).getChatStatus(promptId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * (uses chat domain chat.{env}.genies.com)
   * @summary Send a message to the chat service.
   * @param {SendChatMessage} body Chat message object
   * @param {string} promptId id of the prompt
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatApi
   */
  public sendChatMessage(
    body: SendChatMessage,
    promptId: string,
    options?: any,
  ) {
    return ChatApiFp(this.configuration).sendChatMessage(
      body,
      promptId,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * ClosetApi - fetch parameter creator
 * @export
 */
export const ClosetApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns a list of asset IDs (uses shim domain, api.{env}.genies)
     * @summary An avatar's closet of assets
     * @param {string} userId ID of the owning user
     * @param {string} [itemType] item type to fetch [wearable, things, NFT, NFT and Wearables]
     * @param {string} [minSdkVersion] the mini sdk version, only needed if the type is 2 (things)
     * @param {Array<string>} [protocols] the array of protocols needed, only needed if the type is 2 (things)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCloset(
      userId: string,
      itemType?: string,
      minSdkVersion?: string,
      protocols?: Array<string>,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getCloset.',
        );
      }
      const localVarPath = `/user/{userId}/closet`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (itemType !== undefined) {
        localVarQueryParameter['itemType'] = itemType;
      }

      if (minSdkVersion !== undefined) {
        localVarQueryParameter['minSdkVersion'] = minSdkVersion;
      }

      if (protocols) {
        localVarQueryParameter['protocols'] = protocols;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Modifies a user's closet (uses shim domain, api.{env}.genies)
     * @summary A user's closet of assets
     * @param {ClosetUpdate} body Closet operation
     * @param {string} userId ID of the owning user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCloset(
      body: ClosetUpdate,
      userId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateCloset.',
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling updateCloset.',
        );
      }
      const localVarPath = `/user/{userId}/closet`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'ClosetUpdate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ClosetApi - functional programming interface
 * @export
 */
export const ClosetApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Returns a list of asset IDs (uses shim domain, api.{env}.genies)
     * @summary An avatar's closet of assets
     * @param {string} userId ID of the owning user
     * @param {string} [itemType] item type to fetch [wearable, things, NFT, NFT and Wearables]
     * @param {string} [minSdkVersion] the mini sdk version, only needed if the type is 2 (things)
     * @param {Array<string>} [protocols] the array of protocols needed, only needed if the type is 2 (things)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCloset(
      userId: string,
      itemType?: string,
      minSdkVersion?: string,
      protocols?: Array<string>,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ClosetItemResponse> {
      const localVarFetchArgs = ClosetApiFetchParamCreator(
        configuration,
      ).getCloset(userId, itemType, minSdkVersion, protocols, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Modifies a user's closet (uses shim domain, api.{env}.genies)
     * @summary A user's closet of assets
     * @param {ClosetUpdate} body Closet operation
     * @param {string} userId ID of the owning user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCloset(
      body: ClosetUpdate,
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = ClosetApiFetchParamCreator(
        configuration,
      ).updateCloset(body, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ClosetApi - factory interface
 * @export
 */
export const ClosetApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Returns a list of asset IDs (uses shim domain, api.{env}.genies)
     * @summary An avatar's closet of assets
     * @param {string} userId ID of the owning user
     * @param {string} [itemType] item type to fetch [wearable, things, NFT, NFT and Wearables]
     * @param {string} [minSdkVersion] the mini sdk version, only needed if the type is 2 (things)
     * @param {Array<string>} [protocols] the array of protocols needed, only needed if the type is 2 (things)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCloset(
      userId: string,
      itemType?: string,
      minSdkVersion?: string,
      protocols?: Array<string>,
      options?: any,
    ) {
      return ClosetApiFp(configuration).getCloset(
        userId,
        itemType,
        minSdkVersion,
        protocols,
        options,
      )(fetch, basePath);
    },
    /**
     * Modifies a user's closet (uses shim domain, api.{env}.genies)
     * @summary A user's closet of assets
     * @param {ClosetUpdate} body Closet operation
     * @param {string} userId ID of the owning user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCloset(body: ClosetUpdate, userId: string, options?: any) {
      return ClosetApiFp(configuration).updateCloset(
        body,
        userId,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * ClosetApi - object-oriented interface
 * @export
 * @class ClosetApi
 * @extends {BaseAPI}
 */
export class ClosetApi extends BaseAPI {
  /**
   * Returns a list of asset IDs (uses shim domain, api.{env}.genies)
   * @summary An avatar's closet of assets
   * @param {string} userId ID of the owning user
   * @param {string} [itemType] item type to fetch [wearable, things, NFT, NFT and Wearables]
   * @param {string} [minSdkVersion] the mini sdk version, only needed if the type is 2 (things)
   * @param {Array<string>} [protocols] the array of protocols needed, only needed if the type is 2 (things)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClosetApi
   */
  public getCloset(
    userId: string,
    itemType?: string,
    minSdkVersion?: string,
    protocols?: Array<string>,
    options?: any,
  ) {
    return ClosetApiFp(this.configuration).getCloset(
      userId,
      itemType,
      minSdkVersion,
      protocols,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Modifies a user's closet (uses shim domain, api.{env}.genies)
   * @summary A user's closet of assets
   * @param {ClosetUpdate} body Closet operation
   * @param {string} userId ID of the owning user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClosetApi
   */
  public updateCloset(body: ClosetUpdate, userId: string, options?: any) {
    return ClosetApiFp(this.configuration).updateCloset(
      body,
      userId,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * ComparisonApi - fetch parameter creator
 * @export
 */
export const ComparisonApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get list of existing comparison list of the current authorized user. (uses shim domain, api.{env}.genies)
     * @summary Get comparison list for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getComparisonList(options: any = {}): FetchArgs {
      const localVarPath = `/comparison`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Hide or unhide a user from the comparison list (uses shim domain, api.{env}.genies)
     * @summary Hide user from comparisons
     * @param {ToggleHideComparisonList} body Handle friend operation
     * @param {string} userId userId to friend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    toggleHideComparisonList(
      body: ToggleHideComparisonList,
      userId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling toggleHideComparisonList.',
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling toggleHideComparisonList.',
        );
      }
      const localVarPath = `/comparison/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'ToggleHideComparisonList' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ComparisonApi - functional programming interface
 * @export
 */
export const ComparisonApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Get list of existing comparison list of the current authorized user. (uses shim domain, api.{env}.genies)
     * @summary Get comparison list for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getComparisonList(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserComparisonList> {
      const localVarFetchArgs =
        ComparisonApiFetchParamCreator(configuration).getComparisonList(
          options,
        );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Hide or unhide a user from the comparison list (uses shim domain, api.{env}.genies)
     * @summary Hide user from comparisons
     * @param {ToggleHideComparisonList} body Handle friend operation
     * @param {string} userId userId to friend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    toggleHideComparisonList(
      body: ToggleHideComparisonList,
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
      const localVarFetchArgs = ComparisonApiFetchParamCreator(
        configuration,
      ).toggleHideComparisonList(body, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ComparisonApi - factory interface
 * @export
 */
export const ComparisonApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Get list of existing comparison list of the current authorized user. (uses shim domain, api.{env}.genies)
     * @summary Get comparison list for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getComparisonList(options?: any) {
      return ComparisonApiFp(configuration).getComparisonList(options)(
        fetch,
        basePath,
      );
    },
    /**
     * Hide or unhide a user from the comparison list (uses shim domain, api.{env}.genies)
     * @summary Hide user from comparisons
     * @param {ToggleHideComparisonList} body Handle friend operation
     * @param {string} userId userId to friend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    toggleHideComparisonList(
      body: ToggleHideComparisonList,
      userId: string,
      options?: any,
    ) {
      return ComparisonApiFp(configuration).toggleHideComparisonList(
        body,
        userId,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * ComparisonApi - object-oriented interface
 * @export
 * @class ComparisonApi
 * @extends {BaseAPI}
 */
export class ComparisonApi extends BaseAPI {
  /**
   * Get list of existing comparison list of the current authorized user. (uses shim domain, api.{env}.genies)
   * @summary Get comparison list for user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComparisonApi
   */
  public getComparisonList(options?: any) {
    return ComparisonApiFp(this.configuration).getComparisonList(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Hide or unhide a user from the comparison list (uses shim domain, api.{env}.genies)
   * @summary Hide user from comparisons
   * @param {ToggleHideComparisonList} body Handle friend operation
   * @param {string} userId userId to friend
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComparisonApi
   */
  public toggleHideComparisonList(
    body: ToggleHideComparisonList,
    userId: string,
    options?: any,
  ) {
    return ComparisonApiFp(this.configuration).toggleHideComparisonList(
      body,
      userId,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * FeedApi - fetch parameter creator
 * @export
 */
export const FeedApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Creates a new feed for the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Create a feed
     * @param {FeedCreate} body Feed creation object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFeed(body: FeedCreate, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createFeed.',
        );
      }
      const localVarPath = `/feed`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'FeedCreate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes a feed for the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Delete a feed
     * @param {string} feedId feedId of the feed to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFeed(feedId: string, options: any = {}): FetchArgs {
      // verify required parameter 'feedId' is not null or undefined
      if (feedId === null || feedId === undefined) {
        throw new RequiredError(
          'feedId',
          'Required parameter feedId was null or undefined when calling deleteFeed.',
        );
      }
      const localVarPath = `/feed/{feedId}`.replace(
        `{${'feedId'}}`,
        encodeURIComponent(String(feedId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a single feeds likes and the users who liked the feed. (uses shim domain, api.{env}.genies)
     * @summary Get likes a single feed
     * @param {string} feedId feedId of the feed to get data on
     * @param {number} limit Max number of items to get returned, max number of 25
     * @param {string} [nextCursor] The DynamoDB pagination token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFeedLikeData(
      feedId: string,
      limit: number,
      nextCursor?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'feedId' is not null or undefined
      if (feedId === null || feedId === undefined) {
        throw new RequiredError(
          'feedId',
          'Required parameter feedId was null or undefined when calling getFeedLikeData.',
        );
      }
      // verify required parameter 'limit' is not null or undefined
      if (limit === null || limit === undefined) {
        throw new RequiredError(
          'limit',
          'Required parameter limit was null or undefined when calling getFeedLikeData.',
        );
      }
      const localVarPath = `/feed/{feedId}/like`.replace(
        `{${'feedId'}}`,
        encodeURIComponent(String(feedId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (nextCursor !== undefined) {
        localVarQueryParameter['nextCursor'] = nextCursor;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new feed for the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Get a list of feeds
     * @param {string} type Type of the feed list to get. \&quot;recent\&quot; will get the recent feeds from all users who made a post. \&quot;following\&quot; will get a list of feeds posted only by the users the requestor follow. \&quot;trending\&quot; will get a list of feeds trending based on a ranking system.
     * @param {number} limit Max number of items to get returned, max number of 25
     * @param {string} [nextCursor] Key to get the next page of the feeds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFeeds(
      type: string,
      limit: number,
      nextCursor?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError(
          'type',
          'Required parameter type was null or undefined when calling getFeeds.',
        );
      }
      // verify required parameter 'limit' is not null or undefined
      if (limit === null || limit === undefined) {
        throw new RequiredError(
          'limit',
          'Required parameter limit was null or undefined when calling getFeeds.',
        );
      }
      const localVarPath = `/feed`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (nextCursor !== undefined) {
        localVarQueryParameter['nextCursor'] = nextCursor;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets a list of the feeds that the user has posted using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Get all feeds a user has posted
     * @param {string} userId userId of the user to get their feeds
     * @param {number} limit Max number of items to get returned, max number of 25
     * @param {string} [nextCursor] The DynamoDB pagination token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFeeds(
      userId: string,
      limit: number,
      nextCursor?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getUserFeeds.',
        );
      }
      // verify required parameter 'limit' is not null or undefined
      if (limit === null || limit === undefined) {
        throw new RequiredError(
          'limit',
          'Required parameter limit was null or undefined when calling getUserFeeds.',
        );
      }
      const localVarPath = `/feed/user/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (nextCursor !== undefined) {
        localVarQueryParameter['nextCursor'] = nextCursor;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Likes a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Like a feed
     * @param {string} feedId feedId of the feed to like
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    likeFeed(feedId: string, options: any = {}): FetchArgs {
      // verify required parameter 'feedId' is not null or undefined
      if (feedId === null || feedId === undefined) {
        throw new RequiredError(
          'feedId',
          'Required parameter feedId was null or undefined when calling likeFeed.',
        );
      }
      const localVarPath = `/feed/{feedId}/like`.replace(
        `{${'feedId'}}`,
        encodeURIComponent(String(feedId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Saves a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Save a feed
     * @param {string} feedId feedId of the feed to like
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveFeed(feedId: string, options: any = {}): FetchArgs {
      // verify required parameter 'feedId' is not null or undefined
      if (feedId === null || feedId === undefined) {
        throw new RequiredError(
          'feedId',
          'Required parameter feedId was null or undefined when calling saveFeed.',
        );
      }
      const localVarPath = `/feed/{feedId}/save`.replace(
        `{${'feedId'}}`,
        encodeURIComponent(String(feedId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Tag a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Tag a feed
     * @param {string} feedId feedId of the feed to tag
     * @param {string} tagType tagType to use to tag the feed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagFeed(feedId: string, tagType: string, options: any = {}): FetchArgs {
      // verify required parameter 'feedId' is not null or undefined
      if (feedId === null || feedId === undefined) {
        throw new RequiredError(
          'feedId',
          'Required parameter feedId was null or undefined when calling tagFeed.',
        );
      }
      // verify required parameter 'tagType' is not null or undefined
      if (tagType === null || tagType === undefined) {
        throw new RequiredError(
          'tagType',
          'Required parameter tagType was null or undefined when calling tagFeed.',
        );
      }
      const localVarPath = `/feed/{feedId}/tag`.replace(
        `{${'feedId'}}`,
        encodeURIComponent(String(feedId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (tagType !== undefined) {
        localVarQueryParameter['tagType'] = tagType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Likes a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Unlike a feed
     * @param {string} feedId feedId of the feed to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlikeFeed(feedId: string, options: any = {}): FetchArgs {
      // verify required parameter 'feedId' is not null or undefined
      if (feedId === null || feedId === undefined) {
        throw new RequiredError(
          'feedId',
          'Required parameter feedId was null or undefined when calling unlikeFeed.',
        );
      }
      const localVarPath = `/feed/{feedId}/like`.replace(
        `{${'feedId'}}`,
        encodeURIComponent(String(feedId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Saves a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary unsave a feed
     * @param {string} feedId feedId of the feed to like
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsaveFeed(feedId: string, options: any = {}): FetchArgs {
      // verify required parameter 'feedId' is not null or undefined
      if (feedId === null || feedId === undefined) {
        throw new RequiredError(
          'feedId',
          'Required parameter feedId was null or undefined when calling unsaveFeed.',
        );
      }
      const localVarPath = `/feed/{feedId}/save`.replace(
        `{${'feedId'}}`,
        encodeURIComponent(String(feedId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Untag a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Untag a feed
     * @param {string} feedId feedId of the feed to untag
     * @param {string} tagType tagType to use to tag the feed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    untagFeed(feedId: string, tagType: string, options: any = {}): FetchArgs {
      // verify required parameter 'feedId' is not null or undefined
      if (feedId === null || feedId === undefined) {
        throw new RequiredError(
          'feedId',
          'Required parameter feedId was null or undefined when calling untagFeed.',
        );
      }
      // verify required parameter 'tagType' is not null or undefined
      if (tagType === null || tagType === undefined) {
        throw new RequiredError(
          'tagType',
          'Required parameter tagType was null or undefined when calling untagFeed.',
        );
      }
      const localVarPath = `/feed/{feedId}/tag`.replace(
        `{${'feedId'}}`,
        encodeURIComponent(String(feedId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (tagType !== undefined) {
        localVarQueryParameter['tagType'] = tagType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FeedApi - functional programming interface
 * @export
 */
export const FeedApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Creates a new feed for the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Create a feed
     * @param {FeedCreate} body Feed creation object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFeed(
      body: FeedCreate,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<FeedCreateResponse> {
      const localVarFetchArgs = FeedApiFetchParamCreator(
        configuration,
      ).createFeed(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Deletes a feed for the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Delete a feed
     * @param {string} feedId feedId of the feed to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFeed(
      feedId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
      const localVarFetchArgs = FeedApiFetchParamCreator(
        configuration,
      ).deleteFeed(feedId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get a single feeds likes and the users who liked the feed. (uses shim domain, api.{env}.genies)
     * @summary Get likes a single feed
     * @param {string} feedId feedId of the feed to get data on
     * @param {number} limit Max number of items to get returned, max number of 25
     * @param {string} [nextCursor] The DynamoDB pagination token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFeedLikeData(
      feedId: string,
      limit: number,
      nextCursor?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<FeedLikeDataResponse> {
      const localVarFetchArgs = FeedApiFetchParamCreator(
        configuration,
      ).getFeedLikeData(feedId, limit, nextCursor, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Creates a new feed for the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Get a list of feeds
     * @param {string} type Type of the feed list to get. \&quot;recent\&quot; will get the recent feeds from all users who made a post. \&quot;following\&quot; will get a list of feeds posted only by the users the requestor follow. \&quot;trending\&quot; will get a list of feeds trending based on a ranking system.
     * @param {number} limit Max number of items to get returned, max number of 25
     * @param {string} [nextCursor] Key to get the next page of the feeds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFeeds(
      type: string,
      limit: number,
      nextCursor?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<FeedListResponse> {
      const localVarFetchArgs = FeedApiFetchParamCreator(
        configuration,
      ).getFeeds(type, limit, nextCursor, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Gets a list of the feeds that the user has posted using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Get all feeds a user has posted
     * @param {string} userId userId of the user to get their feeds
     * @param {number} limit Max number of items to get returned, max number of 25
     * @param {string} [nextCursor] The DynamoDB pagination token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFeeds(
      userId: string,
      limit: number,
      nextCursor?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<FeedListResponse> {
      const localVarFetchArgs = FeedApiFetchParamCreator(
        configuration,
      ).getUserFeeds(userId, limit, nextCursor, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Likes a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Like a feed
     * @param {string} feedId feedId of the feed to like
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    likeFeed(
      feedId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<FeedLikeResponse> {
      const localVarFetchArgs = FeedApiFetchParamCreator(
        configuration,
      ).likeFeed(feedId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Saves a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Save a feed
     * @param {string} feedId feedId of the feed to like
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveFeed(
      feedId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<FeedSaveResponse> {
      const localVarFetchArgs = FeedApiFetchParamCreator(
        configuration,
      ).saveFeed(feedId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Tag a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Tag a feed
     * @param {string} feedId feedId of the feed to tag
     * @param {string} tagType tagType to use to tag the feed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagFeed(
      feedId: string,
      tagType: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<FeedTagResponse> {
      const localVarFetchArgs = FeedApiFetchParamCreator(configuration).tagFeed(
        feedId,
        tagType,
        options,
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Likes a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Unlike a feed
     * @param {string} feedId feedId of the feed to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlikeFeed(
      feedId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
      const localVarFetchArgs = FeedApiFetchParamCreator(
        configuration,
      ).unlikeFeed(feedId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Saves a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary unsave a feed
     * @param {string} feedId feedId of the feed to like
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsaveFeed(
      feedId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
      const localVarFetchArgs = FeedApiFetchParamCreator(
        configuration,
      ).unsaveFeed(feedId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Untag a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Untag a feed
     * @param {string} feedId feedId of the feed to untag
     * @param {string} tagType tagType to use to tag the feed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    untagFeed(
      feedId: string,
      tagType: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
      const localVarFetchArgs = FeedApiFetchParamCreator(
        configuration,
      ).untagFeed(feedId, tagType, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * FeedApi - factory interface
 * @export
 */
export const FeedApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Creates a new feed for the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Create a feed
     * @param {FeedCreate} body Feed creation object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFeed(body: FeedCreate, options?: any) {
      return FeedApiFp(configuration).createFeed(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Deletes a feed for the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Delete a feed
     * @param {string} feedId feedId of the feed to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFeed(feedId: string, options?: any) {
      return FeedApiFp(configuration).deleteFeed(feedId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Get a single feeds likes and the users who liked the feed. (uses shim domain, api.{env}.genies)
     * @summary Get likes a single feed
     * @param {string} feedId feedId of the feed to get data on
     * @param {number} limit Max number of items to get returned, max number of 25
     * @param {string} [nextCursor] The DynamoDB pagination token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFeedLikeData(
      feedId: string,
      limit: number,
      nextCursor?: string,
      options?: any,
    ) {
      return FeedApiFp(configuration).getFeedLikeData(
        feedId,
        limit,
        nextCursor,
        options,
      )(fetch, basePath);
    },
    /**
     * Creates a new feed for the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Get a list of feeds
     * @param {string} type Type of the feed list to get. \&quot;recent\&quot; will get the recent feeds from all users who made a post. \&quot;following\&quot; will get a list of feeds posted only by the users the requestor follow. \&quot;trending\&quot; will get a list of feeds trending based on a ranking system.
     * @param {number} limit Max number of items to get returned, max number of 25
     * @param {string} [nextCursor] Key to get the next page of the feeds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFeeds(type: string, limit: number, nextCursor?: string, options?: any) {
      return FeedApiFp(configuration).getFeeds(
        type,
        limit,
        nextCursor,
        options,
      )(fetch, basePath);
    },
    /**
     * Gets a list of the feeds that the user has posted using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Get all feeds a user has posted
     * @param {string} userId userId of the user to get their feeds
     * @param {number} limit Max number of items to get returned, max number of 25
     * @param {string} [nextCursor] The DynamoDB pagination token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFeeds(
      userId: string,
      limit: number,
      nextCursor?: string,
      options?: any,
    ) {
      return FeedApiFp(configuration).getUserFeeds(
        userId,
        limit,
        nextCursor,
        options,
      )(fetch, basePath);
    },
    /**
     * Likes a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Like a feed
     * @param {string} feedId feedId of the feed to like
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    likeFeed(feedId: string, options?: any) {
      return FeedApiFp(configuration).likeFeed(feedId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Saves a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Save a feed
     * @param {string} feedId feedId of the feed to like
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveFeed(feedId: string, options?: any) {
      return FeedApiFp(configuration).saveFeed(feedId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Tag a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Tag a feed
     * @param {string} feedId feedId of the feed to tag
     * @param {string} tagType tagType to use to tag the feed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagFeed(feedId: string, tagType: string, options?: any) {
      return FeedApiFp(configuration).tagFeed(
        feedId,
        tagType,
        options,
      )(fetch, basePath);
    },
    /**
     * Likes a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Unlike a feed
     * @param {string} feedId feedId of the feed to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlikeFeed(feedId: string, options?: any) {
      return FeedApiFp(configuration).unlikeFeed(feedId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Saves a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary unsave a feed
     * @param {string} feedId feedId of the feed to like
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsaveFeed(feedId: string, options?: any) {
      return FeedApiFp(configuration).unsaveFeed(feedId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Untag a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Untag a feed
     * @param {string} feedId feedId of the feed to untag
     * @param {string} tagType tagType to use to tag the feed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    untagFeed(feedId: string, tagType: string, options?: any) {
      return FeedApiFp(configuration).untagFeed(
        feedId,
        tagType,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * FeedApi - object-oriented interface
 * @export
 * @class FeedApi
 * @extends {BaseAPI}
 */
export class FeedApi extends BaseAPI {
  /**
   * Creates a new feed for the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
   * @summary Create a feed
   * @param {FeedCreate} body Feed creation object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedApi
   */
  public createFeed(body: FeedCreate, options?: any) {
    return FeedApiFp(this.configuration).createFeed(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Deletes a feed for the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
   * @summary Delete a feed
   * @param {string} feedId feedId of the feed to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedApi
   */
  public deleteFeed(feedId: string, options?: any) {
    return FeedApiFp(this.configuration).deleteFeed(feedId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Get a single feeds likes and the users who liked the feed. (uses shim domain, api.{env}.genies)
   * @summary Get likes a single feed
   * @param {string} feedId feedId of the feed to get data on
   * @param {number} limit Max number of items to get returned, max number of 25
   * @param {string} [nextCursor] The DynamoDB pagination token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedApi
   */
  public getFeedLikeData(
    feedId: string,
    limit: number,
    nextCursor?: string,
    options?: any,
  ) {
    return FeedApiFp(this.configuration).getFeedLikeData(
      feedId,
      limit,
      nextCursor,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Creates a new feed for the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
   * @summary Get a list of feeds
   * @param {string} type Type of the feed list to get. \&quot;recent\&quot; will get the recent feeds from all users who made a post. \&quot;following\&quot; will get a list of feeds posted only by the users the requestor follow. \&quot;trending\&quot; will get a list of feeds trending based on a ranking system.
   * @param {number} limit Max number of items to get returned, max number of 25
   * @param {string} [nextCursor] Key to get the next page of the feeds
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedApi
   */
  public getFeeds(
    type: string,
    limit: number,
    nextCursor?: string,
    options?: any,
  ) {
    return FeedApiFp(this.configuration).getFeeds(
      type,
      limit,
      nextCursor,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Gets a list of the feeds that the user has posted using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
   * @summary Get all feeds a user has posted
   * @param {string} userId userId of the user to get their feeds
   * @param {number} limit Max number of items to get returned, max number of 25
   * @param {string} [nextCursor] The DynamoDB pagination token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedApi
   */
  public getUserFeeds(
    userId: string,
    limit: number,
    nextCursor?: string,
    options?: any,
  ) {
    return FeedApiFp(this.configuration).getUserFeeds(
      userId,
      limit,
      nextCursor,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Likes a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
   * @summary Like a feed
   * @param {string} feedId feedId of the feed to like
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedApi
   */
  public likeFeed(feedId: string, options?: any) {
    return FeedApiFp(this.configuration).likeFeed(feedId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Saves a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
   * @summary Save a feed
   * @param {string} feedId feedId of the feed to like
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedApi
   */
  public saveFeed(feedId: string, options?: any) {
    return FeedApiFp(this.configuration).saveFeed(feedId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Tag a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
   * @summary Tag a feed
   * @param {string} feedId feedId of the feed to tag
   * @param {string} tagType tagType to use to tag the feed
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedApi
   */
  public tagFeed(feedId: string, tagType: string, options?: any) {
    return FeedApiFp(this.configuration).tagFeed(
      feedId,
      tagType,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Likes a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
   * @summary Unlike a feed
   * @param {string} feedId feedId of the feed to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedApi
   */
  public unlikeFeed(feedId: string, options?: any) {
    return FeedApiFp(this.configuration).unlikeFeed(feedId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Saves a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
   * @summary unsave a feed
   * @param {string} feedId feedId of the feed to like
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedApi
   */
  public unsaveFeed(feedId: string, options?: any) {
    return FeedApiFp(this.configuration).unsaveFeed(feedId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Untag a feed by the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
   * @summary Untag a feed
   * @param {string} feedId feedId of the feed to untag
   * @param {string} tagType tagType to use to tag the feed
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedApi
   */
  public untagFeed(feedId: string, tagType: string, options?: any) {
    return FeedApiFp(this.configuration).untagFeed(
      feedId,
      tagType,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * FollowApi - fetch parameter creator
 * @export
 */
export const FollowApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Gets user/followee status or all users followers. If followeeId is ommited from the params, the endpoint will return all the users followers. Returns an array of size \"1\", if the followee follows the given subID or \"0\" if they do not. For all followers, returns an array of size N, where N represents all of the users followers. (uses shim domain, api.{env}.genies)
     * @summary Get users followers
     * @param {string} userId userId to get followers, should be same as requestors userId
     * @param {string} [followeeId] followeeId to check if following
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFollowers(
      userId: string,
      followeeId?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getFollowers.',
        );
      }
      const localVarPath = `/follow`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId;
      }

      if (followeeId !== undefined) {
        localVarQueryParameter['followeeId'] = followeeId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get list of recommended users to follow. (uses shim domain, api.{env}.genies)
     * @summary Get list of recommended users to follow
     * @param {string} [type] Type of users to get either randomly or recommended, if not passed, random will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecommendedFollows(type?: string, options: any = {}): FetchArgs {
      const localVarPath = `/follow/recommend`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FollowApi - functional programming interface
 * @export
 */
export const FollowApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Gets user/followee status or all users followers. If followeeId is ommited from the params, the endpoint will return all the users followers. Returns an array of size \"1\", if the followee follows the given subID or \"0\" if they do not. For all followers, returns an array of size N, where N represents all of the users followers. (uses shim domain, api.{env}.genies)
     * @summary Get users followers
     * @param {string} userId userId to get followers, should be same as requestors userId
     * @param {string} [followeeId] followeeId to check if following
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFollowers(
      userId: string,
      followeeId?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<FollowGetResponse> {
      const localVarFetchArgs = FollowApiFetchParamCreator(
        configuration,
      ).getFollowers(userId, followeeId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get list of recommended users to follow. (uses shim domain, api.{env}.genies)
     * @summary Get list of recommended users to follow
     * @param {string} [type] Type of users to get either randomly or recommended, if not passed, random will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecommendedFollows(
      type?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<FollowGetResponse> {
      const localVarFetchArgs = FollowApiFetchParamCreator(
        configuration,
      ).getRecommendedFollows(type, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * FollowApi - factory interface
 * @export
 */
export const FollowApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Gets user/followee status or all users followers. If followeeId is ommited from the params, the endpoint will return all the users followers. Returns an array of size \"1\", if the followee follows the given subID or \"0\" if they do not. For all followers, returns an array of size N, where N represents all of the users followers. (uses shim domain, api.{env}.genies)
     * @summary Get users followers
     * @param {string} userId userId to get followers, should be same as requestors userId
     * @param {string} [followeeId] followeeId to check if following
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFollowers(userId: string, followeeId?: string, options?: any) {
      return FollowApiFp(configuration).getFollowers(
        userId,
        followeeId,
        options,
      )(fetch, basePath);
    },
    /**
     * Get list of recommended users to follow. (uses shim domain, api.{env}.genies)
     * @summary Get list of recommended users to follow
     * @param {string} [type] Type of users to get either randomly or recommended, if not passed, random will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecommendedFollows(type?: string, options?: any) {
      return FollowApiFp(configuration).getRecommendedFollows(type, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * FollowApi - object-oriented interface
 * @export
 * @class FollowApi
 * @extends {BaseAPI}
 */
export class FollowApi extends BaseAPI {
  /**
   * Gets user/followee status or all users followers. If followeeId is ommited from the params, the endpoint will return all the users followers. Returns an array of size \"1\", if the followee follows the given subID or \"0\" if they do not. For all followers, returns an array of size N, where N represents all of the users followers. (uses shim domain, api.{env}.genies)
   * @summary Get users followers
   * @param {string} userId userId to get followers, should be same as requestors userId
   * @param {string} [followeeId] followeeId to check if following
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FollowApi
   */
  public getFollowers(userId: string, followeeId?: string, options?: any) {
    return FollowApiFp(this.configuration).getFollowers(
      userId,
      followeeId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Get list of recommended users to follow. (uses shim domain, api.{env}.genies)
   * @summary Get list of recommended users to follow
   * @param {string} [type] Type of users to get either randomly or recommended, if not passed, random will be used
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FollowApi
   */
  public getRecommendedFollows(type?: string, options?: any) {
    return FollowApiFp(this.configuration).getRecommendedFollows(type, options)(
      this.fetch,
      this.basePath,
    );
  }
}
/**
 * FriendApi - fetch parameter creator
 * @export
 */
export const FriendApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Send Friend request to user by id, requires the other user to accept to become friends (uses shim domain, api.{env}.genies)
     * @summary Send friend request to another user
     * @param {string} userId userId to friend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    friendUser(userId: string, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling friendUser.',
        );
      }
      const localVarPath = `/friend/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get list of friends of different types. Pagination will only be for the associated type, can only paginate through one type at a time. [Existing: existing users on the platform (in your contacts)] [Incoming: other users requesting to be friends with current authorized user] [Sent: sent friend requests] [Pending: pending friend requests from invite API] [FOF: friend of friend] [Friended: users that are already friends with the current authorized user]
     * @summary Get friends
     * @param {string} type userId to friend
     * @param {string} [nextCursor] The DynamoDB pagination token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFriends(
      type: string,
      nextCursor?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError(
          'type',
          'Required parameter type was null or undefined when calling getFriends.',
        );
      }
      const localVarPath = `/friend`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (nextCursor !== undefined) {
        localVarQueryParameter['nextCursor'] = nextCursor;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Accept or remove requests from another user that sent the friend request (uses shim domain, api.{env}.genies)
     * @summary Handle incoming friend request
     * @param {HandleFriendRequest} body Handle friend operation
     * @param {string} userId userId to friend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleFriend(
      body: HandleFriendRequest,
      userId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling handleFriend.',
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling handleFriend.',
        );
      }
      const localVarPath = `/friend/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'HandleFriendRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Unfriend a user from the requestor, must be an existing friend of the requestor (uses shim domain, api.{env}.genies)
     * @summary Unfriend a user
     * @param {string} userId userId to unfriend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unFriendUser(userId: string, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling unFriendUser.',
        );
      }
      const localVarPath = `/friend/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FriendApi - functional programming interface
 * @export
 */
export const FriendApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Send Friend request to user by id, requires the other user to accept to become friends (uses shim domain, api.{env}.genies)
     * @summary Send friend request to another user
     * @param {string} userId userId to friend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    friendUser(
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
      const localVarFetchArgs = FriendApiFetchParamCreator(
        configuration,
      ).friendUser(userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get list of friends of different types. Pagination will only be for the associated type, can only paginate through one type at a time. [Existing: existing users on the platform (in your contacts)] [Incoming: other users requesting to be friends with current authorized user] [Sent: sent friend requests] [Pending: pending friend requests from invite API] [FOF: friend of friend] [Friended: users that are already friends with the current authorized user]
     * @summary Get friends
     * @param {string} type userId to friend
     * @param {string} [nextCursor] The DynamoDB pagination token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFriends(
      type: string,
      nextCursor?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<FriendsGetResponse> {
      const localVarFetchArgs = FriendApiFetchParamCreator(
        configuration,
      ).getFriends(type, nextCursor, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Accept or remove requests from another user that sent the friend request (uses shim domain, api.{env}.genies)
     * @summary Handle incoming friend request
     * @param {HandleFriendRequest} body Handle friend operation
     * @param {string} userId userId to friend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleFriend(
      body: HandleFriendRequest,
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<FriendsHandleResponse> {
      const localVarFetchArgs = FriendApiFetchParamCreator(
        configuration,
      ).handleFriend(body, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Unfriend a user from the requestor, must be an existing friend of the requestor (uses shim domain, api.{env}.genies)
     * @summary Unfriend a user
     * @param {string} userId userId to unfriend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unFriendUser(
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
      const localVarFetchArgs = FriendApiFetchParamCreator(
        configuration,
      ).unFriendUser(userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * FriendApi - factory interface
 * @export
 */
export const FriendApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Send Friend request to user by id, requires the other user to accept to become friends (uses shim domain, api.{env}.genies)
     * @summary Send friend request to another user
     * @param {string} userId userId to friend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    friendUser(userId: string, options?: any) {
      return FriendApiFp(configuration).friendUser(userId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Get list of friends of different types. Pagination will only be for the associated type, can only paginate through one type at a time. [Existing: existing users on the platform (in your contacts)] [Incoming: other users requesting to be friends with current authorized user] [Sent: sent friend requests] [Pending: pending friend requests from invite API] [FOF: friend of friend] [Friended: users that are already friends with the current authorized user]
     * @summary Get friends
     * @param {string} type userId to friend
     * @param {string} [nextCursor] The DynamoDB pagination token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFriends(type: string, nextCursor?: string, options?: any) {
      return FriendApiFp(configuration).getFriends(
        type,
        nextCursor,
        options,
      )(fetch, basePath);
    },
    /**
     * Accept or remove requests from another user that sent the friend request (uses shim domain, api.{env}.genies)
     * @summary Handle incoming friend request
     * @param {HandleFriendRequest} body Handle friend operation
     * @param {string} userId userId to friend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleFriend(body: HandleFriendRequest, userId: string, options?: any) {
      return FriendApiFp(configuration).handleFriend(
        body,
        userId,
        options,
      )(fetch, basePath);
    },
    /**
     * Unfriend a user from the requestor, must be an existing friend of the requestor (uses shim domain, api.{env}.genies)
     * @summary Unfriend a user
     * @param {string} userId userId to unfriend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unFriendUser(userId: string, options?: any) {
      return FriendApiFp(configuration).unFriendUser(userId, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * FriendApi - object-oriented interface
 * @export
 * @class FriendApi
 * @extends {BaseAPI}
 */
export class FriendApi extends BaseAPI {
  /**
   * Send Friend request to user by id, requires the other user to accept to become friends (uses shim domain, api.{env}.genies)
   * @summary Send friend request to another user
   * @param {string} userId userId to friend
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FriendApi
   */
  public friendUser(userId: string, options?: any) {
    return FriendApiFp(this.configuration).friendUser(userId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Get list of friends of different types. Pagination will only be for the associated type, can only paginate through one type at a time. [Existing: existing users on the platform (in your contacts)] [Incoming: other users requesting to be friends with current authorized user] [Sent: sent friend requests] [Pending: pending friend requests from invite API] [FOF: friend of friend] [Friended: users that are already friends with the current authorized user]
   * @summary Get friends
   * @param {string} type userId to friend
   * @param {string} [nextCursor] The DynamoDB pagination token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FriendApi
   */
  public getFriends(type: string, nextCursor?: string, options?: any) {
    return FriendApiFp(this.configuration).getFriends(
      type,
      nextCursor,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Accept or remove requests from another user that sent the friend request (uses shim domain, api.{env}.genies)
   * @summary Handle incoming friend request
   * @param {HandleFriendRequest} body Handle friend operation
   * @param {string} userId userId to friend
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FriendApi
   */
  public handleFriend(
    body: HandleFriendRequest,
    userId: string,
    options?: any,
  ) {
    return FriendApiFp(this.configuration).handleFriend(
      body,
      userId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Unfriend a user from the requestor, must be an existing friend of the requestor (uses shim domain, api.{env}.genies)
   * @summary Unfriend a user
   * @param {string} userId userId to unfriend
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FriendApi
   */
  public unFriendUser(userId: string, options?: any) {
    return FriendApiFp(this.configuration).unFriendUser(userId, options)(
      this.fetch,
      this.basePath,
    );
  }
}
/**
 * GameFeatureApi - fetch parameter creator
 * @export
 */
export const GameFeatureApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Create the game features from request, return the time  of creation if success
     * @summary Batch create game features with a POST api.
     * @param {GameFeatureCreate} body Gamefeature Create object
     * @param {string} userId userId represents the user who calls the API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGameFeature(
      body: GameFeatureCreate,
      userId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createGameFeature.',
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling createGameFeature.',
        );
      }
      const localVarPath = `/gameFeature`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'GameFeatureCreate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete the game features by their ids, return the time  of deletion if success
     * @summary Batch delete game features.
     * @param {string} userId userId represents the user who calls the API
     * @param {string} gameFeatureIds ID of game features to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGameFeature(
      userId: string,
      gameFeatureIds: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling deleteGameFeature.',
        );
      }
      // verify required parameter 'gameFeatureIds' is not null or undefined
      if (gameFeatureIds === null || gameFeatureIds === undefined) {
        throw new RequiredError(
          'gameFeatureIds',
          'Required parameter gameFeatureIds was null or undefined when calling deleteGameFeature.',
        );
      }
      const localVarPath = `/gameFeature`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId;
      }

      if (gameFeatureIds !== undefined) {
        localVarQueryParameter['gameFeatureIds'] = gameFeatureIds;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the queried game features
     * @summary Batch query game features with GET api.
     * @param {string} userId userId represents the user who calls the API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGameFeature(userId: string, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getGameFeature.',
        );
      }
      const localVarPath = `/gameFeature`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update one game feature on behalf of the owner
     * @summary Update one game feature.
     * @param {GameFeatureUpdate} body the GameFeature object to update
     * @param {string} userId userId represents the user who calls the API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGameFeature(
      body: GameFeatureUpdate,
      userId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateGameFeature.',
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling updateGameFeature.',
        );
      }
      const localVarPath = `/gameFeature`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'GameFeatureUpdate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GameFeatureApi - functional programming interface
 * @export
 */
export const GameFeatureApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Create the game features from request, return the time  of creation if success
     * @summary Batch create game features with a POST api.
     * @param {GameFeatureCreate} body Gamefeature Create object
     * @param {string} userId userId represents the user who calls the API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGameFeature(
      body: GameFeatureCreate,
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
      const localVarFetchArgs = GameFeatureApiFetchParamCreator(
        configuration,
      ).createGameFeature(body, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete the game features by their ids, return the time  of deletion if success
     * @summary Batch delete game features.
     * @param {string} userId userId represents the user who calls the API
     * @param {string} gameFeatureIds ID of game features to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGameFeature(
      userId: string,
      gameFeatureIds: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
      const localVarFetchArgs = GameFeatureApiFetchParamCreator(
        configuration,
      ).deleteGameFeature(userId, gameFeatureIds, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns the queried game features
     * @summary Batch query game features with GET api.
     * @param {string} userId userId represents the user who calls the API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGameFeature(
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GameFeature>> {
      const localVarFetchArgs = GameFeatureApiFetchParamCreator(
        configuration,
      ).getGameFeature(userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update one game feature on behalf of the owner
     * @summary Update one game feature.
     * @param {GameFeatureUpdate} body the GameFeature object to update
     * @param {string} userId userId represents the user who calls the API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGameFeature(
      body: GameFeatureUpdate,
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GameFeature> {
      const localVarFetchArgs = GameFeatureApiFetchParamCreator(
        configuration,
      ).updateGameFeature(body, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * GameFeatureApi - factory interface
 * @export
 */
export const GameFeatureApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Create the game features from request, return the time  of creation if success
     * @summary Batch create game features with a POST api.
     * @param {GameFeatureCreate} body Gamefeature Create object
     * @param {string} userId userId represents the user who calls the API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGameFeature(body: GameFeatureCreate, userId: string, options?: any) {
      return GameFeatureApiFp(configuration).createGameFeature(
        body,
        userId,
        options,
      )(fetch, basePath);
    },
    /**
     * Delete the game features by their ids, return the time  of deletion if success
     * @summary Batch delete game features.
     * @param {string} userId userId represents the user who calls the API
     * @param {string} gameFeatureIds ID of game features to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGameFeature(userId: string, gameFeatureIds: string, options?: any) {
      return GameFeatureApiFp(configuration).deleteGameFeature(
        userId,
        gameFeatureIds,
        options,
      )(fetch, basePath);
    },
    /**
     * Returns the queried game features
     * @summary Batch query game features with GET api.
     * @param {string} userId userId represents the user who calls the API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGameFeature(userId: string, options?: any) {
      return GameFeatureApiFp(configuration).getGameFeature(userId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Update one game feature on behalf of the owner
     * @summary Update one game feature.
     * @param {GameFeatureUpdate} body the GameFeature object to update
     * @param {string} userId userId represents the user who calls the API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGameFeature(body: GameFeatureUpdate, userId: string, options?: any) {
      return GameFeatureApiFp(configuration).updateGameFeature(
        body,
        userId,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * GameFeatureApi - object-oriented interface
 * @export
 * @class GameFeatureApi
 * @extends {BaseAPI}
 */
export class GameFeatureApi extends BaseAPI {
  /**
   * Create the game features from request, return the time  of creation if success
   * @summary Batch create game features with a POST api.
   * @param {GameFeatureCreate} body Gamefeature Create object
   * @param {string} userId userId represents the user who calls the API
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameFeatureApi
   */
  public createGameFeature(
    body: GameFeatureCreate,
    userId: string,
    options?: any,
  ) {
    return GameFeatureApiFp(this.configuration).createGameFeature(
      body,
      userId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Delete the game features by their ids, return the time  of deletion if success
   * @summary Batch delete game features.
   * @param {string} userId userId represents the user who calls the API
   * @param {string} gameFeatureIds ID of game features to be deleted
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameFeatureApi
   */
  public deleteGameFeature(
    userId: string,
    gameFeatureIds: string,
    options?: any,
  ) {
    return GameFeatureApiFp(this.configuration).deleteGameFeature(
      userId,
      gameFeatureIds,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Returns the queried game features
   * @summary Batch query game features with GET api.
   * @param {string} userId userId represents the user who calls the API
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameFeatureApi
   */
  public getGameFeature(userId: string, options?: any) {
    return GameFeatureApiFp(this.configuration).getGameFeature(userId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Update one game feature on behalf of the owner
   * @summary Update one game feature.
   * @param {GameFeatureUpdate} body the GameFeature object to update
   * @param {string} userId userId represents the user who calls the API
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameFeatureApi
   */
  public updateGameFeature(
    body: GameFeatureUpdate,
    userId: string,
    options?: any,
  ) {
    return GameFeatureApiFp(this.configuration).updateGameFeature(
      body,
      userId,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * GroupApi - fetch parameter creator
 * @export
 */
export const GroupApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Retrieves group members based on parameters. (limit & nextCursor for pagination, just groupId for group metadata, just userId for a single space)
     * @summary Get group members
     * @param {number} [limit] Maximum number of groups to retrieve (default 25).
     * @param {string} [nextCursor] Cursor for pagination (from DynamoDB).
     * @param {string} [groupId] ID of the group to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupMembers(
      limit?: number,
      nextCursor?: string,
      groupId?: string,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/group/member`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (nextCursor !== undefined) {
        localVarQueryParameter['nextCursor'] = nextCursor;
      }

      if (groupId !== undefined) {
        localVarQueryParameter['groupId'] = groupId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves groups based on parameters. (limit & nextCursor for pagination, just groupId for group metadata, just userId for a single space)
     * @summary Get groups
     * @param {number} [limit] Maximum number of groups to retrieve (default 25).
     * @param {string} [nextCursor] Cursor for pagination (from DynamoDB).
     * @param {string} [groupId] ID of the group to retrieve.
     * @param {string} [userId] ID of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroups(
      limit?: number,
      nextCursor?: string,
      groupId?: string,
      userId?: string,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/group`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (nextCursor !== undefined) {
        localVarQueryParameter['nextCursor'] = nextCursor;
      }

      if (groupId !== undefined) {
        localVarQueryParameter['groupId'] = groupId;
      }

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Joins a user to a group.
     * @summary Join a group
     * @param {string} groupId ID of the group to join.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinGroup(groupId: string, options: any = {}): FetchArgs {
      // verify required parameter 'groupId' is not null or undefined
      if (groupId === null || groupId === undefined) {
        throw new RequiredError(
          'groupId',
          'Required parameter groupId was null or undefined when calling joinGroup.',
        );
      }
      const localVarPath = `/group/{groupId}`.replace(
        `{${'groupId'}}`,
        encodeURIComponent(String(groupId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Removes a user from a group.
     * @summary Leave a group
     * @param {string} groupId ID of the group to leave.
     * @param {string} userId ID of the user to remove from the group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaveGroup(groupId: string, userId: string, options: any = {}): FetchArgs {
      // verify required parameter 'groupId' is not null or undefined
      if (groupId === null || groupId === undefined) {
        throw new RequiredError(
          'groupId',
          'Required parameter groupId was null or undefined when calling leaveGroup.',
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling leaveGroup.',
        );
      }
      const localVarPath = `/group/{groupId}/{userId}`
        .replace(`{${'groupId'}}`, encodeURIComponent(String(groupId)))
        .replace(`{${'userId'}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Retrieves group members based on parameters. (limit & nextCursor for pagination, just groupId for group metadata, just userId for a single space)
     * @summary Get group members
     * @param {number} [limit] Maximum number of groups to retrieve (default 25).
     * @param {string} [nextCursor] Cursor for pagination (from DynamoDB).
     * @param {string} [groupId] ID of the group to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupMembers(
      limit?: number,
      nextCursor?: string,
      groupId?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GroupMembersResponse> {
      const localVarFetchArgs = GroupApiFetchParamCreator(
        configuration,
      ).getGroupMembers(limit, nextCursor, groupId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieves groups based on parameters. (limit & nextCursor for pagination, just groupId for group metadata, just userId for a single space)
     * @summary Get groups
     * @param {number} [limit] Maximum number of groups to retrieve (default 25).
     * @param {string} [nextCursor] Cursor for pagination (from DynamoDB).
     * @param {string} [groupId] ID of the group to retrieve.
     * @param {string} [userId] ID of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroups(
      limit?: number,
      nextCursor?: string,
      groupId?: string,
      userId?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GroupsResponse> {
      const localVarFetchArgs = GroupApiFetchParamCreator(
        configuration,
      ).getGroups(limit, nextCursor, groupId, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Joins a user to a group.
     * @summary Join a group
     * @param {string} groupId ID of the group to join.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinGroup(
      groupId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = GroupApiFetchParamCreator(
        configuration,
      ).joinGroup(groupId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Removes a user from a group.
     * @summary Leave a group
     * @param {string} groupId ID of the group to leave.
     * @param {string} userId ID of the user to remove from the group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaveGroup(
      groupId: string,
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = GroupApiFetchParamCreator(
        configuration,
      ).leaveGroup(groupId, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Retrieves group members based on parameters. (limit & nextCursor for pagination, just groupId for group metadata, just userId for a single space)
     * @summary Get group members
     * @param {number} [limit] Maximum number of groups to retrieve (default 25).
     * @param {string} [nextCursor] Cursor for pagination (from DynamoDB).
     * @param {string} [groupId] ID of the group to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupMembers(
      limit?: number,
      nextCursor?: string,
      groupId?: string,
      options?: any,
    ) {
      return GroupApiFp(configuration).getGroupMembers(
        limit,
        nextCursor,
        groupId,
        options,
      )(fetch, basePath);
    },
    /**
     * Retrieves groups based on parameters. (limit & nextCursor for pagination, just groupId for group metadata, just userId for a single space)
     * @summary Get groups
     * @param {number} [limit] Maximum number of groups to retrieve (default 25).
     * @param {string} [nextCursor] Cursor for pagination (from DynamoDB).
     * @param {string} [groupId] ID of the group to retrieve.
     * @param {string} [userId] ID of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroups(
      limit?: number,
      nextCursor?: string,
      groupId?: string,
      userId?: string,
      options?: any,
    ) {
      return GroupApiFp(configuration).getGroups(
        limit,
        nextCursor,
        groupId,
        userId,
        options,
      )(fetch, basePath);
    },
    /**
     * Joins a user to a group.
     * @summary Join a group
     * @param {string} groupId ID of the group to join.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinGroup(groupId: string, options?: any) {
      return GroupApiFp(configuration).joinGroup(groupId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Removes a user from a group.
     * @summary Leave a group
     * @param {string} groupId ID of the group to leave.
     * @param {string} userId ID of the user to remove from the group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaveGroup(groupId: string, userId: string, options?: any) {
      return GroupApiFp(configuration).leaveGroup(
        groupId,
        userId,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI {
  /**
   * Retrieves group members based on parameters. (limit & nextCursor for pagination, just groupId for group metadata, just userId for a single space)
   * @summary Get group members
   * @param {number} [limit] Maximum number of groups to retrieve (default 25).
   * @param {string} [nextCursor] Cursor for pagination (from DynamoDB).
   * @param {string} [groupId] ID of the group to retrieve.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupApi
   */
  public getGroupMembers(
    limit?: number,
    nextCursor?: string,
    groupId?: string,
    options?: any,
  ) {
    return GroupApiFp(this.configuration).getGroupMembers(
      limit,
      nextCursor,
      groupId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Retrieves groups based on parameters. (limit & nextCursor for pagination, just groupId for group metadata, just userId for a single space)
   * @summary Get groups
   * @param {number} [limit] Maximum number of groups to retrieve (default 25).
   * @param {string} [nextCursor] Cursor for pagination (from DynamoDB).
   * @param {string} [groupId] ID of the group to retrieve.
   * @param {string} [userId] ID of the user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupApi
   */
  public getGroups(
    limit?: number,
    nextCursor?: string,
    groupId?: string,
    userId?: string,
    options?: any,
  ) {
    return GroupApiFp(this.configuration).getGroups(
      limit,
      nextCursor,
      groupId,
      userId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Joins a user to a group.
   * @summary Join a group
   * @param {string} groupId ID of the group to join.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupApi
   */
  public joinGroup(groupId: string, options?: any) {
    return GroupApiFp(this.configuration).joinGroup(groupId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Removes a user from a group.
   * @summary Leave a group
   * @param {string} groupId ID of the group to leave.
   * @param {string} userId ID of the user to remove from the group.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupApi
   */
  public leaveGroup(groupId: string, userId: string, options?: any) {
    return GroupApiFp(this.configuration).leaveGroup(
      groupId,
      userId,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * ImageApi - fetch parameter creator
 * @export
 */
export const ImageApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns the presignedUrl and distributionUrl (uses composer-api domain)
     * @summary Upload image from mobile client
     * @param {ImageUpload} body Image Upload Object
     * @param {string} userId The id of the user who uploads the image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imageUpload(
      body: ImageUpload,
      userId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling imageUpload.',
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling imageUpload.',
        );
      }
      const localVarPath = `/image/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'ImageUpload' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ImageApi - functional programming interface
 * @export
 */
export const ImageApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Returns the presignedUrl and distributionUrl (uses composer-api domain)
     * @summary Upload image from mobile client
     * @param {ImageUpload} body Image Upload Object
     * @param {string} userId The id of the user who uploads the image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imageUpload(
      body: ImageUpload,
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ImageResponse> {
      const localVarFetchArgs = ImageApiFetchParamCreator(
        configuration,
      ).imageUpload(body, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ImageApi - factory interface
 * @export
 */
export const ImageApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Returns the presignedUrl and distributionUrl (uses composer-api domain)
     * @summary Upload image from mobile client
     * @param {ImageUpload} body Image Upload Object
     * @param {string} userId The id of the user who uploads the image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imageUpload(body: ImageUpload, userId: string, options?: any) {
      return ImageApiFp(configuration).imageUpload(
        body,
        userId,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * ImageApi - object-oriented interface
 * @export
 * @class ImageApi
 * @extends {BaseAPI}
 */
export class ImageApi extends BaseAPI {
  /**
   * Returns the presignedUrl and distributionUrl (uses composer-api domain)
   * @summary Upload image from mobile client
   * @param {ImageUpload} body Image Upload Object
   * @param {string} userId The id of the user who uploads the image
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImageApi
   */
  public imageUpload(body: ImageUpload, userId: string, options?: any) {
    return ImageApiFp(this.configuration).imageUpload(
      body,
      userId,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * InviteApi - fetch parameter creator
 * @export
 */
export const InviteApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Generates link for user to join  (uses shim domain, api.{env}.genies)
     * @summary Invite user with link
     * @param {InviteUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInviteLink(body: InviteUserRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createInviteLink.',
        );
      }
      const localVarPath = `/invite`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'InviteUserRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of invitations that the current user has sent.  (uses shim domain, api.{env}.genies)
     * @summary Get a list of invites the current user has made
     * @param {string} userId id of the user to get data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvitesSent(userId: string, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getInvitesSent.',
        );
      }
      const localVarPath = `/invite/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Generates link for user to join (uses shim domain, api.{env}.genies)
     * @summary Invite user with link
     * @param {InviteUserUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInviteLink(
      body: InviteUserUpdateRequest,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateInviteLink.',
        );
      }
      const localVarPath = `/invite`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'InviteUserUpdateRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InviteApi - functional programming interface
 * @export
 */
export const InviteApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Generates link for user to join  (uses shim domain, api.{env}.genies)
     * @summary Invite user with link
     * @param {InviteUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInviteLink(
      body: InviteUserRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InviteUserResponse> {
      const localVarFetchArgs = InviteApiFetchParamCreator(
        configuration,
      ).createInviteLink(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get a list of invitations that the current user has sent.  (uses shim domain, api.{env}.genies)
     * @summary Get a list of invites the current user has made
     * @param {string} userId id of the user to get data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvitesSent(
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InvitesSentResponse> {
      const localVarFetchArgs = InviteApiFetchParamCreator(
        configuration,
      ).getInvitesSent(userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Generates link for user to join (uses shim domain, api.{env}.genies)
     * @summary Invite user with link
     * @param {InviteUserUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInviteLink(
      body: InviteUserUpdateRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InviteUserResponse> {
      const localVarFetchArgs = InviteApiFetchParamCreator(
        configuration,
      ).updateInviteLink(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * InviteApi - factory interface
 * @export
 */
export const InviteApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Generates link for user to join  (uses shim domain, api.{env}.genies)
     * @summary Invite user with link
     * @param {InviteUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInviteLink(body: InviteUserRequest, options?: any) {
      return InviteApiFp(configuration).createInviteLink(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Get a list of invitations that the current user has sent.  (uses shim domain, api.{env}.genies)
     * @summary Get a list of invites the current user has made
     * @param {string} userId id of the user to get data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvitesSent(userId: string, options?: any) {
      return InviteApiFp(configuration).getInvitesSent(userId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Generates link for user to join (uses shim domain, api.{env}.genies)
     * @summary Invite user with link
     * @param {InviteUserUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInviteLink(body: InviteUserUpdateRequest, options?: any) {
      return InviteApiFp(configuration).updateInviteLink(body, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * InviteApi - object-oriented interface
 * @export
 * @class InviteApi
 * @extends {BaseAPI}
 */
export class InviteApi extends BaseAPI {
  /**
   * Generates link for user to join  (uses shim domain, api.{env}.genies)
   * @summary Invite user with link
   * @param {InviteUserRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InviteApi
   */
  public createInviteLink(body: InviteUserRequest, options?: any) {
    return InviteApiFp(this.configuration).createInviteLink(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Get a list of invitations that the current user has sent.  (uses shim domain, api.{env}.genies)
   * @summary Get a list of invites the current user has made
   * @param {string} userId id of the user to get data from
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InviteApi
   */
  public getInvitesSent(userId: string, options?: any) {
    return InviteApiFp(this.configuration).getInvitesSent(userId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Generates link for user to join (uses shim domain, api.{env}.genies)
   * @summary Invite user with link
   * @param {InviteUserUpdateRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InviteApi
   */
  public updateInviteLink(body: InviteUserUpdateRequest, options?: any) {
    return InviteApiFp(this.configuration).updateInviteLink(body, options)(
      this.fetch,
      this.basePath,
    );
  }
}
/**
 * LeaderboardApi - fetch parameter creator
 * @export
 */
export const LeaderboardApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns list of users who are in the top 100 of the leaderboard for a specified tag type (uses shim domain, api.{env}.genies)
     * @summary Get list of users in a leaderboard
     * @param {string} tagType tagType to get the list for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLeaderboard(tagType: string, options: any = {}): FetchArgs {
      // verify required parameter 'tagType' is not null or undefined
      if (tagType === null || tagType === undefined) {
        throw new RequiredError(
          'tagType',
          'Required parameter tagType was null or undefined when calling getLeaderboard.',
        );
      }
      const localVarPath = `/leaderboard`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (tagType !== undefined) {
        localVarQueryParameter['tagType'] = tagType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LeaderboardApi - functional programming interface
 * @export
 */
export const LeaderboardApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Returns list of users who are in the top 100 of the leaderboard for a specified tag type (uses shim domain, api.{env}.genies)
     * @summary Get list of users in a leaderboard
     * @param {string} tagType tagType to get the list for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLeaderboard(
      tagType: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<LeaderboardResponse> {
      const localVarFetchArgs = LeaderboardApiFetchParamCreator(
        configuration,
      ).getLeaderboard(tagType, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * LeaderboardApi - factory interface
 * @export
 */
export const LeaderboardApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Returns list of users who are in the top 100 of the leaderboard for a specified tag type (uses shim domain, api.{env}.genies)
     * @summary Get list of users in a leaderboard
     * @param {string} tagType tagType to get the list for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLeaderboard(tagType: string, options?: any) {
      return LeaderboardApiFp(configuration).getLeaderboard(tagType, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * LeaderboardApi - object-oriented interface
 * @export
 * @class LeaderboardApi
 * @extends {BaseAPI}
 */
export class LeaderboardApi extends BaseAPI {
  /**
   * Returns list of users who are in the top 100 of the leaderboard for a specified tag type (uses shim domain, api.{env}.genies)
   * @summary Get list of users in a leaderboard
   * @param {string} tagType tagType to get the list for
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LeaderboardApi
   */
  public getLeaderboard(tagType: string, options?: any) {
    return LeaderboardApiFp(this.configuration).getLeaderboard(
      tagType,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * LookApi - fetch parameter creator
 * @export
 */
export const LookApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Creates a new look for the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Create a new look
     * @param {LookCreate} body Look object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLook(body: LookCreate, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createLook.',
        );
      }
      const localVarPath = `/look`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'LookCreate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes a single of look (uses shim domain, api.{env}.genies)
     * @summary Delete a single look
     * @param {string} lookId LookId to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLookById(lookId: string, options: any = {}): FetchArgs {
      // verify required parameter 'lookId' is not null or undefined
      if (lookId === null || lookId === undefined) {
        throw new RequiredError(
          'lookId',
          'Required parameter lookId was null or undefined when calling deleteLookById.',
        );
      }
      const localVarPath = `/look/{lookId}`.replace(
        `{${'lookId'}}`,
        encodeURIComponent(String(lookId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of looks (uses shim domain, api.{env}.genies)
     * @summary Get available looks from a user
     * @param {string} [userId] The owning userId
     * @param {string} [nextCursor] The DynamoDB pagination token
     * @param {string} [status] Filter by the status of the look if exists in the input, no status in the params will mean it will fetch both draft and published
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLooksBy(
      userId?: string,
      nextCursor?: string,
      status?: string,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/look`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId;
      }

      if (nextCursor !== undefined) {
        localVarQueryParameter['nextCursor'] = nextCursor;
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of looks, limited to 100 per request (uses shim domain, api.{env}.genies)
     * @summary Get list of looks by look id
     * @param {Array<string>} lookIds List of look ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLooksById(lookIds: Array<string>, options: any = {}): FetchArgs {
      // verify required parameter 'lookIds' is not null or undefined
      if (lookIds === null || lookIds === undefined) {
        throw new RequiredError(
          'lookIds',
          'Required parameter lookIds was null or undefined when calling getLooksById.',
        );
      }
      const localVarPath = `/look/{lookIds*}`.replace(
        `{${'lookIds*'}}`,
        encodeURIComponent(String(lookIds)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the updated look (uses shim domain, api.{env}.genies)
     * @summary Update a single look with one or more available properties
     * @param {LookUpdate} body Update a look object
     * @param {string} lookId The lookId to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLookById(
      body: LookUpdate,
      lookId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateLookById.',
        );
      }
      // verify required parameter 'lookId' is not null or undefined
      if (lookId === null || lookId === undefined) {
        throw new RequiredError(
          'lookId',
          'Required parameter lookId was null or undefined when calling updateLookById.',
        );
      }
      const localVarPath = `/look/{lookId}`.replace(
        `{${'lookId'}}`,
        encodeURIComponent(String(lookId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'LookUpdate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LookApi - functional programming interface
 * @export
 */
export const LookApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Creates a new look for the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Create a new look
     * @param {LookCreate} body Look object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLook(
      body: LookCreate,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Look> {
      const localVarFetchArgs = LookApiFetchParamCreator(
        configuration,
      ).createLook(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Deletes a single of look (uses shim domain, api.{env}.genies)
     * @summary Delete a single look
     * @param {string} lookId LookId to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLookById(
      lookId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
      const localVarFetchArgs = LookApiFetchParamCreator(
        configuration,
      ).deleteLookById(lookId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of looks (uses shim domain, api.{env}.genies)
     * @summary Get available looks from a user
     * @param {string} [userId] The owning userId
     * @param {string} [nextCursor] The DynamoDB pagination token
     * @param {string} [status] Filter by the status of the look if exists in the input, no status in the params will mean it will fetch both draft and published
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLooksBy(
      userId?: string,
      nextCursor?: string,
      status?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<LookListPagination> {
      const localVarFetchArgs = LookApiFetchParamCreator(
        configuration,
      ).getLooksBy(userId, nextCursor, status, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of looks, limited to 100 per request (uses shim domain, api.{env}.genies)
     * @summary Get list of looks by look id
     * @param {Array<string>} lookIds List of look ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLooksById(
      lookIds: Array<string>,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<LookList> {
      const localVarFetchArgs = LookApiFetchParamCreator(
        configuration,
      ).getLooksById(lookIds, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns the updated look (uses shim domain, api.{env}.genies)
     * @summary Update a single look with one or more available properties
     * @param {LookUpdate} body Update a look object
     * @param {string} lookId The lookId to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLookById(
      body: LookUpdate,
      lookId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Look> {
      const localVarFetchArgs = LookApiFetchParamCreator(
        configuration,
      ).updateLookById(body, lookId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * LookApi - factory interface
 * @export
 */
export const LookApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Creates a new look for the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
     * @summary Create a new look
     * @param {LookCreate} body Look object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLook(body: LookCreate, options?: any) {
      return LookApiFp(configuration).createLook(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Deletes a single of look (uses shim domain, api.{env}.genies)
     * @summary Delete a single look
     * @param {string} lookId LookId to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLookById(lookId: string, options?: any) {
      return LookApiFp(configuration).deleteLookById(lookId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Returns a list of looks (uses shim domain, api.{env}.genies)
     * @summary Get available looks from a user
     * @param {string} [userId] The owning userId
     * @param {string} [nextCursor] The DynamoDB pagination token
     * @param {string} [status] Filter by the status of the look if exists in the input, no status in the params will mean it will fetch both draft and published
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLooksBy(
      userId?: string,
      nextCursor?: string,
      status?: string,
      options?: any,
    ) {
      return LookApiFp(configuration).getLooksBy(
        userId,
        nextCursor,
        status,
        options,
      )(fetch, basePath);
    },
    /**
     * Returns a list of looks, limited to 100 per request (uses shim domain, api.{env}.genies)
     * @summary Get list of looks by look id
     * @param {Array<string>} lookIds List of look ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLooksById(lookIds: Array<string>, options?: any) {
      return LookApiFp(configuration).getLooksById(lookIds, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Returns the updated look (uses shim domain, api.{env}.genies)
     * @summary Update a single look with one or more available properties
     * @param {LookUpdate} body Update a look object
     * @param {string} lookId The lookId to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLookById(body: LookUpdate, lookId: string, options?: any) {
      return LookApiFp(configuration).updateLookById(
        body,
        lookId,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * LookApi - object-oriented interface
 * @export
 * @class LookApi
 * @extends {BaseAPI}
 */
export class LookApi extends BaseAPI {
  /**
   * Creates a new look for the user using the sub from the cognito accessToken (uses shim domain, api.{env}.genies)
   * @summary Create a new look
   * @param {LookCreate} body Look object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LookApi
   */
  public createLook(body: LookCreate, options?: any) {
    return LookApiFp(this.configuration).createLook(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Deletes a single of look (uses shim domain, api.{env}.genies)
   * @summary Delete a single look
   * @param {string} lookId LookId to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LookApi
   */
  public deleteLookById(lookId: string, options?: any) {
    return LookApiFp(this.configuration).deleteLookById(lookId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Returns a list of looks (uses shim domain, api.{env}.genies)
   * @summary Get available looks from a user
   * @param {string} [userId] The owning userId
   * @param {string} [nextCursor] The DynamoDB pagination token
   * @param {string} [status] Filter by the status of the look if exists in the input, no status in the params will mean it will fetch both draft and published
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LookApi
   */
  public getLooksBy(
    userId?: string,
    nextCursor?: string,
    status?: string,
    options?: any,
  ) {
    return LookApiFp(this.configuration).getLooksBy(
      userId,
      nextCursor,
      status,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a list of looks, limited to 100 per request (uses shim domain, api.{env}.genies)
   * @summary Get list of looks by look id
   * @param {Array<string>} lookIds List of look ids
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LookApi
   */
  public getLooksById(lookIds: Array<string>, options?: any) {
    return LookApiFp(this.configuration).getLooksById(lookIds, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Returns the updated look (uses shim domain, api.{env}.genies)
   * @summary Update a single look with one or more available properties
   * @param {LookUpdate} body Update a look object
   * @param {string} lookId The lookId to update
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LookApi
   */
  public updateLookById(body: LookUpdate, lookId: string, options?: any) {
    return LookApiFp(this.configuration).updateLookById(
      body,
      lookId,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * MobilecmsApi - fetch parameter creator
 * @export
 */
export const MobilecmsApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns the result of a sql query (uses composer-api domain)
     * @summary Query mobile cms postgres database with GET api.
     * @param {string} sqlQuery complete sql query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMobileCms(sqlQuery: string, options: any = {}): FetchArgs {
      // verify required parameter 'sqlQuery' is not null or undefined
      if (sqlQuery === null || sqlQuery === undefined) {
        throw new RequiredError(
          'sqlQuery',
          'Required parameter sqlQuery was null or undefined when calling getMobileCms.',
        );
      }
      const localVarPath = `/mobilecms`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (sqlQuery !== undefined) {
        localVarQueryParameter['sqlQuery'] = sqlQuery;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MobilecmsApi - functional programming interface
 * @export
 */
export const MobilecmsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Returns the result of a sql query (uses composer-api domain)
     * @summary Query mobile cms postgres database with GET api.
     * @param {string} sqlQuery complete sql query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMobileCms(
      sqlQuery: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
      const localVarFetchArgs = MobilecmsApiFetchParamCreator(
        configuration,
      ).getMobileCms(sqlQuery, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * MobilecmsApi - factory interface
 * @export
 */
export const MobilecmsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Returns the result of a sql query (uses composer-api domain)
     * @summary Query mobile cms postgres database with GET api.
     * @param {string} sqlQuery complete sql query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMobileCms(sqlQuery: string, options?: any) {
      return MobilecmsApiFp(configuration).getMobileCms(sqlQuery, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * MobilecmsApi - object-oriented interface
 * @export
 * @class MobilecmsApi
 * @extends {BaseAPI}
 */
export class MobilecmsApi extends BaseAPI {
  /**
   * Returns the result of a sql query (uses composer-api domain)
   * @summary Query mobile cms postgres database with GET api.
   * @param {string} sqlQuery complete sql query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MobilecmsApi
   */
  public getMobileCms(sqlQuery: string, options?: any) {
    return MobilecmsApiFp(this.configuration).getMobileCms(sqlQuery, options)(
      this.fetch,
      this.basePath,
    );
  }
}
/**
 * MoodApi - fetch parameter creator
 * @export
 */
export const MoodApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Add a mood for the authorized user (uses chat domain chat.{env}.genies.com)
     * @summary Add mood
     * @param {MoodAddRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMood(body: MoodAddRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling addMood.',
        );
      }
      const localVarPath = `/mood`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'MoodAddRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete the mood of the authorized user (uses chat domain chat.{env}.genies.com)
     * @summary Delete mood
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMood(options: any = {}): FetchArgs {
      const localVarPath = `/mood`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the mood of any user (uses chat domain chat.{env}.genies.com)
     * @summary Get mood
     * @param {string} spaceOwnerId UserId of the owner of the space
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMood(spaceOwnerId: string, options: any = {}): FetchArgs {
      // verify required parameter 'spaceOwnerId' is not null or undefined
      if (spaceOwnerId === null || spaceOwnerId === undefined) {
        throw new RequiredError(
          'spaceOwnerId',
          'Required parameter spaceOwnerId was null or undefined when calling getMood.',
        );
      }
      const localVarPath = `/mood`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (spaceOwnerId !== undefined) {
        localVarQueryParameter['spaceOwnerId'] = spaceOwnerId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MoodApi - functional programming interface
 * @export
 */
export const MoodApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Add a mood for the authorized user (uses chat domain chat.{env}.genies.com)
     * @summary Add mood
     * @param {MoodAddRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMood(
      body: MoodAddRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MoodAddResponse> {
      const localVarFetchArgs = MoodApiFetchParamCreator(configuration).addMood(
        body,
        options,
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete the mood of the authorized user (uses chat domain chat.{env}.genies.com)
     * @summary Delete mood
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMood(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MoodResponse> {
      const localVarFetchArgs =
        MoodApiFetchParamCreator(configuration).deleteMood(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get the mood of any user (uses chat domain chat.{env}.genies.com)
     * @summary Get mood
     * @param {string} spaceOwnerId UserId of the owner of the space
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMood(
      spaceOwnerId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MoodResponse> {
      const localVarFetchArgs = MoodApiFetchParamCreator(configuration).getMood(
        spaceOwnerId,
        options,
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * MoodApi - factory interface
 * @export
 */
export const MoodApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Add a mood for the authorized user (uses chat domain chat.{env}.genies.com)
     * @summary Add mood
     * @param {MoodAddRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMood(body: MoodAddRequest, options?: any) {
      return MoodApiFp(configuration).addMood(body, options)(fetch, basePath);
    },
    /**
     * Delete the mood of the authorized user (uses chat domain chat.{env}.genies.com)
     * @summary Delete mood
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMood(options?: any) {
      return MoodApiFp(configuration).deleteMood(options)(fetch, basePath);
    },
    /**
     * Get the mood of any user (uses chat domain chat.{env}.genies.com)
     * @summary Get mood
     * @param {string} spaceOwnerId UserId of the owner of the space
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMood(spaceOwnerId: string, options?: any) {
      return MoodApiFp(configuration).getMood(spaceOwnerId, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * MoodApi - object-oriented interface
 * @export
 * @class MoodApi
 * @extends {BaseAPI}
 */
export class MoodApi extends BaseAPI {
  /**
   * Add a mood for the authorized user (uses chat domain chat.{env}.genies.com)
   * @summary Add mood
   * @param {MoodAddRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoodApi
   */
  public addMood(body: MoodAddRequest, options?: any) {
    return MoodApiFp(this.configuration).addMood(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Delete the mood of the authorized user (uses chat domain chat.{env}.genies.com)
   * @summary Delete mood
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoodApi
   */
  public deleteMood(options?: any) {
    return MoodApiFp(this.configuration).deleteMood(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Get the mood of any user (uses chat domain chat.{env}.genies.com)
   * @summary Get mood
   * @param {string} spaceOwnerId UserId of the owner of the space
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoodApi
   */
  public getMood(spaceOwnerId: string, options?: any) {
    return MoodApiFp(this.configuration).getMood(spaceOwnerId, options)(
      this.fetch,
      this.basePath,
    );
  }
}
/**
 * RewardApi - fetch parameter creator
 * @export
 */
export const RewardApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Updates reward claim status (uses shim domain, api.{env}.genies)
     * @summary Update reward claim status
     * @param {string} rewardId unique rewardId to update status for
     * @param {string} userId id of the user to get data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRewardStatus(
      rewardId: string,
      userId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'rewardId' is not null or undefined
      if (rewardId === null || rewardId === undefined) {
        throw new RequiredError(
          'rewardId',
          'Required parameter rewardId was null or undefined when calling updateRewardStatus.',
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling updateRewardStatus.',
        );
      }
      const localVarPath = `/reward/{rewardId}/{userId}`
        .replace(`{${'rewardId'}}`, encodeURIComponent(String(rewardId)))
        .replace(`{${'userId'}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RewardApi - functional programming interface
 * @export
 */
export const RewardApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Updates reward claim status (uses shim domain, api.{env}.genies)
     * @summary Update reward claim status
     * @param {string} rewardId unique rewardId to update status for
     * @param {string} userId id of the user to get data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRewardStatus(
      rewardId: string,
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Reward> {
      const localVarFetchArgs = RewardApiFetchParamCreator(
        configuration,
      ).updateRewardStatus(rewardId, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * RewardApi - factory interface
 * @export
 */
export const RewardApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Updates reward claim status (uses shim domain, api.{env}.genies)
     * @summary Update reward claim status
     * @param {string} rewardId unique rewardId to update status for
     * @param {string} userId id of the user to get data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRewardStatus(rewardId: string, userId: string, options?: any) {
      return RewardApiFp(configuration).updateRewardStatus(
        rewardId,
        userId,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * RewardApi - object-oriented interface
 * @export
 * @class RewardApi
 * @extends {BaseAPI}
 */
export class RewardApi extends BaseAPI {
  /**
   * Updates reward claim status (uses shim domain, api.{env}.genies)
   * @summary Update reward claim status
   * @param {string} rewardId unique rewardId to update status for
   * @param {string} userId id of the user to get data from
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RewardApi
   */
  public updateRewardStatus(rewardId: string, userId: string, options?: any) {
    return RewardApiFp(this.configuration).updateRewardStatus(
      rewardId,
      userId,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * SocialUserApi - fetch parameter creator
 * @export
 */
export const SocialUserApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Assings the users traits based on discrete values (uses chat domain chat.{env}.genies.com)
     * @summary Update the user's traits
     * @param {string} userId id of the user to get trait from
     * @param {UserTraitsUpdate} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignUserTraits(
      userId: string,
      body?: UserTraitsUpdate,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling assignUserTraits.',
        );
      }
      const localVarPath = `/user/{userId}/traits`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'UserTraitsUpdate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for blocking user
     * @param {string} userId id of the blocked user
     * @param {string} [type] type of operation - \&quot;BLOCK\&quot; \&quot;UNBLOCK\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blockUser(userId: string, type?: string, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling blockUser.',
        );
      }
      const localVarPath = `/user/{userId}/block`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary Check user contacts if they have Genies account
     * @param {UserContactRequest} body
     * @param {string} userId The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkUserContacts(
      body: UserContactRequest,
      userId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling checkUserContacts.',
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling checkUserContacts.',
        );
      }
      const localVarPath = `/user/{userId}/contact`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'UserContactRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete user social data such as leaderboard, tags. (uses shim domain, api.{env}.genies)
     * @summary Delete social user data
     * @param {string} userId The user that is to be have social data deleted.  If the user account does not exist, the status code will still return with a &#x27;200&#x27; success.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserSocial(userId: string, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling deleteUserSocial.',
        );
      }
      const localVarPath = `/user/{userId}/social`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for getting blocked and blocked_by users
     * @param {string} userId id of calling user
     * @param {string} [type] type of operation - \&quot;BLOCKED\&quot; \&quot;BLOCKED_BY\&quot; \&quot;BOTH\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBidirectionalBlocking(
      userId: string,
      type?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getBidirectionalBlocking.',
        );
      }
      const localVarPath = `/user/{userId}/block`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for getting user rewards status
     * @param {string} userId id of the user to get reward status from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRewardStatus(userId: string, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getRewardStatus.',
        );
      }
      const localVarPath = `/user/{userId}/reward`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for getting counts of user stats
     * @param {string} userId id of the user to get data from
     * @param {string} [nextCursor] Key to get the next page of the save feeds
     * @param {number} [limit] Max number of items to get returned, max number of 25, defaults to 25 if not specified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSaveFeeds(
      userId: string,
      nextCursor?: string,
      limit?: number,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getSaveFeeds.',
        );
      }
      const localVarPath = `/user/{userId}/save/feed`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (nextCursor !== undefined) {
        localVarQueryParameter['nextCursor'] = nextCursor;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Request for EITHER \"feed\" or \"follow\" activity, cannot get both in the same request. If requesting \"feed\" activity and received a cursor, that cursor will only work for the next \"feed\" activity request. (uses shim domain, api.{env}.genies)
     * @summary Get user social activity
     * @param {string} userId The id of the user
     * @param {number} startTime The start time in epoch of the range to view the list of interactions (inclusive).
     * @param {number} endTime The end time in epoch of the range to view the list of interactions (inclusive).
     * @param {number} limit The size of the interactions to fetch. Max limit of 25.
     * @param {string} [activityType] The type of activity to get, can only get one or the other per request. If not present, the default passed will be \&quot;feed\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserActivty(
      userId: string,
      startTime: number,
      endTime: number,
      limit: number,
      activityType?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getUserActivty.',
        );
      }
      // verify required parameter 'startTime' is not null or undefined
      if (startTime === null || startTime === undefined) {
        throw new RequiredError(
          'startTime',
          'Required parameter startTime was null or undefined when calling getUserActivty.',
        );
      }
      // verify required parameter 'endTime' is not null or undefined
      if (endTime === null || endTime === undefined) {
        throw new RequiredError(
          'endTime',
          'Required parameter endTime was null or undefined when calling getUserActivty.',
        );
      }
      // verify required parameter 'limit' is not null or undefined
      if (limit === null || limit === undefined) {
        throw new RequiredError(
          'limit',
          'Required parameter limit was null or undefined when calling getUserActivty.',
        );
      }
      const localVarPath = `/user/{userId}/activity`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (activityType !== undefined) {
        localVarQueryParameter['activityType'] = activityType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for getting user expressive traits
     * @param {string} userId id of the user to get trait from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserArchetype(userId: string, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getUserArchetype.',
        );
      }
      const localVarPath = `/user/{userId}/archetype`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for getting user expressive traits
     * @param {string} userId id of the user to get trait from
     * @param {string} [promptId] promptId of the expressive trait to get from for the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserExpressiveTraits(
      userId: string,
      promptId?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getUserExpressiveTraits.',
        );
      }
      const localVarPath = `/user/{userId}/traits/expressive`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (promptId !== undefined) {
        localVarQueryParameter['promptId'] = promptId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for getting user traits
     * @param {string} userId id of the user to get trait from
     * @param {string} [startTime]
     * @param {string} [endTime]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserTraits(
      userId: string,
      startTime?: string,
      endTime?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getUserTraits.',
        );
      }
      const localVarPath = `/user/{userId}/traits`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Resets the users traits (uses chat domain chat.{env}.genies.com)
     * @summary Reset the user's traits
     * @param {string} userId id of the user to get trait from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetTraits(userId: string, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling resetTraits.',
        );
      }
      const localVarPath = `/user/{userId}/traits`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for user top 3 tags and outfit,saves, and wearables count
     * @param {string} userId id of the user to get the data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagsUser(userId: string, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling tagsUser.',
        );
      }
      const localVarPath = `/user/{userId}/stats`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SocialUserApi - functional programming interface
 * @export
 */
export const SocialUserApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Assings the users traits based on discrete values (uses chat domain chat.{env}.genies.com)
     * @summary Update the user's traits
     * @param {string} userId id of the user to get trait from
     * @param {UserTraitsUpdate} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignUserTraits(
      userId: string,
      body?: UserTraitsUpdate,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = SocialUserApiFetchParamCreator(
        configuration,
      ).assignUserTraits(userId, body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for blocking user
     * @param {string} userId id of the blocked user
     * @param {string} [type] type of operation - \&quot;BLOCK\&quot; \&quot;UNBLOCK\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blockUser(
      userId: string,
      type?: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<UpdateBlockUserResponse> {
      const localVarFetchArgs = SocialUserApiFetchParamCreator(
        configuration,
      ).blockUser(userId, type, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary Check user contacts if they have Genies account
     * @param {UserContactRequest} body
     * @param {string} userId The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkUserContacts(
      body: UserContactRequest,
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserContactResponse> {
      const localVarFetchArgs = SocialUserApiFetchParamCreator(
        configuration,
      ).checkUserContacts(body, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete user social data such as leaderboard, tags. (uses shim domain, api.{env}.genies)
     * @summary Delete social user data
     * @param {string} userId The user that is to be have social data deleted.  If the user account does not exist, the status code will still return with a &#x27;200&#x27; success.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserSocial(
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SocialUserApiFetchParamCreator(
        configuration,
      ).deleteUserSocial(userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for getting blocked and blocked_by users
     * @param {string} userId id of calling user
     * @param {string} [type] type of operation - \&quot;BLOCKED\&quot; \&quot;BLOCKED_BY\&quot; \&quot;BOTH\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBidirectionalBlocking(
      userId: string,
      type?: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<GetBidirectionalBlockedUserListResponse> {
      const localVarFetchArgs = SocialUserApiFetchParamCreator(
        configuration,
      ).getBidirectionalBlocking(userId, type, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for getting user rewards status
     * @param {string} userId id of the user to get reward status from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRewardStatus(
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RewardStatusResponse> {
      const localVarFetchArgs = SocialUserApiFetchParamCreator(
        configuration,
      ).getRewardStatus(userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for getting counts of user stats
     * @param {string} userId id of the user to get data from
     * @param {string} [nextCursor] Key to get the next page of the save feeds
     * @param {number} [limit] Max number of items to get returned, max number of 25, defaults to 25 if not specified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSaveFeeds(
      userId: string,
      nextCursor?: string,
      limit?: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<FeedListResponse> {
      const localVarFetchArgs = SocialUserApiFetchParamCreator(
        configuration,
      ).getSaveFeeds(userId, nextCursor, limit, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Request for EITHER \"feed\" or \"follow\" activity, cannot get both in the same request. If requesting \"feed\" activity and received a cursor, that cursor will only work for the next \"feed\" activity request. (uses shim domain, api.{env}.genies)
     * @summary Get user social activity
     * @param {string} userId The id of the user
     * @param {number} startTime The start time in epoch of the range to view the list of interactions (inclusive).
     * @param {number} endTime The end time in epoch of the range to view the list of interactions (inclusive).
     * @param {number} limit The size of the interactions to fetch. Max limit of 25.
     * @param {string} [activityType] The type of activity to get, can only get one or the other per request. If not present, the default passed will be \&quot;feed\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserActivty(
      userId: string,
      startTime: number,
      endTime: number,
      limit: number,
      activityType?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ActivityResponse> {
      const localVarFetchArgs = SocialUserApiFetchParamCreator(
        configuration,
      ).getUserActivty(
        userId,
        startTime,
        endTime,
        limit,
        activityType,
        options,
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for getting user expressive traits
     * @param {string} userId id of the user to get trait from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserArchetype(
      userId: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<UserGetArchetypeResponse> {
      const localVarFetchArgs = SocialUserApiFetchParamCreator(
        configuration,
      ).getUserArchetype(userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for getting user expressive traits
     * @param {string} userId id of the user to get trait from
     * @param {string} [promptId] promptId of the expressive trait to get from for the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserExpressiveTraits(
      userId: string,
      promptId?: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<UserGetExpressiveTraitResponse> {
      const localVarFetchArgs = SocialUserApiFetchParamCreator(
        configuration,
      ).getUserExpressiveTraits(userId, promptId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for getting user traits
     * @param {string} userId id of the user to get trait from
     * @param {string} [startTime]
     * @param {string} [endTime]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserTraits(
      userId: string,
      startTime?: string,
      endTime?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserGetTraitsResponse> {
      const localVarFetchArgs = SocialUserApiFetchParamCreator(
        configuration,
      ).getUserTraits(userId, startTime, endTime, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Resets the users traits (uses chat domain chat.{env}.genies.com)
     * @summary Reset the user's traits
     * @param {string} userId id of the user to get trait from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetTraits(
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = SocialUserApiFetchParamCreator(
        configuration,
      ).resetTraits(userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for user top 3 tags and outfit,saves, and wearables count
     * @param {string} userId id of the user to get the data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagsUser(
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserStatsResponse> {
      const localVarFetchArgs = SocialUserApiFetchParamCreator(
        configuration,
      ).tagsUser(userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * SocialUserApi - factory interface
 * @export
 */
export const SocialUserApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Assings the users traits based on discrete values (uses chat domain chat.{env}.genies.com)
     * @summary Update the user's traits
     * @param {string} userId id of the user to get trait from
     * @param {UserTraitsUpdate} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignUserTraits(userId: string, body?: UserTraitsUpdate, options?: any) {
      return SocialUserApiFp(configuration).assignUserTraits(
        userId,
        body,
        options,
      )(fetch, basePath);
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for blocking user
     * @param {string} userId id of the blocked user
     * @param {string} [type] type of operation - \&quot;BLOCK\&quot; \&quot;UNBLOCK\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blockUser(userId: string, type?: string, options?: any) {
      return SocialUserApiFp(configuration).blockUser(
        userId,
        type,
        options,
      )(fetch, basePath);
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary Check user contacts if they have Genies account
     * @param {UserContactRequest} body
     * @param {string} userId The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkUserContacts(body: UserContactRequest, userId: string, options?: any) {
      return SocialUserApiFp(configuration).checkUserContacts(
        body,
        userId,
        options,
      )(fetch, basePath);
    },
    /**
     * Delete user social data such as leaderboard, tags. (uses shim domain, api.{env}.genies)
     * @summary Delete social user data
     * @param {string} userId The user that is to be have social data deleted.  If the user account does not exist, the status code will still return with a &#x27;200&#x27; success.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserSocial(userId: string, options?: any) {
      return SocialUserApiFp(configuration).deleteUserSocial(userId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for getting blocked and blocked_by users
     * @param {string} userId id of calling user
     * @param {string} [type] type of operation - \&quot;BLOCKED\&quot; \&quot;BLOCKED_BY\&quot; \&quot;BOTH\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBidirectionalBlocking(userId: string, type?: string, options?: any) {
      return SocialUserApiFp(configuration).getBidirectionalBlocking(
        userId,
        type,
        options,
      )(fetch, basePath);
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for getting user rewards status
     * @param {string} userId id of the user to get reward status from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRewardStatus(userId: string, options?: any) {
      return SocialUserApiFp(configuration).getRewardStatus(userId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for getting counts of user stats
     * @param {string} userId id of the user to get data from
     * @param {string} [nextCursor] Key to get the next page of the save feeds
     * @param {number} [limit] Max number of items to get returned, max number of 25, defaults to 25 if not specified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSaveFeeds(
      userId: string,
      nextCursor?: string,
      limit?: number,
      options?: any,
    ) {
      return SocialUserApiFp(configuration).getSaveFeeds(
        userId,
        nextCursor,
        limit,
        options,
      )(fetch, basePath);
    },
    /**
     * Request for EITHER \"feed\" or \"follow\" activity, cannot get both in the same request. If requesting \"feed\" activity and received a cursor, that cursor will only work for the next \"feed\" activity request. (uses shim domain, api.{env}.genies)
     * @summary Get user social activity
     * @param {string} userId The id of the user
     * @param {number} startTime The start time in epoch of the range to view the list of interactions (inclusive).
     * @param {number} endTime The end time in epoch of the range to view the list of interactions (inclusive).
     * @param {number} limit The size of the interactions to fetch. Max limit of 25.
     * @param {string} [activityType] The type of activity to get, can only get one or the other per request. If not present, the default passed will be \&quot;feed\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserActivty(
      userId: string,
      startTime: number,
      endTime: number,
      limit: number,
      activityType?: string,
      options?: any,
    ) {
      return SocialUserApiFp(configuration).getUserActivty(
        userId,
        startTime,
        endTime,
        limit,
        activityType,
        options,
      )(fetch, basePath);
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for getting user expressive traits
     * @param {string} userId id of the user to get trait from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserArchetype(userId: string, options?: any) {
      return SocialUserApiFp(configuration).getUserArchetype(userId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for getting user expressive traits
     * @param {string} userId id of the user to get trait from
     * @param {string} [promptId] promptId of the expressive trait to get from for the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserExpressiveTraits(userId: string, promptId?: string, options?: any) {
      return SocialUserApiFp(configuration).getUserExpressiveTraits(
        userId,
        promptId,
        options,
      )(fetch, basePath);
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for getting user traits
     * @param {string} userId id of the user to get trait from
     * @param {string} [startTime]
     * @param {string} [endTime]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserTraits(
      userId: string,
      startTime?: string,
      endTime?: string,
      options?: any,
    ) {
      return SocialUserApiFp(configuration).getUserTraits(
        userId,
        startTime,
        endTime,
        options,
      )(fetch, basePath);
    },
    /**
     * Resets the users traits (uses chat domain chat.{env}.genies.com)
     * @summary Reset the user's traits
     * @param {string} userId id of the user to get trait from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetTraits(userId: string, options?: any) {
      return SocialUserApiFp(configuration).resetTraits(userId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary api for user top 3 tags and outfit,saves, and wearables count
     * @param {string} userId id of the user to get the data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagsUser(userId: string, options?: any) {
      return SocialUserApiFp(configuration).tagsUser(userId, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * SocialUserApi - object-oriented interface
 * @export
 * @class SocialUserApi
 * @extends {BaseAPI}
 */
export class SocialUserApi extends BaseAPI {
  /**
   * Assings the users traits based on discrete values (uses chat domain chat.{env}.genies.com)
   * @summary Update the user's traits
   * @param {string} userId id of the user to get trait from
   * @param {UserTraitsUpdate} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SocialUserApi
   */
  public assignUserTraits(
    userId: string,
    body?: UserTraitsUpdate,
    options?: any,
  ) {
    return SocialUserApiFp(this.configuration).assignUserTraits(
      userId,
      body,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * (uses shim domain, api.{env}.genies)
   * @summary api for blocking user
   * @param {string} userId id of the blocked user
   * @param {string} [type] type of operation - \&quot;BLOCK\&quot; \&quot;UNBLOCK\&quot;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SocialUserApi
   */
  public blockUser(userId: string, type?: string, options?: any) {
    return SocialUserApiFp(this.configuration).blockUser(
      userId,
      type,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * (uses shim domain, api.{env}.genies)
   * @summary Check user contacts if they have Genies account
   * @param {UserContactRequest} body
   * @param {string} userId The id of the user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SocialUserApi
   */
  public checkUserContacts(
    body: UserContactRequest,
    userId: string,
    options?: any,
  ) {
    return SocialUserApiFp(this.configuration).checkUserContacts(
      body,
      userId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Delete user social data such as leaderboard, tags. (uses shim domain, api.{env}.genies)
   * @summary Delete social user data
   * @param {string} userId The user that is to be have social data deleted.  If the user account does not exist, the status code will still return with a &#x27;200&#x27; success.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SocialUserApi
   */
  public deleteUserSocial(userId: string, options?: any) {
    return SocialUserApiFp(this.configuration).deleteUserSocial(
      userId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * (uses shim domain, api.{env}.genies)
   * @summary api for getting blocked and blocked_by users
   * @param {string} userId id of calling user
   * @param {string} [type] type of operation - \&quot;BLOCKED\&quot; \&quot;BLOCKED_BY\&quot; \&quot;BOTH\&quot;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SocialUserApi
   */
  public getBidirectionalBlocking(
    userId: string,
    type?: string,
    options?: any,
  ) {
    return SocialUserApiFp(this.configuration).getBidirectionalBlocking(
      userId,
      type,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * (uses shim domain, api.{env}.genies)
   * @summary api for getting user rewards status
   * @param {string} userId id of the user to get reward status from
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SocialUserApi
   */
  public getRewardStatus(userId: string, options?: any) {
    return SocialUserApiFp(this.configuration).getRewardStatus(userId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * (uses shim domain, api.{env}.genies)
   * @summary api for getting counts of user stats
   * @param {string} userId id of the user to get data from
   * @param {string} [nextCursor] Key to get the next page of the save feeds
   * @param {number} [limit] Max number of items to get returned, max number of 25, defaults to 25 if not specified
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SocialUserApi
   */
  public getSaveFeeds(
    userId: string,
    nextCursor?: string,
    limit?: number,
    options?: any,
  ) {
    return SocialUserApiFp(this.configuration).getSaveFeeds(
      userId,
      nextCursor,
      limit,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Request for EITHER \"feed\" or \"follow\" activity, cannot get both in the same request. If requesting \"feed\" activity and received a cursor, that cursor will only work for the next \"feed\" activity request. (uses shim domain, api.{env}.genies)
   * @summary Get user social activity
   * @param {string} userId The id of the user
   * @param {number} startTime The start time in epoch of the range to view the list of interactions (inclusive).
   * @param {number} endTime The end time in epoch of the range to view the list of interactions (inclusive).
   * @param {number} limit The size of the interactions to fetch. Max limit of 25.
   * @param {string} [activityType] The type of activity to get, can only get one or the other per request. If not present, the default passed will be \&quot;feed\&quot;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SocialUserApi
   */
  public getUserActivty(
    userId: string,
    startTime: number,
    endTime: number,
    limit: number,
    activityType?: string,
    options?: any,
  ) {
    return SocialUserApiFp(this.configuration).getUserActivty(
      userId,
      startTime,
      endTime,
      limit,
      activityType,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * (uses shim domain, api.{env}.genies)
   * @summary api for getting user expressive traits
   * @param {string} userId id of the user to get trait from
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SocialUserApi
   */
  public getUserArchetype(userId: string, options?: any) {
    return SocialUserApiFp(this.configuration).getUserArchetype(
      userId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * (uses shim domain, api.{env}.genies)
   * @summary api for getting user expressive traits
   * @param {string} userId id of the user to get trait from
   * @param {string} [promptId] promptId of the expressive trait to get from for the user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SocialUserApi
   */
  public getUserExpressiveTraits(
    userId: string,
    promptId?: string,
    options?: any,
  ) {
    return SocialUserApiFp(this.configuration).getUserExpressiveTraits(
      userId,
      promptId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * (uses shim domain, api.{env}.genies)
   * @summary api for getting user traits
   * @param {string} userId id of the user to get trait from
   * @param {string} [startTime]
   * @param {string} [endTime]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SocialUserApi
   */
  public getUserTraits(
    userId: string,
    startTime?: string,
    endTime?: string,
    options?: any,
  ) {
    return SocialUserApiFp(this.configuration).getUserTraits(
      userId,
      startTime,
      endTime,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Resets the users traits (uses chat domain chat.{env}.genies.com)
   * @summary Reset the user's traits
   * @param {string} userId id of the user to get trait from
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SocialUserApi
   */
  public resetTraits(userId: string, options?: any) {
    return SocialUserApiFp(this.configuration).resetTraits(userId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * (uses shim domain, api.{env}.genies)
   * @summary api for user top 3 tags and outfit,saves, and wearables count
   * @param {string} userId id of the user to get the data from
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SocialUserApi
   */
  public tagsUser(userId: string, options?: any) {
    return SocialUserApiFp(this.configuration).tagsUser(userId, options)(
      this.fetch,
      this.basePath,
    );
  }
}
/**
 * SpaceApi - fetch parameter creator
 * @export
 */
export const SpaceApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Create a user's space
     * @summary Create Space
     * @param {SpaceCreateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSpace(body: SpaceCreateRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createSpace.',
        );
      }
      const localVarPath = `/space`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'SpaceCreateRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a space by the userId
     * @summary Get Space by userId
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSpaceByUserId(userId: string, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getSpaceByUserId.',
        );
      }
      const localVarPath = `/space/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves space feeds based on parameters.
     * @summary Get Space Feeds
     * @param {string} groupId Group ID (required only if type is GROUP).
     * @param {string} sessionId ID of the session.
     * @param {number} [limit] Maximum number of feeds to retrieve (default 25).
     * @param {number} [offset] Start index for pagination.
     * @param {string} [type] Type of feed (FRIEND or GROUP).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSpaceFeeds(
      groupId: string,
      sessionId: string,
      limit?: number,
      offset?: number,
      type?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'groupId' is not null or undefined
      if (groupId === null || groupId === undefined) {
        throw new RequiredError(
          'groupId',
          'Required parameter groupId was null or undefined when calling getSpaceFeeds.',
        );
      }
      // verify required parameter 'sessionId' is not null or undefined
      if (sessionId === null || sessionId === undefined) {
        throw new RequiredError(
          'sessionId',
          'Required parameter sessionId was null or undefined when calling getSpaceFeeds.',
        );
      }
      const localVarPath = `/space/feed`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (groupId !== undefined) {
        localVarQueryParameter['groupId'] = groupId;
      }

      if (sessionId !== undefined) {
        localVarQueryParameter['sessionId'] = sessionId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Interact with a space.
     * @summary Visit a space
     * @param {string} userId UserID of the space to visit.
     * @param {string} type Type of interaction (VISIT).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    interactSpace(userId: string, type: string, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling interactSpace.',
        );
      }
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError(
          'type',
          'Required parameter type was null or undefined when calling interactSpace.',
        );
      }
      const localVarPath = `/space/interact/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a user's space
     * @summary Update Space
     * @param {SpaceUpdate} body
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSpace(
      body: SpaceUpdate,
      userId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateSpace.',
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling updateSpace.',
        );
      }
      const localVarPath = `/space/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'SpaceUpdate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SpaceApi - functional programming interface
 * @export
 */
export const SpaceApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Create a user's space
     * @summary Create Space
     * @param {SpaceCreateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSpace(
      body: SpaceCreateRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Space> {
      const localVarFetchArgs = SpaceApiFetchParamCreator(
        configuration,
      ).createSpace(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get a space by the userId
     * @summary Get Space by userId
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSpaceByUserId(
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Space> {
      const localVarFetchArgs = SpaceApiFetchParamCreator(
        configuration,
      ).getSpaceByUserId(userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieves space feeds based on parameters.
     * @summary Get Space Feeds
     * @param {string} groupId Group ID (required only if type is GROUP).
     * @param {string} sessionId ID of the session.
     * @param {number} [limit] Maximum number of feeds to retrieve (default 25).
     * @param {number} [offset] Start index for pagination.
     * @param {string} [type] Type of feed (FRIEND or GROUP).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSpaceFeeds(
      groupId: string,
      sessionId: string,
      limit?: number,
      offset?: number,
      type?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<SpaceFeeds> {
      const localVarFetchArgs = SpaceApiFetchParamCreator(
        configuration,
      ).getSpaceFeeds(groupId, sessionId, limit, offset, type, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Interact with a space.
     * @summary Visit a space
     * @param {string} userId UserID of the space to visit.
     * @param {string} type Type of interaction (VISIT).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    interactSpace(
      userId: string,
      type: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = SpaceApiFetchParamCreator(
        configuration,
      ).interactSpace(userId, type, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update a user's space
     * @summary Update Space
     * @param {SpaceUpdate} body
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSpace(
      body: SpaceUpdate,
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = SpaceApiFetchParamCreator(
        configuration,
      ).updateSpace(body, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * SpaceApi - factory interface
 * @export
 */
export const SpaceApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Create a user's space
     * @summary Create Space
     * @param {SpaceCreateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSpace(body: SpaceCreateRequest, options?: any) {
      return SpaceApiFp(configuration).createSpace(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Get a space by the userId
     * @summary Get Space by userId
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSpaceByUserId(userId: string, options?: any) {
      return SpaceApiFp(configuration).getSpaceByUserId(userId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Retrieves space feeds based on parameters.
     * @summary Get Space Feeds
     * @param {string} groupId Group ID (required only if type is GROUP).
     * @param {string} sessionId ID of the session.
     * @param {number} [limit] Maximum number of feeds to retrieve (default 25).
     * @param {number} [offset] Start index for pagination.
     * @param {string} [type] Type of feed (FRIEND or GROUP).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSpaceFeeds(
      groupId: string,
      sessionId: string,
      limit?: number,
      offset?: number,
      type?: string,
      options?: any,
    ) {
      return SpaceApiFp(configuration).getSpaceFeeds(
        groupId,
        sessionId,
        limit,
        offset,
        type,
        options,
      )(fetch, basePath);
    },
    /**
     * Interact with a space.
     * @summary Visit a space
     * @param {string} userId UserID of the space to visit.
     * @param {string} type Type of interaction (VISIT).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    interactSpace(userId: string, type: string, options?: any) {
      return SpaceApiFp(configuration).interactSpace(
        userId,
        type,
        options,
      )(fetch, basePath);
    },
    /**
     * Update a user's space
     * @summary Update Space
     * @param {SpaceUpdate} body
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSpace(body: SpaceUpdate, userId: string, options?: any) {
      return SpaceApiFp(configuration).updateSpace(
        body,
        userId,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * SpaceApi - object-oriented interface
 * @export
 * @class SpaceApi
 * @extends {BaseAPI}
 */
export class SpaceApi extends BaseAPI {
  /**
   * Create a user's space
   * @summary Create Space
   * @param {SpaceCreateRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpaceApi
   */
  public createSpace(body: SpaceCreateRequest, options?: any) {
    return SpaceApiFp(this.configuration).createSpace(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Get a space by the userId
   * @summary Get Space by userId
   * @param {string} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpaceApi
   */
  public getSpaceByUserId(userId: string, options?: any) {
    return SpaceApiFp(this.configuration).getSpaceByUserId(userId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Retrieves space feeds based on parameters.
   * @summary Get Space Feeds
   * @param {string} groupId Group ID (required only if type is GROUP).
   * @param {string} sessionId ID of the session.
   * @param {number} [limit] Maximum number of feeds to retrieve (default 25).
   * @param {number} [offset] Start index for pagination.
   * @param {string} [type] Type of feed (FRIEND or GROUP).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpaceApi
   */
  public getSpaceFeeds(
    groupId: string,
    sessionId: string,
    limit?: number,
    offset?: number,
    type?: string,
    options?: any,
  ) {
    return SpaceApiFp(this.configuration).getSpaceFeeds(
      groupId,
      sessionId,
      limit,
      offset,
      type,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Interact with a space.
   * @summary Visit a space
   * @param {string} userId UserID of the space to visit.
   * @param {string} type Type of interaction (VISIT).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpaceApi
   */
  public interactSpace(userId: string, type: string, options?: any) {
    return SpaceApiFp(this.configuration).interactSpace(
      userId,
      type,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Update a user's space
   * @summary Update Space
   * @param {SpaceUpdate} body
   * @param {string} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpaceApi
   */
  public updateSpace(body: SpaceUpdate, userId: string, options?: any) {
    return SpaceApiFp(this.configuration).updateSpace(
      body,
      userId,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * StatsigApi - fetch parameter creator
 * @export
 */
export const StatsigApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Add a user to a statsig segment (uses composer-api domain)
     * @summary Add a user to a statsig segment
     * @param {StatsigSegmentListUpdate} body Statsig Segment Update List Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStatsigSegmentList(
      body: StatsigSegmentListUpdate,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateStatsigSegmentList.',
        );
      }
      const localVarPath = `/statsig/segment/user`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'StatsigSegmentListUpdate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StatsigApi - functional programming interface
 * @export
 */
export const StatsigApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Add a user to a statsig segment (uses composer-api domain)
     * @summary Add a user to a statsig segment
     * @param {StatsigSegmentListUpdate} body Statsig Segment Update List Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStatsigSegmentList(
      body: StatsigSegmentListUpdate,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = StatsigApiFetchParamCreator(
        configuration,
      ).updateStatsigSegmentList(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * StatsigApi - factory interface
 * @export
 */
export const StatsigApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Add a user to a statsig segment (uses composer-api domain)
     * @summary Add a user to a statsig segment
     * @param {StatsigSegmentListUpdate} body Statsig Segment Update List Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStatsigSegmentList(body: StatsigSegmentListUpdate, options?: any) {
      return StatsigApiFp(configuration).updateStatsigSegmentList(
        body,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * StatsigApi - object-oriented interface
 * @export
 * @class StatsigApi
 * @extends {BaseAPI}
 */
export class StatsigApi extends BaseAPI {
  /**
   * Add a user to a statsig segment (uses composer-api domain)
   * @summary Add a user to a statsig segment
   * @param {StatsigSegmentListUpdate} body Statsig Segment Update List Object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatsigApi
   */
  public updateStatsigSegmentList(
    body: StatsigSegmentListUpdate,
    options?: any,
  ) {
    return StatsigApiFp(this.configuration).updateStatsigSegmentList(
      body,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * ThingsApi - fetch parameter creator
 * @export
 */
export const ThingsApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Get list of things
     * @param {string} [cursor] the pagination cursor
     * @param {number} [limit] the pagination size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminGetThings(
      cursor?: string,
      limit?: number,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/admin/things`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (cursor !== undefined) {
        localVarQueryParameter['cursor'] = cursor;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Soft delete thing
     * @param {string} thingId id of the thing to soft delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminSoftDeleteThings(thingId: string, options: any = {}): FetchArgs {
      // verify required parameter 'thingId' is not null or undefined
      if (thingId === null || thingId === undefined) {
        throw new RequiredError(
          'thingId',
          'Required parameter thingId was null or undefined when calling adminSoftDeleteThings.',
        );
      }
      const localVarPath = `/things/{thingId}`.replace(
        `{${'thingId'}}`,
        encodeURIComponent(String(thingId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary create thing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createThing(options: any = {}): FetchArgs {
      const localVarPath = `/pipeline/things`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary create the version of thing, two types of the create thing version -Name and description -New Asset If we update the name and description, it will create the new thing version. If the isNewAsset is true, it mean the user will upload a new thing asset.
     * @param {ThingVersionCreate} body Feed creation object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createThingVersion(body: ThingVersionCreate, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createThingVersion.',
        );
      }
      const localVarPath = `/things/version`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'ThingVersionCreate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary Get list of things
     * @param {string} type the way to get things
     * @param {string} [thingId] the thing id when the type is THING_ID
     * @param {boolean} [includeVersion] if type is USER, whether to include the most recent thing version in response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThings(
      type: string,
      thingId?: string,
      includeVersion?: boolean,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError(
          'type',
          'Required parameter type was null or undefined when calling getThings.',
        );
      }
      const localVarPath = `/things`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (thingId !== undefined) {
        localVarQueryParameter['thingId'] = thingId;
      }

      if (includeVersion !== undefined) {
        localVarQueryParameter['includeVersion'] = includeVersion;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary Get the version of thing
     * @param {string} thingId id of the thing to get associated versions
     * @param {string} [type] Filter to get all or by status
     * @param {string} [status] filter to retrieve by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThingsVersion(
      thingId: string,
      type?: string,
      status?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'thingId' is not null or undefined
      if (thingId === null || thingId === undefined) {
        throw new RequiredError(
          'thingId',
          'Required parameter thingId was null or undefined when calling getThingsVersion.',
        );
      }
      const localVarPath = `/things/version/{thingId}`.replace(
        `{${'thingId'}}`,
        encodeURIComponent(String(thingId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary Get list of things
     * @param {string} type the way to get things
     * @param {string} [thingId] the thing id when the type is THING_ID
     * @param {boolean} [includeVersion] if type is USER, whether to include the most recent thing version in response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineGetThings(
      type: string,
      thingId?: string,
      includeVersion?: boolean,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError(
          'type',
          'Required parameter type was null or undefined when calling pipelineGetThings.',
        );
      }
      const localVarPath = `/pipeline/things`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (thingId !== undefined) {
        localVarQueryParameter['thingId'] = thingId;
      }

      if (includeVersion !== undefined) {
        localVarQueryParameter['includeVersion'] = includeVersion;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary update the thing version
     * @param {ThingVersionPipelineUpdate} body Things update version body
     * @param {string} thingId id of the thing to get associated version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineUpdateThingVersion(
      body: ThingVersionPipelineUpdate,
      thingId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling pipelineUpdateThingVersion.',
        );
      }
      // verify required parameter 'thingId' is not null or undefined
      if (thingId === null || thingId === undefined) {
        throw new RequiredError(
          'thingId',
          'Required parameter thingId was null or undefined when calling pipelineUpdateThingVersion.',
        );
      }
      const localVarPath = `/pipeline/things/version/{thingId}`.replace(
        `{${'thingId'}}`,
        encodeURIComponent(String(thingId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'ThingVersionPipelineUpdate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary update the thing map with a key value pair
     * @param {ThingMapUpdate} body array of maps
     * @param {string} thingId id of the thing to get associated versions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateThingMap(
      body: ThingMapUpdate,
      thingId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateThingMap.',
        );
      }
      // verify required parameter 'thingId' is not null or undefined
      if (thingId === null || thingId === undefined) {
        throw new RequiredError(
          'thingId',
          'Required parameter thingId was null or undefined when calling updateThingMap.',
        );
      }
      const localVarPath = `/things/{thingId}`.replace(
        `{${'thingId'}}`,
        encodeURIComponent(String(thingId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'ThingMapUpdate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary update the thing version
     * @param {ThingVersionUpdate} body Things update version body
     * @param {string} thingId id of the thing to get associated version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateThingVersion(
      body: ThingVersionUpdate,
      thingId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateThingVersion.',
        );
      }
      // verify required parameter 'thingId' is not null or undefined
      if (thingId === null || thingId === undefined) {
        throw new RequiredError(
          'thingId',
          'Required parameter thingId was null or undefined when calling updateThingVersion.',
        );
      }
      const localVarPath = `/things/version/{thingId}`.replace(
        `{${'thingId'}}`,
        encodeURIComponent(String(thingId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'ThingVersionUpdate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ThingsApi - functional programming interface
 * @export
 */
export const ThingsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get list of things
     * @param {string} [cursor] the pagination cursor
     * @param {number} [limit] the pagination size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminGetThings(
      cursor?: string,
      limit?: number,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<ThingsAdminGetResponse> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(
        configuration,
      ).adminGetThings(cursor, limit, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Soft delete thing
     * @param {string} thingId id of the thing to soft delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminSoftDeleteThings(
      thingId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(
        configuration,
      ).adminSoftDeleteThings(thingId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary create thing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createThing(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ThingCreateResponse> {
      const localVarFetchArgs =
        ThingsApiFetchParamCreator(configuration).createThing(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary create the version of thing, two types of the create thing version -Name and description -New Asset If we update the name and description, it will create the new thing version. If the isNewAsset is true, it mean the user will upload a new thing asset.
     * @param {ThingVersionCreate} body Feed creation object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createThingVersion(
      body: ThingVersionCreate,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<ThingVersionCreateResponse> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(
        configuration,
      ).createThingVersion(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary Get list of things
     * @param {string} type the way to get things
     * @param {string} [thingId] the thing id when the type is THING_ID
     * @param {boolean} [includeVersion] if type is USER, whether to include the most recent thing version in response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThings(
      type: string,
      thingId?: string,
      includeVersion?: boolean,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ThingGetResponse> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(
        configuration,
      ).getThings(type, thingId, includeVersion, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary Get the version of thing
     * @param {string} thingId id of the thing to get associated versions
     * @param {string} [type] Filter to get all or by status
     * @param {string} [status] filter to retrieve by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThingsVersion(
      thingId: string,
      type?: string,
      status?: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<ThingVersionGetResponse> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(
        configuration,
      ).getThingsVersion(thingId, type, status, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary Get list of things
     * @param {string} type the way to get things
     * @param {string} [thingId] the thing id when the type is THING_ID
     * @param {boolean} [includeVersion] if type is USER, whether to include the most recent thing version in response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineGetThings(
      type: string,
      thingId?: string,
      includeVersion?: boolean,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ThingGetResponse> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(
        configuration,
      ).pipelineGetThings(type, thingId, includeVersion, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary update the thing version
     * @param {ThingVersionPipelineUpdate} body Things update version body
     * @param {string} thingId id of the thing to get associated version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineUpdateThingVersion(
      body: ThingVersionPipelineUpdate,
      thingId: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<ThingVersionUpdateResponse> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(
        configuration,
      ).pipelineUpdateThingVersion(body, thingId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary update the thing map with a key value pair
     * @param {ThingMapUpdate} body array of maps
     * @param {string} thingId id of the thing to get associated versions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateThingMap(
      body: ThingMapUpdate,
      thingId: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<ThingMapUpdateResponse> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(
        configuration,
      ).updateThingMap(body, thingId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary update the thing version
     * @param {ThingVersionUpdate} body Things update version body
     * @param {string} thingId id of the thing to get associated version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateThingVersion(
      body: ThingVersionUpdate,
      thingId: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<ThingVersionUpdateResponse> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(
        configuration,
      ).updateThingVersion(body, thingId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ThingsApi - factory interface
 * @export
 */
export const ThingsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Get list of things
     * @param {string} [cursor] the pagination cursor
     * @param {number} [limit] the pagination size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminGetThings(cursor?: string, limit?: number, options?: any) {
      return ThingsApiFp(configuration).adminGetThings(
        cursor,
        limit,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Soft delete thing
     * @param {string} thingId id of the thing to soft delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminSoftDeleteThings(thingId: string, options?: any) {
      return ThingsApiFp(configuration).adminSoftDeleteThings(thingId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary create thing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createThing(options?: any) {
      return ThingsApiFp(configuration).createThing(options)(fetch, basePath);
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary create the version of thing, two types of the create thing version -Name and description -New Asset If we update the name and description, it will create the new thing version. If the isNewAsset is true, it mean the user will upload a new thing asset.
     * @param {ThingVersionCreate} body Feed creation object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createThingVersion(body: ThingVersionCreate, options?: any) {
      return ThingsApiFp(configuration).createThingVersion(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary Get list of things
     * @param {string} type the way to get things
     * @param {string} [thingId] the thing id when the type is THING_ID
     * @param {boolean} [includeVersion] if type is USER, whether to include the most recent thing version in response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThings(
      type: string,
      thingId?: string,
      includeVersion?: boolean,
      options?: any,
    ) {
      return ThingsApiFp(configuration).getThings(
        type,
        thingId,
        includeVersion,
        options,
      )(fetch, basePath);
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary Get the version of thing
     * @param {string} thingId id of the thing to get associated versions
     * @param {string} [type] Filter to get all or by status
     * @param {string} [status] filter to retrieve by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThingsVersion(
      thingId: string,
      type?: string,
      status?: string,
      options?: any,
    ) {
      return ThingsApiFp(configuration).getThingsVersion(
        thingId,
        type,
        status,
        options,
      )(fetch, basePath);
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary Get list of things
     * @param {string} type the way to get things
     * @param {string} [thingId] the thing id when the type is THING_ID
     * @param {boolean} [includeVersion] if type is USER, whether to include the most recent thing version in response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineGetThings(
      type: string,
      thingId?: string,
      includeVersion?: boolean,
      options?: any,
    ) {
      return ThingsApiFp(configuration).pipelineGetThings(
        type,
        thingId,
        includeVersion,
        options,
      )(fetch, basePath);
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary update the thing version
     * @param {ThingVersionPipelineUpdate} body Things update version body
     * @param {string} thingId id of the thing to get associated version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineUpdateThingVersion(
      body: ThingVersionPipelineUpdate,
      thingId: string,
      options?: any,
    ) {
      return ThingsApiFp(configuration).pipelineUpdateThingVersion(
        body,
        thingId,
        options,
      )(fetch, basePath);
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary update the thing map with a key value pair
     * @param {ThingMapUpdate} body array of maps
     * @param {string} thingId id of the thing to get associated versions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateThingMap(body: ThingMapUpdate, thingId: string, options?: any) {
      return ThingsApiFp(configuration).updateThingMap(
        body,
        thingId,
        options,
      )(fetch, basePath);
    },
    /**
     * (uses shim domain, api.{env}.genies)
     * @summary update the thing version
     * @param {ThingVersionUpdate} body Things update version body
     * @param {string} thingId id of the thing to get associated version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateThingVersion(
      body: ThingVersionUpdate,
      thingId: string,
      options?: any,
    ) {
      return ThingsApiFp(configuration).updateThingVersion(
        body,
        thingId,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * ThingsApi - object-oriented interface
 * @export
 * @class ThingsApi
 * @extends {BaseAPI}
 */
export class ThingsApi extends BaseAPI {
  /**
   *
   * @summary Get list of things
   * @param {string} [cursor] the pagination cursor
   * @param {number} [limit] the pagination size
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public adminGetThings(cursor?: string, limit?: number, options?: any) {
    return ThingsApiFp(this.configuration).adminGetThings(
      cursor,
      limit,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Soft delete thing
   * @param {string} thingId id of the thing to soft delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public adminSoftDeleteThings(thingId: string, options?: any) {
    return ThingsApiFp(this.configuration).adminSoftDeleteThings(
      thingId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * (uses shim domain, api.{env}.genies)
   * @summary create thing
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public createThing(options?: any) {
    return ThingsApiFp(this.configuration).createThing(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * (uses shim domain, api.{env}.genies)
   * @summary create the version of thing, two types of the create thing version -Name and description -New Asset If we update the name and description, it will create the new thing version. If the isNewAsset is true, it mean the user will upload a new thing asset.
   * @param {ThingVersionCreate} body Feed creation object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public createThingVersion(body: ThingVersionCreate, options?: any) {
    return ThingsApiFp(this.configuration).createThingVersion(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * (uses shim domain, api.{env}.genies)
   * @summary Get list of things
   * @param {string} type the way to get things
   * @param {string} [thingId] the thing id when the type is THING_ID
   * @param {boolean} [includeVersion] if type is USER, whether to include the most recent thing version in response
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public getThings(
    type: string,
    thingId?: string,
    includeVersion?: boolean,
    options?: any,
  ) {
    return ThingsApiFp(this.configuration).getThings(
      type,
      thingId,
      includeVersion,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * (uses shim domain, api.{env}.genies)
   * @summary Get the version of thing
   * @param {string} thingId id of the thing to get associated versions
   * @param {string} [type] Filter to get all or by status
   * @param {string} [status] filter to retrieve by status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public getThingsVersion(
    thingId: string,
    type?: string,
    status?: string,
    options?: any,
  ) {
    return ThingsApiFp(this.configuration).getThingsVersion(
      thingId,
      type,
      status,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * (uses shim domain, api.{env}.genies)
   * @summary Get list of things
   * @param {string} type the way to get things
   * @param {string} [thingId] the thing id when the type is THING_ID
   * @param {boolean} [includeVersion] if type is USER, whether to include the most recent thing version in response
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public pipelineGetThings(
    type: string,
    thingId?: string,
    includeVersion?: boolean,
    options?: any,
  ) {
    return ThingsApiFp(this.configuration).pipelineGetThings(
      type,
      thingId,
      includeVersion,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * (uses shim domain, api.{env}.genies)
   * @summary update the thing version
   * @param {ThingVersionPipelineUpdate} body Things update version body
   * @param {string} thingId id of the thing to get associated version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public pipelineUpdateThingVersion(
    body: ThingVersionPipelineUpdate,
    thingId: string,
    options?: any,
  ) {
    return ThingsApiFp(this.configuration).pipelineUpdateThingVersion(
      body,
      thingId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * (uses shim domain, api.{env}.genies)
   * @summary update the thing map with a key value pair
   * @param {ThingMapUpdate} body array of maps
   * @param {string} thingId id of the thing to get associated versions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public updateThingMap(body: ThingMapUpdate, thingId: string, options?: any) {
    return ThingsApiFp(this.configuration).updateThingMap(
      body,
      thingId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * (uses shim domain, api.{env}.genies)
   * @summary update the thing version
   * @param {ThingVersionUpdate} body Things update version body
   * @param {string} thingId id of the thing to get associated version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public updateThingVersion(
    body: ThingVersionUpdate,
    thingId: string,
    options?: any,
  ) {
    return ThingsApiFp(this.configuration).updateThingVersion(
      body,
      thingId,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * TokenApi - fetch parameter creator
 * @export
 */
export const TokenApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Deletes the refresh token for a provider.
     * @summary Delete refresh token
     * @param {string} provider Provider of the tokens (SPOTIFY).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRefreshToken(provider: string, options: any = {}): FetchArgs {
      // verify required parameter 'provider' is not null or undefined
      if (provider === null || provider === undefined) {
        throw new RequiredError(
          'provider',
          'Required parameter provider was null or undefined when calling deleteRefreshToken.',
        );
      }
      const localVarPath = `/token`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (provider !== undefined) {
        localVarQueryParameter['provider'] = provider;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves tokens for a provider.
     * @summary Fetch tokens
     * @param {string} provider Provider of the tokens (SPOTIFY).
     * @param {string} userId User ID to fetch tokens for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchTokens(
      provider: string,
      userId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'provider' is not null or undefined
      if (provider === null || provider === undefined) {
        throw new RequiredError(
          'provider',
          'Required parameter provider was null or undefined when calling fetchTokens.',
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling fetchTokens.',
        );
      }
      const localVarPath = `/token`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (provider !== undefined) {
        localVarQueryParameter['provider'] = provider;
      }

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Stores tokens for a provider.
     * @summary Store tokens
     * @param {TokenRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeTokens(body: TokenRequestBody, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling storeTokens.',
        );
      }
      const localVarPath = `/token`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'TokenRequestBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates tokens for a provider.
     * @summary Update tokens
     * @param {TokenRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTokens(body: TokenRequestBody, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateTokens.',
        );
      }
      const localVarPath = `/token`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'TokenRequestBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TokenApi - functional programming interface
 * @export
 */
export const TokenApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Deletes the refresh token for a provider.
     * @summary Delete refresh token
     * @param {string} provider Provider of the tokens (SPOTIFY).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRefreshToken(
      provider: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = TokenApiFetchParamCreator(
        configuration,
      ).deleteRefreshToken(provider, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieves tokens for a provider.
     * @summary Fetch tokens
     * @param {string} provider Provider of the tokens (SPOTIFY).
     * @param {string} userId User ID to fetch tokens for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchTokens(
      provider: string,
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<TokenResponse> {
      const localVarFetchArgs = TokenApiFetchParamCreator(
        configuration,
      ).fetchTokens(provider, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Stores tokens for a provider.
     * @summary Store tokens
     * @param {TokenRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeTokens(
      body: TokenRequestBody,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = TokenApiFetchParamCreator(
        configuration,
      ).storeTokens(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Updates tokens for a provider.
     * @summary Update tokens
     * @param {TokenRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTokens(
      body: TokenRequestBody,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = TokenApiFetchParamCreator(
        configuration,
      ).updateTokens(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * TokenApi - factory interface
 * @export
 */
export const TokenApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Deletes the refresh token for a provider.
     * @summary Delete refresh token
     * @param {string} provider Provider of the tokens (SPOTIFY).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRefreshToken(provider: string, options?: any) {
      return TokenApiFp(configuration).deleteRefreshToken(provider, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Retrieves tokens for a provider.
     * @summary Fetch tokens
     * @param {string} provider Provider of the tokens (SPOTIFY).
     * @param {string} userId User ID to fetch tokens for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchTokens(provider: string, userId: string, options?: any) {
      return TokenApiFp(configuration).fetchTokens(
        provider,
        userId,
        options,
      )(fetch, basePath);
    },
    /**
     * Stores tokens for a provider.
     * @summary Store tokens
     * @param {TokenRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeTokens(body: TokenRequestBody, options?: any) {
      return TokenApiFp(configuration).storeTokens(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Updates tokens for a provider.
     * @summary Update tokens
     * @param {TokenRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTokens(body: TokenRequestBody, options?: any) {
      return TokenApiFp(configuration).updateTokens(body, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * TokenApi - object-oriented interface
 * @export
 * @class TokenApi
 * @extends {BaseAPI}
 */
export class TokenApi extends BaseAPI {
  /**
   * Deletes the refresh token for a provider.
   * @summary Delete refresh token
   * @param {string} provider Provider of the tokens (SPOTIFY).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokenApi
   */
  public deleteRefreshToken(provider: string, options?: any) {
    return TokenApiFp(this.configuration).deleteRefreshToken(provider, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Retrieves tokens for a provider.
   * @summary Fetch tokens
   * @param {string} provider Provider of the tokens (SPOTIFY).
   * @param {string} userId User ID to fetch tokens for.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokenApi
   */
  public fetchTokens(provider: string, userId: string, options?: any) {
    return TokenApiFp(this.configuration).fetchTokens(
      provider,
      userId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Stores tokens for a provider.
   * @summary Store tokens
   * @param {TokenRequestBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokenApi
   */
  public storeTokens(body: TokenRequestBody, options?: any) {
    return TokenApiFp(this.configuration).storeTokens(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Updates tokens for a provider.
   * @summary Update tokens
   * @param {TokenRequestBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokenApi
   */
  public updateTokens(body: TokenRequestBody, options?: any) {
    return TokenApiFp(this.configuration).updateTokens(body, options)(
      this.fetch,
      this.basePath,
    );
  }
}
/**
 * TraitsApi - fetch parameter creator
 * @export
 */
export const TraitsApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get the prompt of the day. From shim API with trait service
     * @summary Get the prompt of the day.
     * @param {string} [timeZone] timezone in UTC format ex: \&quot;00:00\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrompt(timeZone?: string, options: any = {}): FetchArgs {
      const localVarPath = `/traits/prompt`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (timeZone !== undefined) {
        localVarQueryParameter['time_zone'] = timeZone;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the mood (uses chat domain chat.{env}.genies.com)
     * @summary Get traits mood
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTraitsMood(options: any = {}): FetchArgs {
      const localVarPath = `/traits/mood`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TraitsApi - functional programming interface
 * @export
 */
export const TraitsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Get the prompt of the day. From shim API with trait service
     * @summary Get the prompt of the day.
     * @param {string} [timeZone] timezone in UTC format ex: \&quot;00:00\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrompt(
      timeZone?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GetPromptResponse> {
      const localVarFetchArgs = TraitsApiFetchParamCreator(
        configuration,
      ).getPrompt(timeZone, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get the mood (uses chat domain chat.{env}.genies.com)
     * @summary Get traits mood
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTraitsMood(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MoodGetResponse> {
      const localVarFetchArgs =
        TraitsApiFetchParamCreator(configuration).getTraitsMood(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * TraitsApi - factory interface
 * @export
 */
export const TraitsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Get the prompt of the day. From shim API with trait service
     * @summary Get the prompt of the day.
     * @param {string} [timeZone] timezone in UTC format ex: \&quot;00:00\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrompt(timeZone?: string, options?: any) {
      return TraitsApiFp(configuration).getPrompt(timeZone, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Get the mood (uses chat domain chat.{env}.genies.com)
     * @summary Get traits mood
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTraitsMood(options?: any) {
      return TraitsApiFp(configuration).getTraitsMood(options)(fetch, basePath);
    },
  };
};

/**
 * TraitsApi - object-oriented interface
 * @export
 * @class TraitsApi
 * @extends {BaseAPI}
 */
export class TraitsApi extends BaseAPI {
  /**
   * Get the prompt of the day. From shim API with trait service
   * @summary Get the prompt of the day.
   * @param {string} [timeZone] timezone in UTC format ex: \&quot;00:00\&quot;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TraitsApi
   */
  public getPrompt(timeZone?: string, options?: any) {
    return TraitsApiFp(this.configuration).getPrompt(timeZone, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Get the mood (uses chat domain chat.{env}.genies.com)
   * @summary Get traits mood
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TraitsApi
   */
  public getTraitsMood(options?: any) {
    return TraitsApiFp(this.configuration).getTraitsMood(options)(
      this.fetch,
      this.basePath,
    );
  }
}
/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Delete user account. This will also delete the user's avatar.
     * @summary Delete user
     * @param {string} userId The user that is to be deleted.  If the user account does not exist, the status code will still return with a &#x27;200&#x27; success.
     * @param {string} accessToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(
      userId: string,
      accessToken: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling deleteUser.',
        );
      }
      // verify required parameter 'accessToken' is not null or undefined
      if (accessToken === null || accessToken === undefined) {
        throw new RequiredError(
          'accessToken',
          'Required parameter accessToken was null or undefined when calling deleteUser.',
        );
      }
      const localVarPath = `/user/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (accessToken !== undefined) {
        localVarQueryParameter['accessToken'] = accessToken;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(options: any = {}): FetchArgs {
      const localVarPath = `/user`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update user data such as preferred username
     * @summary Update user data properties
     * @param {UserUpdate} body User Update Object
     * @param {string} userId The id of the user
     * @param {string} accessToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(
      body: UserUpdate,
      userId: string,
      accessToken: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateUser.',
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling updateUser.',
        );
      }
      // verify required parameter 'accessToken' is not null or undefined
      if (accessToken === null || accessToken === undefined) {
        throw new RequiredError(
          'accessToken',
          'Required parameter accessToken was null or undefined when calling updateUser.',
        );
      }
      const localVarPath = `/user/{userId}/user`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (accessToken !== undefined) {
        localVarQueryParameter['accessToken'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'UserUpdate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Used to upload image (like profile) to S3 bucket   If successfully upload image, will return 200 status code and url to  the image. If incorrect userId or image payload provided,  BadRequest error is returned
     * @summary Upload user image
     * @param {UserImageUpload} body User Image Upload Object
     * @param {string} userId The id of the user who uploads the image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadImage(
      body: UserImageUpload,
      userId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling uploadImage.',
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling uploadImage.',
        );
      }
      const localVarPath = `/user/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'UserImageUpload' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Delete user account. This will also delete the user's avatar.
     * @summary Delete user
     * @param {string} userId The user that is to be deleted.  If the user account does not exist, the status code will still return with a &#x27;200&#x27; success.
     * @param {string} accessToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(
      userId: string,
      accessToken: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration,
      ).deleteUser(userId, accessToken, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
      const localVarFetchArgs =
        UserApiFetchParamCreator(configuration).getUser(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update user data such as preferred username
     * @summary Update user data properties
     * @param {UserUpdate} body User Update Object
     * @param {string} userId The id of the user
     * @param {string} accessToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(
      body: UserUpdate,
      userId: string,
      accessToken: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration,
      ).updateUser(body, userId, accessToken, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Used to upload image (like profile) to S3 bucket   If successfully upload image, will return 200 status code and url to  the image. If incorrect userId or image payload provided,  BadRequest error is returned
     * @summary Upload user image
     * @param {UserImageUpload} body User Image Upload Object
     * @param {string} userId The id of the user who uploads the image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadImage(
      body: UserImageUpload,
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration,
      ).uploadImage(body, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Delete user account. This will also delete the user's avatar.
     * @summary Delete user
     * @param {string} userId The user that is to be deleted.  If the user account does not exist, the status code will still return with a &#x27;200&#x27; success.
     * @param {string} accessToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(userId: string, accessToken: string, options?: any) {
      return UserApiFp(configuration).deleteUser(
        userId,
        accessToken,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(options?: any) {
      return UserApiFp(configuration).getUser(options)(fetch, basePath);
    },
    /**
     * Update user data such as preferred username
     * @summary Update user data properties
     * @param {UserUpdate} body User Update Object
     * @param {string} userId The id of the user
     * @param {string} accessToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(
      body: UserUpdate,
      userId: string,
      accessToken: string,
      options?: any,
    ) {
      return UserApiFp(configuration).updateUser(
        body,
        userId,
        accessToken,
        options,
      )(fetch, basePath);
    },
    /**
     * Used to upload image (like profile) to S3 bucket   If successfully upload image, will return 200 status code and url to  the image. If incorrect userId or image payload provided,  BadRequest error is returned
     * @summary Upload user image
     * @param {UserImageUpload} body User Image Upload Object
     * @param {string} userId The id of the user who uploads the image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadImage(body: UserImageUpload, userId: string, options?: any) {
      return UserApiFp(configuration).uploadImage(
        body,
        userId,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   * Delete user account. This will also delete the user's avatar.
   * @summary Delete user
   * @param {string} userId The user that is to be deleted.  If the user account does not exist, the status code will still return with a &#x27;200&#x27; success.
   * @param {string} accessToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public deleteUser(userId: string, accessToken: string, options?: any) {
    return UserApiFp(this.configuration).deleteUser(
      userId,
      accessToken,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUser(options?: any) {
    return UserApiFp(this.configuration).getUser(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Update user data such as preferred username
   * @summary Update user data properties
   * @param {UserUpdate} body User Update Object
   * @param {string} userId The id of the user
   * @param {string} accessToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public updateUser(
    body: UserUpdate,
    userId: string,
    accessToken: string,
    options?: any,
  ) {
    return UserApiFp(this.configuration).updateUser(
      body,
      userId,
      accessToken,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Used to upload image (like profile) to S3 bucket   If successfully upload image, will return 200 status code and url to  the image. If incorrect userId or image payload provided,  BadRequest error is returned
   * @summary Upload user image
   * @param {UserImageUpload} body User Image Upload Object
   * @param {string} userId The id of the user who uploads the image
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public uploadImage(body: UserImageUpload, userId: string, options?: any) {
    return UserApiFp(this.configuration).uploadImage(
      body,
      userId,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * UserV2Api - fetch parameter creator
 * @export
 */
export const UserV2ApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Request for tag, leaderboard entered top 100 for any tag, follows with one paginator. (uses shim domain, api.{env}.genies)
     * @summary Get user social activity
     * @param {string} userId The id of the user
     * @param {number} startTime The start time in epoch of the range to view the list of interactions (inclusive).
     * @param {number} endTime The end time in epoch of the range to view the list of interactions (inclusive).
     * @param {number} limit The size of the interactions to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserActivtyV2(
      userId: string,
      startTime: number,
      endTime: number,
      limit: number,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getUserActivtyV2.',
        );
      }
      // verify required parameter 'startTime' is not null or undefined
      if (startTime === null || startTime === undefined) {
        throw new RequiredError(
          'startTime',
          'Required parameter startTime was null or undefined when calling getUserActivtyV2.',
        );
      }
      // verify required parameter 'endTime' is not null or undefined
      if (endTime === null || endTime === undefined) {
        throw new RequiredError(
          'endTime',
          'Required parameter endTime was null or undefined when calling getUserActivtyV2.',
        );
      }
      // verify required parameter 'limit' is not null or undefined
      if (limit === null || limit === undefined) {
        throw new RequiredError(
          'limit',
          'Required parameter limit was null or undefined when calling getUserActivtyV2.',
        );
      }
      const localVarPath = `/v2/user/{userId}/activity`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserV2Api - functional programming interface
 * @export
 */
export const UserV2ApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Request for tag, leaderboard entered top 100 for any tag, follows with one paginator. (uses shim domain, api.{env}.genies)
     * @summary Get user social activity
     * @param {string} userId The id of the user
     * @param {number} startTime The start time in epoch of the range to view the list of interactions (inclusive).
     * @param {number} endTime The end time in epoch of the range to view the list of interactions (inclusive).
     * @param {number} limit The size of the interactions to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserActivtyV2(
      userId: string,
      startTime: number,
      endTime: number,
      limit: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ActivityResponseV2> {
      const localVarFetchArgs = UserV2ApiFetchParamCreator(
        configuration,
      ).getUserActivtyV2(userId, startTime, endTime, limit, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * UserV2Api - factory interface
 * @export
 */
export const UserV2ApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Request for tag, leaderboard entered top 100 for any tag, follows with one paginator. (uses shim domain, api.{env}.genies)
     * @summary Get user social activity
     * @param {string} userId The id of the user
     * @param {number} startTime The start time in epoch of the range to view the list of interactions (inclusive).
     * @param {number} endTime The end time in epoch of the range to view the list of interactions (inclusive).
     * @param {number} limit The size of the interactions to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserActivtyV2(
      userId: string,
      startTime: number,
      endTime: number,
      limit: number,
      options?: any,
    ) {
      return UserV2ApiFp(configuration).getUserActivtyV2(
        userId,
        startTime,
        endTime,
        limit,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * UserV2Api - object-oriented interface
 * @export
 * @class UserV2Api
 * @extends {BaseAPI}
 */
export class UserV2Api extends BaseAPI {
  /**
   * Request for tag, leaderboard entered top 100 for any tag, follows with one paginator. (uses shim domain, api.{env}.genies)
   * @summary Get user social activity
   * @param {string} userId The id of the user
   * @param {number} startTime The start time in epoch of the range to view the list of interactions (inclusive).
   * @param {number} endTime The end time in epoch of the range to view the list of interactions (inclusive).
   * @param {number} limit The size of the interactions to fetch.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserV2Api
   */
  public getUserActivtyV2(
    userId: string,
    startTime: number,
    endTime: number,
    limit: number,
    options?: any,
  ) {
    return UserV2ApiFp(this.configuration).getUserActivtyV2(
      userId,
      startTime,
      endTime,
      limit,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * WalletApi - fetch parameter creator
 * @export
 */
export const WalletApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Creates an edition on the blockchain
     * @summary Add an edition
     * @param {AddEditionInput} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addEdition(body: AddEditionInput, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling addEdition.',
        );
      }
      const localVarPath = `/edition`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'AddEditionInput' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a wallet that Genies manages for the user
     * @summary Create a wallet
     * @param {WalletCreate} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWallet(body: WalletCreate, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createWallet.',
        );
      }
      const localVarPath = `/wallet`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'WalletCreate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates an edition on the blockchain
     * @summary Add an edition
     * @param {MintNftInput} body
     * @param {string} wearableId Identifier of wearable to mint (uuid)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintNft(
      body: MintNftInput,
      wearableId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling mintNft.',
        );
      }
      // verify required parameter 'wearableId' is not null or undefined
      if (wearableId === null || wearableId === undefined) {
        throw new RequiredError(
          'wearableId',
          'Required parameter wearableId was null or undefined when calling mintNft.',
        );
      }
      const localVarPath = `/edition/{wearableId}/mint`.replace(
        `{${'wearableId'}}`,
        encodeURIComponent(String(wearableId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'MintNftInput' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Purchases list of Nfts for the user
     * @summary Purchase Nft
     * @param {PurchaseNftInput} body
     * @param {string} userId User sub used that makes the purchase transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchaseNfts(
      body: PurchaseNftInput,
      userId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling purchaseNfts.',
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling purchaseNfts.',
        );
      }
      const localVarPath = `/wallet/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'PurchaseNftInput' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Transfers a list of Nfts for the user
     * @summary Transfer Nft
     * @param {PurchaseNftInput} body
     * @param {string} userId User sub used that makes the purchase transaction
     * @param {string} receiverId User sub used that will get the Nfts on successful transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferNfts(
      body: PurchaseNftInput,
      userId: string,
      receiverId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling transferNfts.',
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling transferNfts.',
        );
      }
      // verify required parameter 'receiverId' is not null or undefined
      if (receiverId === null || receiverId === undefined) {
        throw new RequiredError(
          'receiverId',
          'Required parameter receiverId was null or undefined when calling transferNfts.',
        );
      }
      const localVarPath = `/wallet/{userId}/{receiverId}`
        .replace(`{${'userId'}}`, encodeURIComponent(String(userId)))
        .replace(`{${'receiverId'}}`, encodeURIComponent(String(receiverId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'PurchaseNftInput' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Creates an edition on the blockchain
     * @summary Add an edition
     * @param {AddEditionInput} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addEdition(
      body: AddEditionInput,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<WalletAsyncResponse> {
      const localVarFetchArgs = WalletApiFetchParamCreator(
        configuration,
      ).addEdition(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Creates a wallet that Genies manages for the user
     * @summary Create a wallet
     * @param {WalletCreate} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWallet(
      body: WalletCreate,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<WalletAsyncResponse> {
      const localVarFetchArgs = WalletApiFetchParamCreator(
        configuration,
      ).createWallet(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Creates an edition on the blockchain
     * @summary Add an edition
     * @param {MintNftInput} body
     * @param {string} wearableId Identifier of wearable to mint (uuid)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintNft(
      body: MintNftInput,
      wearableId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<WalletAsyncResponse> {
      const localVarFetchArgs = WalletApiFetchParamCreator(
        configuration,
      ).mintNft(body, wearableId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Purchases list of Nfts for the user
     * @summary Purchase Nft
     * @param {PurchaseNftInput} body
     * @param {string} userId User sub used that makes the purchase transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchaseNfts(
      body: PurchaseNftInput,
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<WalletAsyncResponse> {
      const localVarFetchArgs = WalletApiFetchParamCreator(
        configuration,
      ).purchaseNfts(body, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Transfers a list of Nfts for the user
     * @summary Transfer Nft
     * @param {PurchaseNftInput} body
     * @param {string} userId User sub used that makes the purchase transaction
     * @param {string} receiverId User sub used that will get the Nfts on successful transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferNfts(
      body: PurchaseNftInput,
      userId: string,
      receiverId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<WalletAsyncResponse> {
      const localVarFetchArgs = WalletApiFetchParamCreator(
        configuration,
      ).transferNfts(body, userId, receiverId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Creates an edition on the blockchain
     * @summary Add an edition
     * @param {AddEditionInput} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addEdition(body: AddEditionInput, options?: any) {
      return WalletApiFp(configuration).addEdition(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Creates a wallet that Genies manages for the user
     * @summary Create a wallet
     * @param {WalletCreate} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWallet(body: WalletCreate, options?: any) {
      return WalletApiFp(configuration).createWallet(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Creates an edition on the blockchain
     * @summary Add an edition
     * @param {MintNftInput} body
     * @param {string} wearableId Identifier of wearable to mint (uuid)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintNft(body: MintNftInput, wearableId: string, options?: any) {
      return WalletApiFp(configuration).mintNft(
        body,
        wearableId,
        options,
      )(fetch, basePath);
    },
    /**
     * Purchases list of Nfts for the user
     * @summary Purchase Nft
     * @param {PurchaseNftInput} body
     * @param {string} userId User sub used that makes the purchase transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchaseNfts(body: PurchaseNftInput, userId: string, options?: any) {
      return WalletApiFp(configuration).purchaseNfts(
        body,
        userId,
        options,
      )(fetch, basePath);
    },
    /**
     * Transfers a list of Nfts for the user
     * @summary Transfer Nft
     * @param {PurchaseNftInput} body
     * @param {string} userId User sub used that makes the purchase transaction
     * @param {string} receiverId User sub used that will get the Nfts on successful transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferNfts(
      body: PurchaseNftInput,
      userId: string,
      receiverId: string,
      options?: any,
    ) {
      return WalletApiFp(configuration).transferNfts(
        body,
        userId,
        receiverId,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
  /**
   * Creates an edition on the blockchain
   * @summary Add an edition
   * @param {AddEditionInput} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public addEdition(body: AddEditionInput, options?: any) {
    return WalletApiFp(this.configuration).addEdition(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Creates a wallet that Genies manages for the user
   * @summary Create a wallet
   * @param {WalletCreate} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public createWallet(body: WalletCreate, options?: any) {
    return WalletApiFp(this.configuration).createWallet(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Creates an edition on the blockchain
   * @summary Add an edition
   * @param {MintNftInput} body
   * @param {string} wearableId Identifier of wearable to mint (uuid)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public mintNft(body: MintNftInput, wearableId: string, options?: any) {
    return WalletApiFp(this.configuration).mintNft(
      body,
      wearableId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Purchases list of Nfts for the user
   * @summary Purchase Nft
   * @param {PurchaseNftInput} body
   * @param {string} userId User sub used that makes the purchase transaction
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public purchaseNfts(body: PurchaseNftInput, userId: string, options?: any) {
    return WalletApiFp(this.configuration).purchaseNfts(
      body,
      userId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Transfers a list of Nfts for the user
   * @summary Transfer Nft
   * @param {PurchaseNftInput} body
   * @param {string} userId User sub used that makes the purchase transaction
   * @param {string} receiverId User sub used that will get the Nfts on successful transaction
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public transferNfts(
    body: PurchaseNftInput,
    userId: string,
    receiverId: string,
    options?: any,
  ) {
    return WalletApiFp(this.configuration).transferNfts(
      body,
      userId,
      receiverId,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * WalletUserApi - fetch parameter creator
 * @export
 */
export const WalletUserApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create user payment
     * @param {string} userId The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserPayment(userId: string, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling createUserPayment.',
        );
      }
      const localVarPath = `/user/{userId}/payment`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete wallet data for a user
     * @param {string} userId The id of the user
     * @param {string} walletId The id of the wallet to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserWallet(
      userId: string,
      walletId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling deleteUserWallet.',
        );
      }
      // verify required parameter 'walletId' is not null or undefined
      if (walletId === null || walletId === undefined) {
        throw new RequiredError(
          'walletId',
          'Required parameter walletId was null or undefined when calling deleteUserWallet.',
        );
      }
      const localVarPath = `/user/{userId}/{walletId}`
        .replace(`{${'userId'}}`, encodeURIComponent(String(userId)))
        .replace(`{${'walletId'}}`, encodeURIComponent(String(walletId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user payment
     * @param {string} userId The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserPayment(userId: string, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getUserPayment.',
        );
      }
      const localVarPath = `/user/{userId}/payment`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get wallet data for a user
     * @param {string} userId The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserWallet(userId: string, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getUserWallet.',
        );
      }
      const localVarPath = `/user/{userId}/wallet`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WalletUserApi - functional programming interface
 * @export
 */
export const WalletUserApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create user payment
     * @param {string} userId The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserPayment(
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = WalletUserApiFetchParamCreator(
        configuration,
      ).createUserPayment(userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Delete wallet data for a user
     * @param {string} userId The id of the user
     * @param {string} walletId The id of the wallet to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserWallet(
      userId: string,
      walletId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<WalletDeleteResponse> {
      const localVarFetchArgs = WalletUserApiFetchParamCreator(
        configuration,
      ).deleteUserWallet(userId, walletId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get user payment
     * @param {string} userId The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserPayment(
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<WalletPaymentData> {
      const localVarFetchArgs = WalletUserApiFetchParamCreator(
        configuration,
      ).getUserPayment(userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get wallet data for a user
     * @param {string} userId The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserWallet(
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<WalletUserData> {
      const localVarFetchArgs = WalletUserApiFetchParamCreator(
        configuration,
      ).getUserWallet(userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * WalletUserApi - factory interface
 * @export
 */
export const WalletUserApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Create user payment
     * @param {string} userId The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserPayment(userId: string, options?: any) {
      return WalletUserApiFp(configuration).createUserPayment(userId, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Delete wallet data for a user
     * @param {string} userId The id of the user
     * @param {string} walletId The id of the wallet to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserWallet(userId: string, walletId: string, options?: any) {
      return WalletUserApiFp(configuration).deleteUserWallet(
        userId,
        walletId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get user payment
     * @param {string} userId The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserPayment(userId: string, options?: any) {
      return WalletUserApiFp(configuration).getUserPayment(userId, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Get wallet data for a user
     * @param {string} userId The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserWallet(userId: string, options?: any) {
      return WalletUserApiFp(configuration).getUserWallet(userId, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * WalletUserApi - object-oriented interface
 * @export
 * @class WalletUserApi
 * @extends {BaseAPI}
 */
export class WalletUserApi extends BaseAPI {
  /**
   *
   * @summary Create user payment
   * @param {string} userId The id of the user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletUserApi
   */
  public createUserPayment(userId: string, options?: any) {
    return WalletUserApiFp(this.configuration).createUserPayment(
      userId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Delete wallet data for a user
   * @param {string} userId The id of the user
   * @param {string} walletId The id of the wallet to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletUserApi
   */
  public deleteUserWallet(userId: string, walletId: string, options?: any) {
    return WalletUserApiFp(this.configuration).deleteUserWallet(
      userId,
      walletId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get user payment
   * @param {string} userId The id of the user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletUserApi
   */
  public getUserPayment(userId: string, options?: any) {
    return WalletUserApiFp(this.configuration).getUserPayment(userId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Get wallet data for a user
   * @param {string} userId The id of the user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletUserApi
   */
  public getUserWallet(userId: string, options?: any) {
    return WalletUserApiFp(this.configuration).getUserWallet(userId, options)(
      this.fetch,
      this.basePath,
    );
  }
}
/**
 * WearableApi - fetch parameter creator
 * @export
 */
export const WearableApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns a boolean (uses shim domain, api.{env}.genies)
     * @summary Check if a wearable can be thrifted by current user based on certain conditions.
     * @param {string} fullAssetName The full asset name of the wearable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkIfWearableCanBeThrifted(
      fullAssetName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'fullAssetName' is not null or undefined
      if (fullAssetName === null || fullAssetName === undefined) {
        throw new RequiredError(
          'fullAssetName',
          'Required parameter fullAssetName was null or undefined when calling checkIfWearableCanBeThrifted.',
        );
      }
      const localVarPath = `/wearable/{fullAssetName}/thriftable`.replace(
        `{${'fullAssetName'}}`,
        encodeURIComponent(String(fullAssetName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the created wearable metadata (uses composer-api domain)
     * @summary Create a wearable
     * @param {WearableCreate} body Wearable Create object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWearable(body: WearableCreate, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createWearable.',
        );
      }
      const localVarPath = `/wearable`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'WearableCreate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of wearable metadata for a user's thrift shop (uses shim domain, api.{env}.genies)
     * @summary Get a list of wearables for a user's thrift shop
     * @param {string} userId User sub to get their thrift shop
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWearables(userId: string, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getWearables.',
        );
      }
      const localVarPath = `/wearable/thrift`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of wearables
     * @summary Find wearables by the wearable unique id.
     * @param {Array<string>} wearableIds wearableId of wearables, only the uuid part after skin_ &#x27;jacket-0010-puffy_skin_8005bd8b-d57c-435a-93ad-82c9b98335f3&#x27;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWearablesById(wearableIds: Array<string>, options: any = {}): FetchArgs {
      // verify required parameter 'wearableIds' is not null or undefined
      if (wearableIds === null || wearableIds === undefined) {
        throw new RequiredError(
          'wearableIds',
          'Required parameter wearableIds was null or undefined when calling getWearablesById.',
        );
      }
      const localVarPath = `/wearable/{wearableIds*}`.replace(
        `{${'wearableIds*'}}`,
        encodeURIComponent(String(wearableIds)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update some properties of wearables. (uses shim domain, api.{env}.genies)
     * @summary Update a wearable
     * @param {WearableUpdateList} body Wearable Update object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWearable(body: WearableUpdateList, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateWearable.',
        );
      }
      const localVarPath = `/wearable`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-api-key')
            : configuration.apiKey;
        localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
      }

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'WearableUpdateList' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WearableApi - functional programming interface
 * @export
 */
export const WearableApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Returns a boolean (uses shim domain, api.{env}.genies)
     * @summary Check if a wearable can be thrifted by current user based on certain conditions.
     * @param {string} fullAssetName The full asset name of the wearable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkIfWearableCanBeThrifted(
      fullAssetName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
      const localVarFetchArgs = WearableApiFetchParamCreator(
        configuration,
      ).checkIfWearableCanBeThrifted(fullAssetName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns the created wearable metadata (uses composer-api domain)
     * @summary Create a wearable
     * @param {WearableCreate} body Wearable Create object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWearable(
      body: WearableCreate,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Wearable> {
      const localVarFetchArgs = WearableApiFetchParamCreator(
        configuration,
      ).createWearable(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of wearable metadata for a user's thrift shop (uses shim domain, api.{env}.genies)
     * @summary Get a list of wearables for a user's thrift shop
     * @param {string} userId User sub to get their thrift shop
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWearables(
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<WearableThriftList> {
      const localVarFetchArgs = WearableApiFetchParamCreator(
        configuration,
      ).getWearables(userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of wearables
     * @summary Find wearables by the wearable unique id.
     * @param {Array<string>} wearableIds wearableId of wearables, only the uuid part after skin_ &#x27;jacket-0010-puffy_skin_8005bd8b-d57c-435a-93ad-82c9b98335f3&#x27;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWearablesById(
      wearableIds: Array<string>,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Wearable>> {
      const localVarFetchArgs = WearableApiFetchParamCreator(
        configuration,
      ).getWearablesById(wearableIds, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update some properties of wearables. (uses shim domain, api.{env}.genies)
     * @summary Update a wearable
     * @param {WearableUpdateList} body Wearable Update object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWearable(
      body: WearableUpdateList,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<WearableList> {
      const localVarFetchArgs = WearableApiFetchParamCreator(
        configuration,
      ).updateWearable(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * WearableApi - factory interface
 * @export
 */
export const WearableApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Returns a boolean (uses shim domain, api.{env}.genies)
     * @summary Check if a wearable can be thrifted by current user based on certain conditions.
     * @param {string} fullAssetName The full asset name of the wearable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkIfWearableCanBeThrifted(fullAssetName: string, options?: any) {
      return WearableApiFp(configuration).checkIfWearableCanBeThrifted(
        fullAssetName,
        options,
      )(fetch, basePath);
    },
    /**
     * Returns the created wearable metadata (uses composer-api domain)
     * @summary Create a wearable
     * @param {WearableCreate} body Wearable Create object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWearable(body: WearableCreate, options?: any) {
      return WearableApiFp(configuration).createWearable(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Returns a list of wearable metadata for a user's thrift shop (uses shim domain, api.{env}.genies)
     * @summary Get a list of wearables for a user's thrift shop
     * @param {string} userId User sub to get their thrift shop
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWearables(userId: string, options?: any) {
      return WearableApiFp(configuration).getWearables(userId, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Returns a list of wearables
     * @summary Find wearables by the wearable unique id.
     * @param {Array<string>} wearableIds wearableId of wearables, only the uuid part after skin_ &#x27;jacket-0010-puffy_skin_8005bd8b-d57c-435a-93ad-82c9b98335f3&#x27;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWearablesById(wearableIds: Array<string>, options?: any) {
      return WearableApiFp(configuration).getWearablesById(
        wearableIds,
        options,
      )(fetch, basePath);
    },
    /**
     * Update some properties of wearables. (uses shim domain, api.{env}.genies)
     * @summary Update a wearable
     * @param {WearableUpdateList} body Wearable Update object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWearable(body: WearableUpdateList, options?: any) {
      return WearableApiFp(configuration).updateWearable(body, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * WearableApi - object-oriented interface
 * @export
 * @class WearableApi
 * @extends {BaseAPI}
 */
export class WearableApi extends BaseAPI {
  /**
   * Returns a boolean (uses shim domain, api.{env}.genies)
   * @summary Check if a wearable can be thrifted by current user based on certain conditions.
   * @param {string} fullAssetName The full asset name of the wearable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WearableApi
   */
  public checkIfWearableCanBeThrifted(fullAssetName: string, options?: any) {
    return WearableApiFp(this.configuration).checkIfWearableCanBeThrifted(
      fullAssetName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Returns the created wearable metadata (uses composer-api domain)
   * @summary Create a wearable
   * @param {WearableCreate} body Wearable Create object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WearableApi
   */
  public createWearable(body: WearableCreate, options?: any) {
    return WearableApiFp(this.configuration).createWearable(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Returns a list of wearable metadata for a user's thrift shop (uses shim domain, api.{env}.genies)
   * @summary Get a list of wearables for a user's thrift shop
   * @param {string} userId User sub to get their thrift shop
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WearableApi
   */
  public getWearables(userId: string, options?: any) {
    return WearableApiFp(this.configuration).getWearables(userId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Returns a list of wearables
   * @summary Find wearables by the wearable unique id.
   * @param {Array<string>} wearableIds wearableId of wearables, only the uuid part after skin_ &#x27;jacket-0010-puffy_skin_8005bd8b-d57c-435a-93ad-82c9b98335f3&#x27;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WearableApi
   */
  public getWearablesById(wearableIds: Array<string>, options?: any) {
    return WearableApiFp(this.configuration).getWearablesById(
      wearableIds,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Update some properties of wearables. (uses shim domain, api.{env}.genies)
   * @summary Update a wearable
   * @param {WearableUpdateList} body Wearable Update object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WearableApi
   */
  public updateWearable(body: WearableUpdateList, options?: any) {
    return WearableApiFp(this.configuration).updateWearable(body, options)(
      this.fetch,
      this.basePath,
    );
  }
}
