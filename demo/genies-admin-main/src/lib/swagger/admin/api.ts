/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Genies Admin API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.41
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://virtserver.swaggerhub.com/Genies/Admin/1.0.41".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * Represents the new product to create
 * @export
 * @interface AddHardCurrencyProductBody
 */
export interface AddHardCurrencyProductBody {
    /**
     * product sku 
     * @type {string}
     * @memberof AddHardCurrencyProductBody
     */
    productSku: string;
    /**
     * amount of hard currency reward 
     * @type {number}
     * @memberof AddHardCurrencyProductBody
     */
    amount: number;
    /**
     * if the product is active or not 
     * @type {boolean}
     * @memberof AddHardCurrencyProductBody
     */
    isActive?: boolean;
}
/**
 * 
 * @export
 * @interface AddHardCurrencyProductResponse
 */
export interface AddHardCurrencyProductResponse {
    /**
     * 
     * @type {string}
     * @memberof AddHardCurrencyProductResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof AddHardCurrencyProductResponse
     */
    productSku?: string;
    /**
     * 
     * @type {number}
     * @memberof AddHardCurrencyProductResponse
     */
    amount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AddHardCurrencyProductResponse
     */
    isActive?: boolean;
}
/**
 * 
 * @export
 * @interface AddSoftCurrencyProductRequest
 */
export interface AddSoftCurrencyProductRequest {
    /**
     * 
     * @type {string}
     * @memberof AddSoftCurrencyProductRequest
     */
    currencyId?: string;
    /**
     * 
     * @type {string}
     * @memberof AddSoftCurrencyProductRequest
     */
    productSku?: string;
    /**
     * 
     * @type {number}
     * @memberof AddSoftCurrencyProductRequest
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof AddSoftCurrencyProductRequest
     */
    hcCost?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AddSoftCurrencyProductRequest
     */
    isActive?: boolean;
    /**
     * 
     * @type {SoftCurrencyProductMetadata}
     * @memberof AddSoftCurrencyProductRequest
     */
    metadata?: SoftCurrencyProductMetadata;
}
/**
 * 
 * @export
 * @interface AddSoftCurrencyProductResponse
 */
export interface AddSoftCurrencyProductResponse {
    /**
     * 
     * @type {string}
     * @memberof AddSoftCurrencyProductResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof AddSoftCurrencyProductResponse
     */
    currencyId?: string;
    /**
     * 
     * @type {string}
     * @memberof AddSoftCurrencyProductResponse
     */
    productSku?: string;
    /**
     * 
     * @type {number}
     * @memberof AddSoftCurrencyProductResponse
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof AddSoftCurrencyProductResponse
     */
    hcCost?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AddSoftCurrencyProductResponse
     */
    isActive?: boolean;
}
/**
 * 
 * @export
 * @interface AdminCloudSaveCreateRequest
 */
export interface AdminCloudSaveCreateRequest {
    /**
     * id of the user that the admin wants to create cloud save for
     * @type {string}
     * @memberof AdminCloudSaveCreateRequest
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof AdminCloudSaveCreateRequest
     */
    instanceId: string;
    /**
     * 
     * @type {string}
     * @memberof AdminCloudSaveCreateRequest
     */
    data: string;
    /**
     * Optional param. If the public is true, the data is shared in the experience. If the public is false, the data is only accessible with the personal access token.
     * @type {boolean}
     * @memberof AdminCloudSaveCreateRequest
     */
    _public?: boolean;
}
/**
 * 
 * @export
 * @interface AdminCloudSaveUpdateRequest
 */
export interface AdminCloudSaveUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AdminCloudSaveUpdateRequest
     */
    cloudSaveUpdates: string;
    /**
     * 
     * @type {string}
     * @memberof AdminCloudSaveUpdateRequest
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface AdminGetTraitStatusResponse
 */
export interface AdminGetTraitStatusResponse {
    /**
     * 
     * @type {Array<MaxCountStatus>}
     * @memberof AdminGetTraitStatusResponse
     */
    maxCounts?: Array<MaxCountStatus>;
    /**
     * 
     * @type {Array<Decay>}
     * @memberof AdminGetTraitStatusResponse
     */
    decay?: Array<Decay>;
}
/**
 * 
 * @export
 * @interface AdminSetTraitScoreRequest
 */
export interface AdminSetTraitScoreRequest {
    /**
     * 
     * @type {string}
     * @memberof AdminSetTraitScoreRequest
     */
    traitId?: string;
    /**
     * 
     * @type {number}
     * @memberof AdminSetTraitScoreRequest
     */
    score?: number;
}
/**
 * 
 * @export
 * @interface AnimationLibraryAsset
 */
export interface AnimationLibraryAsset extends VersionableInventoryAsset {
    /**
     * Animation category
     * @type {string}
     * @memberof AnimationLibraryAsset
     */
    category?: string;
    /**
     * Mood tag for filtering animations by emotional context
     * @type {string}
     * @memberof AnimationLibraryAsset
     */
    moodsTag?: string;
    /**
     * Protocol tags for animation compatibility and usage
     * @type {Array<string>}
     * @memberof AnimationLibraryAsset
     */
    protocolTags?: Array<string>;
}
/**
 * 
 * @export
 * @interface AnimationLibraryAssetInstance
 */
export interface AnimationLibraryAssetInstance extends BaseInventoryAssetInstance {
    /**
     * 
     * @type {AnimationLibraryAsset}
     * @memberof AnimationLibraryAssetInstance
     */
    asset?: AnimationLibraryAsset;
}
/**
 * Lifecycle status of an asset
 * @export
 * @enum {string}
 */
export enum AssetLifecycleStatus {
    Sandbox = <any> 'sandbox',
    Inactive = <any> 'inactive',
    Active = <any> 'active'
}
/**
 * Moderation information for a specific asset
 * @export
 * @interface AssetModerationDetailResponse
 */
export interface AssetModerationDetailResponse extends AssetModerationInfo {
}

/**
 * @export
 * @namespace AssetModerationDetailResponse
 */
export namespace AssetModerationDetailResponse {
}
/**
 * 
 * @export
 * @interface AssetModerationInfo
 */
export interface AssetModerationInfo {
    /**
     * 
     * @type {string}
     * @memberof AssetModerationInfo
     */
    assetId?: string;
    /**
     * Type of the asset
     * @type {string}
     * @memberof AssetModerationInfo
     */
    assetType?: AssetModerationInfo.AssetTypeEnum;
    /**
     * Asset name (from tag_name namespace)
     * @type {string}
     * @memberof AssetModerationInfo
     */
    name?: string;
    /**
     * Asset description (from tag_description namespace)
     * @type {string}
     * @memberof AssetModerationInfo
     */
    description?: string;
    /**
     * Asset category (from tag_category namespace)
     * @type {string}
     * @memberof AssetModerationInfo
     */
    category?: string;
    /**
     * Asset subcategories (from tag_subcategories namespace)
     * @type {Array<string>}
     * @memberof AssetModerationInfo
     */
    subcategories?: Array<string>;
    /**
     * Asset origin type (e.g., UGC, AIGC, System)
     * @type {string}
     * @memberof AssetModerationInfo
     */
    origin?: AssetModerationInfo.OriginEnum;
    /**
     * 
     * @type {string}
     * @memberof AssetModerationInfo
     */
    creatorId?: string;
    /**
     * 
     * @type {ModerationStatus}
     * @memberof AssetModerationInfo
     */
    moderationStatus?: ModerationStatus;
    /**
     * 
     * @type {ModerationType}
     * @memberof AssetModerationInfo
     */
    moderationType?: ModerationType;
    /**
     * 
     * @type {string}
     * @memberof AssetModerationInfo
     */
    reviewerUserId?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetModerationInfo
     */
    reviewNotes?: string;
    /**
     * Unix timestamp of submission
     * @type {number}
     * @memberof AssetModerationInfo
     */
    submittedAt?: number;
    /**
     * Unix timestamp of review
     * @type {number}
     * @memberof AssetModerationInfo
     */
    reviewedAt?: number;
    /**
     * URL to the asset file (from tag_assetUrl namespace)
     * @type {string}
     * @memberof AssetModerationInfo
     */
    assetUrl?: string;
    /**
     * Organization ID (from tag_defaultCloset namespace, if asset is a default item)
     * @type {string}
     * @memberof AssetModerationInfo
     */
    orgId?: string;
    /**
     * Application ID (from tag_defaultCloset namespace, if asset is a default item)
     * @type {string}
     * @memberof AssetModerationInfo
     */
    appId?: string;
    /**
     * Whether this is a default/system item (from tag_defaultCloset namespace)
     * @type {boolean}
     * @memberof AssetModerationInfo
     */
    isDefault?: boolean;
}

/**
 * @export
 * @namespace AssetModerationInfo
 */
export namespace AssetModerationInfo {
    /**
     * @export
     * @enum {string}
     */
    export enum AssetTypeEnum {
        WardrobeGear = <any> 'WardrobeGear',
        ModelLibrary = <any> 'ModelLibrary',
        UserAvatar = <any> 'UserAvatar',
        AvatarBase = <any> 'AvatarBase',
        Makeup = <any> 'Makeup',
        Flair = <any> 'Flair',
        Eyes = <any> 'Eyes',
        ColorPreset = <any> 'ColorPreset',
        ImageLibrary = <any> 'ImageLibrary',
        AnimationLibrary = <any> 'AnimationLibrary'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OriginEnum {
        UGC = <any> 'UGC',
        AIGC = <any> 'AIGC',
        System = <any> 'System'
    }
}
/**
 * 
 * @export
 * @interface AvatarBaseAsset
 */
export interface AvatarBaseAsset extends BaseInventoryAsset {
}

/**
 * @export
 * @namespace AvatarBaseAsset
 */
export namespace AvatarBaseAsset {
}
/**
 * 
 * @export
 * @interface AvatarBaseAssetInstance
 */
export interface AvatarBaseAssetInstance extends BaseInventoryAssetInstance {
    /**
     * 
     * @type {AvatarBaseAsset}
     * @memberof AvatarBaseAssetInstance
     */
    asset?: AvatarBaseAsset;
}
/**
 * Base properties for all V2 inventory assets
 * @export
 * @interface BaseInventoryAsset
 */
export interface BaseInventoryAsset {
    /**
     * Unique identifier for the asset type
     * @type {string}
     * @memberof BaseInventoryAsset
     */
    assetId?: string;
    /**
     * Type of the asset
     * @type {string}
     * @memberof BaseInventoryAsset
     */
    assetType?: BaseInventoryAsset.AssetTypeEnum;
    /**
     * Display name of the asset
     * @type {string}
     * @memberof BaseInventoryAsset
     */
    name?: string;
    /**
     * Short description of the asset
     * @type {string}
     * @memberof BaseInventoryAsset
     */
    description?: string;
    /**
     * Detailed description of the asset
     * @type {string}
     * @memberof BaseInventoryAsset
     */
    longDescription?: string;
    /**
     * Organization ID
     * @type {string}
     * @memberof BaseInventoryAsset
     */
    orgId?: string;
    /**
     * Application ID
     * @type {string}
     * @memberof BaseInventoryAsset
     */
    appId?: string;
    /**
     * Creator of the asset
     * @type {string}
     * @memberof BaseInventoryAsset
     */
    creator?: string;
    /**
     * Origin tag for filtering (e.g., \"genies\", \"third-party\")
     * @type {string}
     * @memberof BaseInventoryAsset
     */
    origin?: string;
}

/**
 * @export
 * @namespace BaseInventoryAsset
 */
export namespace BaseInventoryAsset {
    /**
     * @export
     * @enum {string}
     */
    export enum AssetTypeEnum {
        WardrobeGear = <any> 'WardrobeGear',
        ModelLibrary = <any> 'ModelLibrary',
        UserAvatar = <any> 'UserAvatar',
        AvatarBase = <any> 'AvatarBase',
        Makeup = <any> 'Makeup',
        Flair = <any> 'Flair',
        Eyes = <any> 'Eyes',
        ColorPreset = <any> 'ColorPreset',
        ImageLibrary = <any> 'ImageLibrary',
        AnimationLibrary = <any> 'AnimationLibrary'
    }
}
/**
 * Base properties for all V2 inventory asset instances
 * @export
 * @interface BaseInventoryAssetInstance
 */
export interface BaseInventoryAssetInstance {
    /**
     * Unique identifier for this asset instance
     * @type {string}
     * @memberof BaseInventoryAssetInstance
     */
    assetInstanceId?: string;
    /**
     * Owner of the asset instance
     * @type {string}
     * @memberof BaseInventoryAssetInstance
     */
    owner?: string;
    /**
     * Unix timestamp when the instance was created
     * @type {number}
     * @memberof BaseInventoryAssetInstance
     */
    dateCreated?: number;
}
/**
 * 
 * @export
 * @interface CloudSaveCreateRequest
 */
export interface CloudSaveCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof CloudSaveCreateRequest
     */
    instanceId: string;
    /**
     * 
     * @type {string}
     * @memberof CloudSaveCreateRequest
     */
    data: string;
    /**
     * Optional param. If the public is true, the data is shared in the experience. If the public is false, the data is only accessible with the personal access token.
     * @type {boolean}
     * @memberof CloudSaveCreateRequest
     */
    _public?: boolean;
}
/**
 * 
 * @export
 * @interface CloudSaveGetResponse
 */
export interface CloudSaveGetResponse {
    /**
     * 
     * @type {string}
     * @memberof CloudSaveGetResponse
     */
    experienceId?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudSaveGetResponse
     */
    instanceId?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudSaveGetResponse
     */
    data?: string;
}
/**
 * 
 * @export
 * @interface CloudSaveUpdateRequest
 */
export interface CloudSaveUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof CloudSaveUpdateRequest
     */
    cloudSaveUpdates: string;
}
/**
 * 
 * @export
 * @interface CloudSaveUpdateResponse
 */
export interface CloudSaveUpdateResponse {
    /**
     * 
     * @type {string}
     * @memberof CloudSaveUpdateResponse
     */
    experienceId?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudSaveUpdateResponse
     */
    instanceId?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudSaveUpdateResponse
     */
    data?: string;
}
/**
 * Hex color representation
 * @export
 * @interface ColorHex
 */
export interface ColorHex {
    /**
     * Hexadecimal color code
     * @type {string}
     * @memberof ColorHex
     */
    hex?: string;
}
/**
 * 
 * @export
 * @interface ColorPresetAsset
 */
export interface ColorPresetAsset extends BaseInventoryAsset {
    /**
     * Hexadecimal color codes in the preset palette
     * @type {Array<string>}
     * @memberof ColorPresetAsset
     */
    colorsHex?: Array<string>;
}

/**
 * @export
 * @namespace ColorPresetAsset
 */
export namespace ColorPresetAsset {
}
/**
 * 
 * @export
 * @interface ColorPresetAssetInstance
 */
export interface ColorPresetAssetInstance extends BaseInventoryAssetInstance {
    /**
     * 
     * @type {ColorPresetAsset}
     * @memberof ColorPresetAssetInstance
     */
    asset?: ColorPresetAsset;
}
/**
 * 
 * @export
 * @interface CreateAssetSupplyRequest
 */
export interface CreateAssetSupplyRequest {
    /**
     * Unique identifier for the asset
     * @type {string}
     * @memberof CreateAssetSupplyRequest
     */
    assetId: string;
    /**
     * Type of the asset
     * @type {string}
     * @memberof CreateAssetSupplyRequest
     */
    assetType: string;
    /**
     * userid who created the asset
     * @type {string}
     * @memberof CreateAssetSupplyRequest
     */
    creatorId: string;
    /**
     * id of the party where asset is created
     * @type {string}
     * @memberof CreateAssetSupplyRequest
     */
    partyId?: string;
    /**
     * id of the experience where asset is created
     * @type {string}
     * @memberof CreateAssetSupplyRequest
     */
    experienceId?: string;
    /**
     * maximum amount of supply (defaults to int.max)
     * @type {number}
     * @memberof CreateAssetSupplyRequest
     */
    maximumSupply?: number;
    /**
     * available amount of supply (defaults to int.max)
     * @type {number}
     * @memberof CreateAssetSupplyRequest
     */
    availableSupply?: number;
}
/**
 * 
 * @export
 * @interface CreateAssetSupplyResponse
 */
export interface CreateAssetSupplyResponse {
    /**
     * Unique identifier for the created asset
     * @type {string}
     * @memberof CreateAssetSupplyResponse
     */
    assetId?: string;
    /**
     * Whether the creation was successful
     * @type {boolean}
     * @memberof CreateAssetSupplyResponse
     */
    success?: boolean;
}
/**
 * Request body for creating a new custom color preset
 * @export
 * @interface CreateCustomColorRequest
 */
export interface CreateCustomColorRequest {
    /**
     * Category of the custom color (hair, skin, or flair)
     * @type {string}
     * @memberof CreateCustomColorRequest
     */
    category: CreateCustomColorRequest.CategoryEnum;
    /**
     * Array of hex color values (supports multiple colors for hair)
     * @type {Array<string>}
     * @memberof CreateCustomColorRequest
     */
    colorsHex: Array<string>;
    /**
     * Optional display name for the custom color
     * @type {string}
     * @memberof CreateCustomColorRequest
     */
    name?: string;
    /**
     * Application ID for app-specific colors
     * @type {string}
     * @memberof CreateCustomColorRequest
     */
    appId: string;
    /**
     * Organization ID
     * @type {string}
     * @memberof CreateCustomColorRequest
     */
    orgId: string;
}

/**
 * @export
 * @namespace CreateCustomColorRequest
 */
export namespace CreateCustomColorRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryEnum {
        Hair = <any> 'hair',
        Skin = <any> 'skin',
        Flair = <any> 'flair'
    }
}
/**
 * 
 * @export
 * @interface CreateDefaultClosetNamespaceResponse
 */
export interface CreateDefaultClosetNamespaceResponse {
    /**
     * The namespace of the created store
     * @type {string}
     * @memberof CreateDefaultClosetNamespaceResponse
     */
    namespace?: string;
    /**
     * List of indexed field names for filtering default items
     * @type {Array<string>}
     * @memberof CreateDefaultClosetNamespaceResponse
     */
    indexedFields?: Array<string>;
    /**
     * Success or info message
     * @type {string}
     * @memberof CreateDefaultClosetNamespaceResponse
     */
    message?: string;
    /**
     * Whether the namespace already existed
     * @type {boolean}
     * @memberof CreateDefaultClosetNamespaceResponse
     */
    alreadyExists?: boolean;
    /**
     * Additional information about metadata retrieval
     * @type {string}
     * @memberof CreateDefaultClosetNamespaceResponse
     */
    note?: string;
}
/**
 * 
 * @export
 * @interface CreateDefaultItemRequest
 */
export interface CreateDefaultItemRequest {
    /**
     * ID of the asset to create as a default item
     * @type {string}
     * @memberof CreateDefaultItemRequest
     */
    assetId: string;
    /**
     * Type of the asset (must match internal backend format)
     * @type {string}
     * @memberof CreateDefaultItemRequest
     */
    assetType: CreateDefaultItemRequest.AssetTypeEnum;
    /**
     * Organization ID for the default item (use \"ALL\" for global)
     * @type {string}
     * @memberof CreateDefaultItemRequest
     */
    orgId: string;
    /**
     * Application ID for the default item (use \"ALL\" for all apps)
     * @type {string}
     * @memberof CreateDefaultItemRequest
     */
    appId: string;
}

/**
 * @export
 * @namespace CreateDefaultItemRequest
 */
export namespace CreateDefaultItemRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum AssetTypeEnum {
        WardrobeGear = <any> 'WardrobeGear',
        AvatarBase = <any> 'AvatarBase',
        AvatarMakeup = <any> 'AvatarMakeup',
        AvatarEyes = <any> 'AvatarEyes',
        Flair = <any> 'Flair',
        ModelLibrary = <any> 'ModelLibrary',
        ColorPreset = <any> 'ColorPreset',
        ImageLibrary = <any> 'ImageLibrary',
        AnimationLibrary = <any> 'AnimationLibrary'
    }
}
/**
 * 
 * @export
 * @interface CreateDefaultItemResponse
 */
export interface CreateDefaultItemResponse {
    /**
     * ID of the created asset
     * @type {string}
     * @memberof CreateDefaultItemResponse
     */
    assetId?: string;
    /**
     * Type of the asset
     * @type {string}
     * @memberof CreateDefaultItemResponse
     */
    assetType?: string;
    /**
     * The metadata store key used for tagging (tag_defaultCloset)
     * @type {string}
     * @memberof CreateDefaultItemResponse
     */
    metadataStoreKey?: string;
    /**
     * Organization ID (or \"ALL\" for global defaults)
     * @type {string}
     * @memberof CreateDefaultItemResponse
     */
    orgId?: string;
    /**
     * Application ID (or \"ALL\" for all apps)
     * @type {string}
     * @memberof CreateDefaultItemResponse
     */
    appId?: string;
    /**
     * Success message
     * @type {string}
     * @memberof CreateDefaultItemResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface CreateMetadataStoreRequest
 */
export interface CreateMetadataStoreRequest {
    /**
     * 
     * @type {Array<InventoryIndexedField>}
     * @memberof CreateMetadataStoreRequest
     */
    fields?: Array<InventoryIndexedField>;
}
/**
 * 
 * @export
 * @interface CreateMetadataStoreResponse
 */
export interface CreateMetadataStoreResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateMetadataStoreResponse
     */
    metadataStoreKey?: string;
}
/**
 * 
 * @export
 * @interface Currency
 */
export interface Currency {
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    currencyId?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    currencyName?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    ownerId?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    ownerType?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    currencyType?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    currencyIconUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    updatedAt?: string;
}
/**
 * Represents a single custom color preset
 * @export
 * @interface CustomColorResponse
 */
export interface CustomColorResponse {
    /**
     * Unique ID of the custom color instance
     * @type {string}
     * @memberof CustomColorResponse
     */
    instanceId?: string;
    /**
     * Base asset ID (e.g., custom-hair-color-base)
     * @type {string}
     * @memberof CustomColorResponse
     */
    assetId?: string;
    /**
     * Category of the custom color
     * @type {string}
     * @memberof CustomColorResponse
     */
    category?: string;
    /**
     * Array of hex color values
     * @type {Array<string>}
     * @memberof CustomColorResponse
     */
    colorsHex?: Array<string>;
    /**
     * Display name of the custom color
     * @type {string}
     * @memberof CustomColorResponse
     */
    name?: string;
    /**
     * Application ID
     * @type {string}
     * @memberof CustomColorResponse
     */
    appId?: string;
    /**
     * Organization ID
     * @type {string}
     * @memberof CustomColorResponse
     */
    orgId?: string;
    /**
     * User ID who owns the custom color
     * @type {string}
     * @memberof CustomColorResponse
     */
    ownerId?: string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof CustomColorResponse
     */
    dateCreated?: string;
}
/**
 * 
 * @export
 * @interface Decay
 */
export interface Decay {
    /**
     * 
     * @type {string}
     * @memberof Decay
     */
    traitId?: string;
    /**
     * 
     * @type {number}
     * @memberof Decay
     */
    expiresAt?: number;
}
/**
 * 
 * @export
 * @interface DecorInventoryAsset
 */
export interface DecorInventoryAsset extends VersionableInventoryAsset {
    /**
     * Available colors for this decor item
     * @type {Array<ColorHex>}
     * @memberof DecorInventoryAsset
     */
    colors?: Array<ColorHex>;
    /**
     * Decor category (always \"decor\" for items from this endpoint)
     * @type {string}
     * @memberof DecorInventoryAsset
     */
    category?: string;
    /**
     * Decor subcategories
     * @type {Array<string>}
     * @memberof DecorInventoryAsset
     */
    subcategories?: Array<string>;
}
/**
 * 
 * @export
 * @interface DecorInventoryAssetInstance
 */
export interface DecorInventoryAssetInstance extends BaseInventoryAssetInstance {
    /**
     * 
     * @type {DecorInventoryAsset}
     * @memberof DecorInventoryAssetInstance
     */
    asset?: DecorInventoryAsset;
}
/**
 * 
 * @export
 * @interface DeleteAssetInstanceResponse
 */
export interface DeleteAssetInstanceResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DeleteAssetInstanceResponse
     */
    success?: boolean;
}
/**
 * 
 * @export
 * @interface DeleteAssetsRequest
 */
export interface DeleteAssetsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteAssetsRequest
     */
    assetIds?: Array<string>;
}
/**
 * 
 * @export
 * @interface DeleteAssetsResponse
 */
export interface DeleteAssetsResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteAssetsResponse
     */
    deletedIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteAssetsResponse
     */
    failedIds?: Array<string>;
}
/**
 * Response after successfully deleting a custom color
 * @export
 * @interface DeleteCustomColorResponse
 */
export interface DeleteCustomColorResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DeleteCustomColorResponse
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeleteCustomColorResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface DeleteHardCurrencyProductMetadataResponse
 */
export interface DeleteHardCurrencyProductMetadataResponse {
    /**
     * 
     * @type {string}
     * @memberof DeleteHardCurrencyProductMetadataResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface DeleteSoftCurrencyProductResponse
 */
export interface DeleteSoftCurrencyProductResponse {
    /**
     * 
     * @type {string}
     * @memberof DeleteSoftCurrencyProductResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface DeleteSoftCurrencyResponse
 */
export interface DeleteSoftCurrencyResponse {
    /**
     * Confirmation message indicating successful deletion.
     * @type {string}
     * @memberof DeleteSoftCurrencyResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface ErrorMessage
 */
export interface ErrorMessage {
    /**
     * 
     * @type {string}
     * @memberof ErrorMessage
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface EyesAsset
 */
export interface EyesAsset extends BaseInventoryAsset {
    /**
     * Hexadecimal color codes for eye colors
     * @type {Array<string>}
     * @memberof EyesAsset
     */
    colorsHex?: Array<string>;
}

/**
 * @export
 * @namespace EyesAsset
 */
export namespace EyesAsset {
}
/**
 * 
 * @export
 * @interface EyesAssetInstance
 */
export interface EyesAssetInstance extends BaseInventoryAssetInstance {
    /**
     * 
     * @type {EyesAsset}
     * @memberof EyesAssetInstance
     */
    asset?: EyesAsset;
}
/**
 * 
 * @export
 * @interface FlairAsset
 */
export interface FlairAsset extends BaseInventoryAsset {
}

/**
 * @export
 * @namespace FlairAsset
 */
export namespace FlairAsset {
}
/**
 * 
 * @export
 * @interface FlairAssetInstance
 */
export interface FlairAssetInstance extends BaseInventoryAssetInstance {
    /**
     * 
     * @type {FlairAsset}
     * @memberof FlairAssetInstance
     */
    asset?: FlairAsset;
}
/**
 * Represents the amount to add to user
 * @export
 * @interface ForceAddHardCurrencyBody
 */
export interface ForceAddHardCurrencyBody {
    /**
     * amount of hard currency to add to the user's balance 
     * @type {number}
     * @memberof ForceAddHardCurrencyBody
     */
    amount: number;
    /**
     * can be \"buyer\" or \"seller\" 
     * @type {string}
     * @memberof ForceAddHardCurrencyBody
     */
    walletType: string;
}
/**
 * 
 * @export
 * @interface ForceAddHardCurrencyResponse
 */
export interface ForceAddHardCurrencyResponse {
    /**
     * 
     * @type {number}
     * @memberof ForceAddHardCurrencyResponse
     */
    balance?: number;
}
/**
 * Object representation of a gear
 * @export
 * @interface Gear
 */
export interface Gear {
    /**
     * 
     * @type {string}
     * @memberof Gear
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Gear
     */
    gearVersionId?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Gear
     */
    iconUrl?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Gear
     */
    status?: string;
    /**
     * 
     * @type {number}
     * @memberof Gear
     */
    sdkVersion?: number;
    /**
     * 
     * @type {string}
     * @memberof Gear
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Gear
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Gear
     */
    cmsId?: string;
    /**
     * 
     * @type {string}
     * @memberof Gear
     */
    reviewerId?: string;
    /**
     * 
     * @type {string}
     * @memberof Gear
     */
    reviewerComment?: string;
    /**
     * 
     * @type {string}
     * @memberof Gear
     */
    s3Key?: string;
    /**
     * 
     * @type {string}
     * @memberof Gear
     */
    fullSdkVersion?: string;
    /**
     * 
     * @type {number}
     * @memberof Gear
     */
    createdAt?: number;
    /**
     * 
     * @type {number}
     * @memberof Gear
     */
    lastModifiedAt?: number;
    /**
     * 
     * @type {number}
     * @memberof Gear
     */
    contentVersion?: number;
    /**
     * 
     * @type {string}
     * @memberof Gear
     */
    category?: Gear.CategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof Gear
     */
    buildStatus?: Gear.BuildStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Gear
     */
    errorMessage?: string;
    /**
     * 
     * @type {Array<RenderingUrl>}
     * @memberof Gear
     */
    renderingUrl?: Array<RenderingUrl>;
    /**
     * 
     * @type {boolean}
     * @memberof Gear
     */
    nonConformed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Gear
     */
    contentBuildStatus?: Gear.ContentBuildStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Gear
     */
    contentError?: string;
}

/**
 * @export
 * @namespace Gear
 */
export namespace Gear {
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryEnum {
        NOCATEGORY = <any> 'NOCATEGORY',
        BRACELETS = <any> 'BRACELETS',
        DRESSES = <any> 'DRESSES',
        EARRINGS = <any> 'EARRINGS',
        GLASSES = <any> 'GLASSES',
        HATS = <any> 'HATS',
        HOODIES = <any> 'HOODIES',
        JACKETS = <any> 'JACKETS',
        MASKS = <any> 'MASKS',
        PANTS = <any> 'PANTS',
        SHIRTS = <any> 'SHIRTS',
        SHOES = <any> 'SHOES',
        SHORTS = <any> 'SHORTS',
        SKIRTS = <any> 'SKIRTS'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum BuildStatusEnum {
        QUEUED = <any> 'QUEUED',
        FAILED = <any> 'FAILED',
        WARNING = <any> 'WARNING',
        SUCCESS = <any> 'SUCCESS',
        PREVIEWSRENDERED = <any> 'PREVIEWS_RENDERED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ContentBuildStatusEnum {
        NOBUILDSTATUS = <any> 'NOBUILDSTATUS',
        QUEUED = <any> 'QUEUED',
        FAILED = <any> 'FAILED',
        WARNING = <any> 'WARNING',
        SUCCESS = <any> 'SUCCESS'
    }
}
/**
 * Representation of request body for create gear
 * @export
 * @interface GearCreateRequest
 */
export interface GearCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof GearCreateRequest
     */
    gearId?: string;
    /**
     * 
     * @type {string}
     * @memberof GearCreateRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GearCreateRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof GearCreateRequest
     */
    category?: GearCreateRequest.CategoryEnum;
    /**
     * 
     * @type {boolean}
     * @memberof GearCreateRequest
     */
    nonConformed?: boolean;
}

/**
 * @export
 * @namespace GearCreateRequest
 */
export namespace GearCreateRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryEnum {
        NOCATEGORY = <any> 'NOCATEGORY',
        HOODIE = <any> 'HOODIE',
        SHIRT = <any> 'SHIRT',
        JACKET = <any> 'JACKET',
        DRESS = <any> 'DRESS',
        PANTS = <any> 'PANTS',
        SHORTS = <any> 'SHORTS',
        SKIRT = <any> 'SKIRT',
        SHOES = <any> 'SHOES',
        EARRINGS = <any> 'EARRINGS',
        GLASSES = <any> 'GLASSES',
        HAT = <any> 'HAT',
        MASK = <any> 'MASK'
    }
}
/**
 * Representation of response body for create gear
 * @export
 * @interface GearCreateResponse
 */
export interface GearCreateResponse {
    /**
     * 
     * @type {string}
     * @memberof GearCreateResponse
     */
    gearId?: string;
    /**
     * 
     * @type {string}
     * @memberof GearCreateResponse
     */
    gearVersionId?: string;
    /**
     * 
     * @type {string}
     * @memberof GearCreateResponse
     */
    presignedUrl?: string;
}
/**
 * Object representation of a gear
 * @export
 * @interface GearGetByIdResponse
 */
export interface GearGetByIdResponse {
    /**
     * 
     * @type {Gear}
     * @memberof GearGetByIdResponse
     */
    gear?: Gear;
}
/**
 * 
 * @export
 * @interface GearInventoryAsset
 */
export interface GearInventoryAsset extends VersionableInventoryAsset {
    /**
     * Available colors for this gear
     * @type {Array<ColorHex>}
     * @memberof GearInventoryAsset
     */
    colors?: Array<ColorHex>;
    /**
     * Gear category
     * @type {string}
     * @memberof GearInventoryAsset
     */
    category?: string;
    /**
     * Gear subcategories
     * @type {Array<string>}
     * @memberof GearInventoryAsset
     */
    subcategories?: Array<string>;
}
/**
 * 
 * @export
 * @interface GearInventoryAssetInstance
 */
export interface GearInventoryAssetInstance extends BaseInventoryAssetInstance {
    /**
     * 
     * @type {GearInventoryAsset}
     * @memberof GearInventoryAssetInstance
     */
    asset?: GearInventoryAsset;
}
/**
 * List of gear objects
 * @export
 * @interface GearListResponse
 */
export interface GearListResponse {
    /**
     * 
     * @type {Array<Gear>}
     * @memberof GearListResponse
     */
    gears?: Array<Gear>;
    /**
     * 
     * @type {string}
     * @memberof GearListResponse
     */
    cursor?: string;
}
/**
 * Representation of request body for update gear
 * @export
 * @interface GearUpdateRequest
 */
export interface GearUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof GearUpdateRequest
     */
    gearVersionId?: string;
    /**
     * 
     * @type {string}
     * @memberof GearUpdateRequest
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof GearUpdateRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GearUpdateRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof GearUpdateRequest
     */
    cmsId?: string;
    /**
     * 
     * @type {string}
     * @memberof GearUpdateRequest
     */
    reviewerId?: string;
    /**
     * 
     * @type {string}
     * @memberof GearUpdateRequest
     */
    reviewerComment?: string;
    /**
     * 
     * @type {string}
     * @memberof GearUpdateRequest
     */
    s3Key?: string;
    /**
     * 
     * @type {string}
     * @memberof GearUpdateRequest
     */
    fullSdkVersion?: string;
    /**
     * 
     * @type {number}
     * @memberof GearUpdateRequest
     */
    createdAt?: number;
    /**
     * 
     * @type {number}
     * @memberof GearUpdateRequest
     */
    lastModifiedAt?: number;
    /**
     * 
     * @type {number}
     * @memberof GearUpdateRequest
     */
    contentVersion?: number;
    /**
     * 
     * @type {string}
     * @memberof GearUpdateRequest
     */
    category?: GearUpdateRequest.CategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof GearUpdateRequest
     */
    errorMessage?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GearUpdateRequest
     */
    iconUrl?: Array<string>;
    /**
     * 
     * @type {Array<RenderingUrl>}
     * @memberof GearUpdateRequest
     */
    renderingUrl?: Array<RenderingUrl>;
}

/**
 * @export
 * @namespace GearUpdateRequest
 */
export namespace GearUpdateRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryEnum {
        NOCATEGORY = <any> 'NOCATEGORY',
        BRACELETS = <any> 'BRACELETS',
        DRESSES = <any> 'DRESSES',
        EARRINGS = <any> 'EARRINGS',
        GLASSES = <any> 'GLASSES',
        HATS = <any> 'HATS',
        HOODIES = <any> 'HOODIES',
        JACKETS = <any> 'JACKETS',
        MASKS = <any> 'MASKS',
        PANTS = <any> 'PANTS',
        SHIRTS = <any> 'SHIRTS',
        SHOES = <any> 'SHOES',
        SHORTS = <any> 'SHORTS',
        SKIRTS = <any> 'SKIRTS'
    }
}
/**
 * 
 * @export
 * @interface GenericMessageResponse
 */
export interface GenericMessageResponse {
    /**
     * 
     * @type {string}
     * @memberof GenericMessageResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface GetActiveSoftCurrencyProductsResponse
 */
export interface GetActiveSoftCurrencyProductsResponse {
    /**
     * 
     * @type {Array<SoftCurrencyProductWithMetadata>}
     * @memberof GetActiveSoftCurrencyProductsResponse
     */
    products?: Array<SoftCurrencyProductWithMetadata>;
}
/**
 * 
 * @export
 * @interface GetAllCurrenciesForOwnerResponse
 */
export interface GetAllCurrenciesForOwnerResponse {
    /**
     * 
     * @type {Array<Currency>}
     * @memberof GetAllCurrenciesForOwnerResponse
     */
    currencies?: Array<Currency>;
}
/**
 * 
 * @export
 * @interface GetAllHardCurrencyProductMetadataResponse
 */
export interface GetAllHardCurrencyProductMetadataResponse {
    /**
     * 
     * @type {Array<HardCurrencyProductMetadata>}
     * @memberof GetAllHardCurrencyProductMetadataResponse
     */
    metadataList?: Array<HardCurrencyProductMetadata>;
}
/**
 * 
 * @export
 * @interface GetAllStoresResponse
 */
export interface GetAllStoresResponse {
    /**
     * List of available metadata stores
     * @type {Array<MetadataStoreInfo>}
     * @memberof GetAllStoresResponse
     */
    stores?: Array<MetadataStoreInfo>;
    /**
     * Total number of stores
     * @type {number}
     * @memberof GetAllStoresResponse
     */
    total?: number;
    /**
     * Pagination cursor for the next page of results
     * @type {string}
     * @memberof GetAllStoresResponse
     */
    nextCursor?: string;
}
/**
 * 
 * @export
 * @interface GetAllWalletsForUserResponse
 */
export interface GetAllWalletsForUserResponse {
    /**
     * 
     * @type {number}
     * @memberof GetAllWalletsForUserResponse
     */
    hardCurrency?: number;
    /**
     * 
     * @type {Array<Wallet>}
     * @memberof GetAllWalletsForUserResponse
     */
    softWallets?: Array<Wallet>;
}
/**
 * 
 * @export
 * @interface GetHardCurrencyProductMetadataResponse
 */
export interface GetHardCurrencyProductMetadataResponse {
    /**
     * 
     * @type {HardCurrencyProductMetadata}
     * @memberof GetHardCurrencyProductMetadataResponse
     */
    metadata?: HardCurrencyProductMetadata;
}
/**
 * 
 * @export
 * @interface GetHardCurrencyProductsWithMappingsResponse
 */
export interface GetHardCurrencyProductsWithMappingsResponse {
    /**
     * 
     * @type {Array<HardCurrencyProductWithMappings>}
     * @memberof GetHardCurrencyProductsWithMappingsResponse
     */
    productsWithMappings?: Array<HardCurrencyProductWithMappings>;
}
/**
 * V2 animation library assets response
 * @export
 * @interface GetInventoryV2AnimationLibraryResponse
 */
export interface GetInventoryV2AnimationLibraryResponse {
    /**
     * List of animation library assets
     * @type {Array<AnimationLibraryAssetInstance>}
     * @memberof GetInventoryV2AnimationLibraryResponse
     */
    animationLibrary?: Array<AnimationLibraryAssetInstance>;
    /**
     * Pagination cursor for the next page of results
     * @type {string}
     * @memberof GetInventoryV2AnimationLibraryResponse
     */
    nextCursor?: string;
}
/**
 * V2 base customization assets response
 * @export
 * @interface GetInventoryV2AvatarBaseResponse
 */
export interface GetInventoryV2AvatarBaseResponse {
    /**
     * List of base customization avatar assets
     * @type {Array<AvatarBaseAssetInstance>}
     * @memberof GetInventoryV2AvatarBaseResponse
     */
    avatarBase?: Array<AvatarBaseAssetInstance>;
    /**
     * Pagination cursor for the next page of results
     * @type {string}
     * @memberof GetInventoryV2AvatarBaseResponse
     */
    nextCursor?: string;
}
/**
 * V2 eye assets response
 * @export
 * @interface GetInventoryV2AvatarEyesResponse
 */
export interface GetInventoryV2AvatarEyesResponse {
    /**
     * List of eye assets
     * @type {Array<EyesAssetInstance>}
     * @memberof GetInventoryV2AvatarEyesResponse
     */
    avatarEyes?: Array<EyesAssetInstance>;
    /**
     * Pagination cursor for the next page of results
     * @type {string}
     * @memberof GetInventoryV2AvatarEyesResponse
     */
    nextCursor?: string;
}
/**
 * V2 flair assets response
 * @export
 * @interface GetInventoryV2AvatarFlairResponse
 */
export interface GetInventoryV2AvatarFlairResponse {
    /**
     * List of flair/accessory assets
     * @type {Array<FlairAssetInstance>}
     * @memberof GetInventoryV2AvatarFlairResponse
     */
    avatarFlair?: Array<FlairAssetInstance>;
    /**
     * Pagination cursor for the next page of results
     * @type {string}
     * @memberof GetInventoryV2AvatarFlairResponse
     */
    nextCursor?: string;
}
/**
 * V2 makeup assets response
 * @export
 * @interface GetInventoryV2AvatarMakeupResponse
 */
export interface GetInventoryV2AvatarMakeupResponse {
    /**
     * List of makeup assets
     * @type {Array<MakeupAssetInstance>}
     * @memberof GetInventoryV2AvatarMakeupResponse
     */
    avatarMakeup?: Array<MakeupAssetInstance>;
    /**
     * Pagination cursor for the next page of results
     * @type {string}
     * @memberof GetInventoryV2AvatarMakeupResponse
     */
    nextCursor?: string;
}
/**
 * V2 avatar-only inventory response
 * @export
 * @interface GetInventoryV2AvatarResponse
 */
export interface GetInventoryV2AvatarResponse {
    /**
     * List of user avatar items
     * @type {Array<UserAvatarInventoryAssetInstance>}
     * @memberof GetInventoryV2AvatarResponse
     */
    avatar?: Array<UserAvatarInventoryAssetInstance>;
    /**
     * Pagination cursor for the next page of results
     * @type {string}
     * @memberof GetInventoryV2AvatarResponse
     */
    nextCursor?: string;
}
/**
 * V2 color preset assets response
 * @export
 * @interface GetInventoryV2ColorPresetsResponse
 */
export interface GetInventoryV2ColorPresetsResponse {
    /**
     * List of color preset assets
     * @type {Array<ColorPresetAssetInstance>}
     * @memberof GetInventoryV2ColorPresetsResponse
     */
    colorPresets?: Array<ColorPresetAssetInstance>;
    /**
     * Pagination cursor for the next page of results
     * @type {string}
     * @memberof GetInventoryV2ColorPresetsResponse
     */
    nextCursor?: string;
}
/**
 * V2 decor-only inventory response
 * @export
 * @interface GetInventoryV2DecorResponse
 */
export interface GetInventoryV2DecorResponse {
    /**
     * List of decorative items (filtered from ModelLibrary)
     * @type {Array<DecorInventoryAssetInstance>}
     * @memberof GetInventoryV2DecorResponse
     */
    decor?: Array<DecorInventoryAssetInstance>;
    /**
     * Pagination cursor for the next page of results
     * @type {string}
     * @memberof GetInventoryV2DecorResponse
     */
    nextCursor?: string;
}
/**
 * V2 gear-only inventory response
 * @export
 * @interface GetInventoryV2GearResponse
 */
export interface GetInventoryV2GearResponse {
    /**
     * List of gear/wearable items
     * @type {Array<GearInventoryAssetInstance>}
     * @memberof GetInventoryV2GearResponse
     */
    gear?: Array<GearInventoryAssetInstance>;
    /**
     * Pagination cursor for the next page of results
     * @type {string}
     * @memberof GetInventoryV2GearResponse
     */
    nextCursor?: string;
}
/**
 * V2 image library assets response
 * @export
 * @interface GetInventoryV2ImageLibraryResponse
 */
export interface GetInventoryV2ImageLibraryResponse {
    /**
     * List of image library assets
     * @type {Array<ImageLibraryAssetInstance>}
     * @memberof GetInventoryV2ImageLibraryResponse
     */
    imageLibrary?: Array<ImageLibraryAssetInstance>;
    /**
     * Pagination cursor for the next page of results
     * @type {string}
     * @memberof GetInventoryV2ImageLibraryResponse
     */
    nextCursor?: string;
}
/**
 * V2 model library assets response
 * @export
 * @interface GetInventoryV2ModelLibraryResponse
 */
export interface GetInventoryV2ModelLibraryResponse {
    /**
     * List of model library assets
     * @type {Array<ModelLibraryAssetInstance>}
     * @memberof GetInventoryV2ModelLibraryResponse
     */
    modelLibrary?: Array<ModelLibraryAssetInstance>;
    /**
     * Pagination cursor for the next page of results
     * @type {string}
     * @memberof GetInventoryV2ModelLibraryResponse
     */
    nextCursor?: string;
}
/**
 * V2 inventory response with categorized item lists
 * @export
 * @interface GetInventoryV2Response
 */
export interface GetInventoryV2Response {
    /**
     * List of gear/wearable items
     * @type {Array<GearInventoryAssetInstance>}
     * @memberof GetInventoryV2Response
     */
    gear?: Array<GearInventoryAssetInstance>;
    /**
     * List of decorative items
     * @type {Array<DecorInventoryAssetInstance>}
     * @memberof GetInventoryV2Response
     */
    decor?: Array<DecorInventoryAssetInstance>;
    /**
     * List of user avatar items
     * @type {Array<UserAvatarInventoryAssetInstance>}
     * @memberof GetInventoryV2Response
     */
    avatar?: Array<UserAvatarInventoryAssetInstance>;
    /**
     * List of avatar base assets
     * @type {Array<AvatarBaseAssetInstance>}
     * @memberof GetInventoryV2Response
     */
    avatarBase?: Array<AvatarBaseAssetInstance>;
    /**
     * List of makeup assets
     * @type {Array<MakeupAssetInstance>}
     * @memberof GetInventoryV2Response
     */
    makeup?: Array<MakeupAssetInstance>;
    /**
     * List of flair/accessory assets
     * @type {Array<FlairAssetInstance>}
     * @memberof GetInventoryV2Response
     */
    flair?: Array<FlairAssetInstance>;
    /**
     * List of eye assets
     * @type {Array<EyesAssetInstance>}
     * @memberof GetInventoryV2Response
     */
    avatarEyes?: Array<EyesAssetInstance>;
    /**
     * List of color preset assets
     * @type {Array<ColorPresetAssetInstance>}
     * @memberof GetInventoryV2Response
     */
    colorPresets?: Array<ColorPresetAssetInstance>;
    /**
     * List of image library assets
     * @type {Array<ImageLibraryAssetInstance>}
     * @memberof GetInventoryV2Response
     */
    imageLibrary?: Array<ImageLibraryAssetInstance>;
    /**
     * List of animation library assets
     * @type {Array<AnimationLibraryAssetInstance>}
     * @memberof GetInventoryV2Response
     */
    animationLibrary?: Array<AnimationLibraryAssetInstance>;
    /**
     * List of model library assets
     * @type {Array<ModelLibraryAssetInstance>}
     * @memberof GetInventoryV2Response
     */
    modelLibrary?: Array<ModelLibraryAssetInstance>;
    /**
     * Pagination cursor for the next page of results
     * @type {string}
     * @memberof GetInventoryV2Response
     */
    nextCursor?: string;
}
/**
 * 
 * @export
 * @interface GetMetadataStoreResponse
 */
export interface GetMetadataStoreResponse {
    /**
     * Unique identifier for the metadata store
     * @type {string}
     * @memberof GetMetadataStoreResponse
     */
    metadataStoreKey?: string;
    /**
     * List of indexed fields in the metadata store
     * @type {Array<InventoryIndexedField>}
     * @memberof GetMetadataStoreResponse
     */
    fields?: Array<InventoryIndexedField>;
}
/**
 * 
 * @export
 * @interface GetMetadataTagResponse
 */
export interface GetMetadataTagResponse {
    /**
     * 
     * @type {InventoryMetadataTag}
     * @memberof GetMetadataTagResponse
     */
    tag?: InventoryMetadataTag;
}
/**
 * 
 * @export
 * @interface GetSoftCurrencyProductResponse
 */
export interface GetSoftCurrencyProductResponse {
    /**
     * 
     * @type {string}
     * @memberof GetSoftCurrencyProductResponse
     */
    currencyId?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSoftCurrencyProductResponse
     */
    productSku?: string;
    /**
     * 
     * @type {number}
     * @memberof GetSoftCurrencyProductResponse
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof GetSoftCurrencyProductResponse
     */
    hcCost?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GetSoftCurrencyProductResponse
     */
    isActive?: boolean;
    /**
     * 
     * @type {SoftCurrencyProductMetadata}
     * @memberof GetSoftCurrencyProductResponse
     */
    metadata?: SoftCurrencyProductMetadata;
}
/**
 * 
 * @export
 * @interface GetTransactionHistoryResponse
 */
export interface GetTransactionHistoryResponse {
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof GetTransactionHistoryResponse
     */
    transactions?: Array<Transaction>;
    /**
     * 
     * @type {number}
     * @memberof GetTransactionHistoryResponse
     */
    totalCount?: number;
    /**
     * 
     * @type {number}
     * @memberof GetTransactionHistoryResponse
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof GetTransactionHistoryResponse
     */
    pageSize?: number;
}
/**
 * 
 * @export
 * @interface HardCurrencyProduct
 */
export interface HardCurrencyProduct {
    /**
     * 
     * @type {string}
     * @memberof HardCurrencyProduct
     */
    productSku?: string;
    /**
     * 
     * @type {number}
     * @memberof HardCurrencyProduct
     */
    amount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof HardCurrencyProduct
     */
    isActive?: boolean;
}
/**
 * 
 * @export
 * @interface HardCurrencyProductMetadata
 */
export interface HardCurrencyProductMetadata {
    /**
     * 
     * @type {string}
     * @memberof HardCurrencyProductMetadata
     */
    productSku?: string;
    /**
     * 
     * @type {string}
     * @memberof HardCurrencyProductMetadata
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof HardCurrencyProductMetadata
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof HardCurrencyProductMetadata
     */
    iconUrl?: string;
}
/**
 * 
 * @export
 * @interface HardCurrencyProductWithMappings
 */
export interface HardCurrencyProductWithMappings {
    /**
     * 
     * @type {HardCurrencyProduct}
     * @memberof HardCurrencyProductWithMappings
     */
    product?: HardCurrencyProduct;
    /**
     * 
     * @type {Array<ProductSkuMapping>}
     * @memberof HardCurrencyProductWithMappings
     */
    mappings?: Array<ProductSkuMapping>;
}
/**
 * 
 * @export
 * @interface ImageLibraryAsset
 */
export interface ImageLibraryAsset extends BaseInventoryAsset {
}

/**
 * @export
 * @namespace ImageLibraryAsset
 */
export namespace ImageLibraryAsset {
}
/**
 * 
 * @export
 * @interface ImageLibraryAssetInstance
 */
export interface ImageLibraryAssetInstance extends BaseInventoryAssetInstance {
    /**
     * 
     * @type {ImageLibraryAsset}
     * @memberof ImageLibraryAssetInstance
     */
    asset?: ImageLibraryAsset;
}
/**
 * 
 * @export
 * @interface InlineResponse410
 */
export interface InlineResponse410 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse410
     */
    error?: string;
}
/**
 * Represents an inventory item asset
 * @export
 * @interface InventoryAsset
 */
export interface InventoryAsset {
    /**
     * ID of asset type
     * @type {string}
     * @memberof InventoryAsset
     */
    assetId?: string;
    /**
     * Type of the asset
     * @type {string}
     * @memberof InventoryAsset
     */
    assetType?: string;
    /**
     * Name of item
     * @type {string}
     * @memberof InventoryAsset
     */
    name?: string;
    /**
     * Description of asset
     * @type {string}
     * @memberof InventoryAsset
     */
    description?: string;
    /**
     * Version of the asset
     * @type {number}
     * @memberof InventoryAsset
     */
    assetVersion?: number;
}
/**
 * Individual inventory item
 * @export
 * @interface InventoryAssetInstance
 */
export interface InventoryAssetInstance {
    /**
     * ID of the asset instance
     * @type {string}
     * @memberof InventoryAssetInstance
     */
    assetInstanceId?: string;
    /**
     * Creator of the item
     * @type {string}
     * @memberof InventoryAssetInstance
     */
    creator?: string;
    /**
     * Creation timestamp
     * @type {number}
     * @memberof InventoryAssetInstance
     */
    dateCreated?: number;
    /**
     * Origin of the item
     * @type {string}
     * @memberof InventoryAssetInstance
     */
    origin?: string;
    /**
     * 
     * @type {InventoryCost}
     * @memberof InventoryAssetInstance
     */
    cost?: InventoryCost;
    /**
     * Quantity of the item
     * @type {number}
     * @memberof InventoryAssetInstance
     */
    amount?: number;
    /**
     * 
     * @type {InventoryAsset}
     * @memberof InventoryAssetInstance
     */
    asset?: InventoryAsset;
    /**
     * 
     * @type {InventoryTags}
     * @memberof InventoryAssetInstance
     */
    tags?: InventoryTags;
}
/**
 * Represents the cost of an inventory object
 * @export
 * @interface InventoryCost
 */
export interface InventoryCost {
    /**
     * currency id
     * @type {string}
     * @memberof InventoryCost
     */
    currencyId?: string;
    /**
     * price
     * @type {number}
     * @memberof InventoryCost
     */
    amount?: number;
}
/**
 * Response for getting inventory items
 * @export
 * @interface InventoryGetResponse
 */
export interface InventoryGetResponse {
    /**
     * 
     * @type {Array<InventoryAssetInstance>}
     * @memberof InventoryGetResponse
     */
    data?: Array<InventoryAssetInstance>;
    /**
     * Cursor for pagination
     * @type {string}
     * @memberof InventoryGetResponse
     */
    nextCursor?: string;
}
/**
 * 
 * @export
 * @interface InventoryIndexedField
 */
export interface InventoryIndexedField {
    /**
     * 
     * @type {string}
     * @memberof InventoryIndexedField
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InventoryIndexedField
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface InventoryMetadataTag
 */
export interface InventoryMetadataTag {
    /**
     * 
     * @type {string}
     * @memberof InventoryMetadataTag
     */
    id?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof InventoryMetadataTag
     */
    body?: { [key: string]: any; };
}
/**
 * Represents tags on an inventory
 * @export
 * @interface InventoryTags
 */
export interface InventoryTags {
    /**
     * 
     * @type {Array<string>}
     * @memberof InventoryTags
     */
    color?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InventoryTags
     */
    category?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InventoryTags
     */
    partyId?: string;
}
/**
 * 
 * @export
 * @interface LeaderboardCreateRequest
 */
export interface LeaderboardCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof LeaderboardCreateRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardCreateRequest
     */
    description?: string;
    /**
     * leaderboard type, default is CURRENT_SCORE
     * @type {string}
     * @memberof LeaderboardCreateRequest
     */
    type?: LeaderboardCreateRequest.TypeEnum;
}

/**
 * @export
 * @namespace LeaderboardCreateRequest
 */
export namespace LeaderboardCreateRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        CURRENTSCORE = <any> 'CURRENT_SCORE',
        HIGHESTSCORE = <any> 'HIGHEST_SCORE'
    }
}
/**
 * 
 * @export
 * @interface LeaderboardCreateResponse
 */
export interface LeaderboardCreateResponse {
    /**
     * 
     * @type {string}
     * @memberof LeaderboardCreateResponse
     */
    leaderboardId?: string;
}
/**
 * Representation of request body for create gear
 * @export
 * @interface LeaderboardSubmitUserScoreRequest
 */
export interface LeaderboardSubmitUserScoreRequest {
    /**
     * 
     * @type {string}
     * @memberof LeaderboardSubmitUserScoreRequest
     */
    userId?: string;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardSubmitUserScoreRequest
     */
    scoreIncrement?: number;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardSubmitUserScoreRequest
     */
    idempotencyKey?: string;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardSubmitUserScoreRequest
     */
    score?: number;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardSubmitUserScoreRequest
     */
    type?: LeaderboardSubmitUserScoreRequest.TypeEnum;
}

/**
 * @export
 * @namespace LeaderboardSubmitUserScoreRequest
 */
export namespace LeaderboardSubmitUserScoreRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        INCREMENTAL = <any> 'INCREMENTAL',
        DIRECT = <any> 'DIRECT'
    }
}
/**
 * Response containing a list of custom color presets
 * @export
 * @interface ListCustomColorsResponse
 */
export interface ListCustomColorsResponse {
    /**
     * 
     * @type {Array<CustomColorResponse>}
     * @memberof ListCustomColorsResponse
     */
    colors?: Array<CustomColorResponse>;
}
/**
 * 
 * @export
 * @interface MakeupAsset
 */
export interface MakeupAsset extends BaseInventoryAsset {
}

/**
 * @export
 * @namespace MakeupAsset
 */
export namespace MakeupAsset {
}
/**
 * 
 * @export
 * @interface MakeupAssetInstance
 */
export interface MakeupAssetInstance extends BaseInventoryAssetInstance {
    /**
     * 
     * @type {MakeupAsset}
     * @memberof MakeupAssetInstance
     */
    asset?: MakeupAsset;
}
/**
 * 
 * @export
 * @interface MaxCountStatus
 */
export interface MaxCountStatus {
    /**
     * 
     * @type {string}
     * @memberof MaxCountStatus
     */
    traitId?: string;
    /**
     * 
     * @type {string}
     * @memberof MaxCountStatus
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof MaxCountStatus
     */
    currentCount?: number;
    /**
     * Limit of max count for the associated trait
     * @type {number}
     * @memberof MaxCountStatus
     */
    maxCount?: number;
    /**
     * 
     * @type {number}
     * @memberof MaxCountStatus
     */
    expiresAt?: number;
    /**
     * 
     * @type {string}
     * @memberof MaxCountStatus
     */
    source?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MaxCountStatus
     */
    onCooldown?: boolean;
}
/**
 * 
 * @export
 * @interface MessageResponse
 */
export interface MessageResponse {
    /**
     * 
     * @type {string}
     * @memberof MessageResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface MetadataIndexedField
 */
export interface MetadataIndexedField {
    /**
     * Field name
     * @type {string}
     * @memberof MetadataIndexedField
     */
    name?: string;
    /**
     * Field type
     * @type {string}
     * @memberof MetadataIndexedField
     */
    type?: MetadataIndexedField.TypeEnum;
}

/**
 * @export
 * @namespace MetadataIndexedField
 */
export namespace MetadataIndexedField {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        STRING = <any> 'STRING',
        NUMBER = <any> 'NUMBER',
        BOOL = <any> 'BOOL'
    }
}
/**
 * 
 * @export
 * @interface MetadataStoreCreatedResponse
 */
export interface MetadataStoreCreatedResponse {
    /**
     * 
     * @type {string}
     * @memberof MetadataStoreCreatedResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof MetadataStoreCreatedResponse
     */
    metadataStoreKey?: string;
}
/**
 * 
 * @export
 * @interface MetadataStoreInfo
 */
export interface MetadataStoreInfo {
    /**
     * Store namespace
     * @type {string}
     * @memberof MetadataStoreInfo
     */
    namespace?: string;
    /**
     * Store type (core, app-specific, instance)
     * @type {string}
     * @memberof MetadataStoreInfo
     */
    type?: string;
    /**
     * Store description
     * @type {string}
     * @memberof MetadataStoreInfo
     */
    description?: string;
    /**
     * List of indexed fields with their types
     * @type {Array<MetadataIndexedField>}
     * @memberof MetadataStoreInfo
     */
    indexedFields?: Array<MetadataIndexedField>;
    /**
     * Whether the store exists in the inventory service
     * @type {boolean}
     * @memberof MetadataStoreInfo
     */
    exists?: boolean;
    /**
     * When the store was created (timestamp)
     * @type {string}
     * @memberof MetadataStoreInfo
     */
    createdAt?: string;
}
/**
 * 
 * @export
 * @interface MintAssetRequest
 */
export interface MintAssetRequest {
    /**
     * ID of the asset to mint an instance of
     * @type {string}
     * @memberof MintAssetRequest
     */
    assetId: string;
    /**
     * ID of the user who will own this asset instance
     * @type {string}
     * @memberof MintAssetRequest
     */
    ownerId: string;
    /**
     * Optional party ID associated with this asset instance
     * @type {string}
     * @memberof MintAssetRequest
     */
    partyId?: string;
    /**
     * Optional organization ID associated with this asset instance
     * @type {string}
     * @memberof MintAssetRequest
     */
    orgId?: string;
    /**
     * Optional experience ID associated with this asset instance
     * @type {string}
     * @memberof MintAssetRequest
     */
    experienceId?: string;
}
/**
 * 
 * @export
 * @interface MintAssetResponse
 */
export interface MintAssetResponse {
    /**
     * Unique ID of the newly minted asset instance
     * @type {string}
     * @memberof MintAssetResponse
     */
    instanceId?: string;
    /**
     * ID of the original asset
     * @type {string}
     * @memberof MintAssetResponse
     */
    assetId?: string;
    /**
     * ID of the owner
     * @type {string}
     * @memberof MintAssetResponse
     */
    ownerId?: string;
    /**
     * Unix timestamp when the asset was minted
     * @type {number}
     * @memberof MintAssetResponse
     */
    mintedAt?: number;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface ModelLibraryAsset
 */
export interface ModelLibraryAsset extends VersionableInventoryAsset {
    /**
     * Available colors for this model
     * @type {Array<ColorHex>}
     * @memberof ModelLibraryAsset
     */
    colors?: Array<ColorHex>;
    /**
     * Model category (e.g., furniture, decor, lighting)
     * @type {string}
     * @memberof ModelLibraryAsset
     */
    category?: string;
    /**
     * Model subcategories
     * @type {Array<string>}
     * @memberof ModelLibraryAsset
     */
    subcategories?: Array<string>;
}
/**
 * 
 * @export
 * @interface ModelLibraryAssetInstance
 */
export interface ModelLibraryAssetInstance extends BaseInventoryAssetInstance {
    /**
     * 
     * @type {ModelLibraryAsset}
     * @memberof ModelLibraryAssetInstance
     */
    asset?: ModelLibraryAsset;
}
/**
 * Current moderation state of an asset
 * @export
 * @enum {string}
 */
export enum ModerationStatus {
    NotSubmitted = <any> 'not_submitted',
    InReview = <any> 'in_review',
    Approved = <any> 'approved',
    Rejected = <any> 'rejected'
}
/**
 * Paginated response containing assets and their moderation info
 * @export
 * @interface ModerationStatusResponse
 */
export interface ModerationStatusResponse {
    /**
     * 
     * @type {Array<AssetModerationInfo>}
     * @memberof ModerationStatusResponse
     */
    assets?: Array<AssetModerationInfo>;
    /**
     * Cursor for pagination
     * @type {string}
     * @memberof ModerationStatusResponse
     */
    nextCursor?: string;
    /**
     * Total number of assets matching the query
     * @type {number}
     * @memberof ModerationStatusResponse
     */
    total?: number;
}
/**
 * Type of moderation process
 * @export
 * @enum {string}
 */
export enum ModerationType {
    Auto = <any> 'auto',
    Manual = <any> 'manual'
}
/**
 * Pipeline versioning information (V2 - string-only versions with pipeline ID)
 * @export
 * @interface PipelineItemV2
 */
export interface PipelineItemV2 {
    /**
     * Pipeline identifier (e.g., \"pipeline_0\", \"pipeline_1\")
     * @type {string}
     * @memberof PipelineItemV2
     */
    pipelineId: string;
    /**
     * Asset version number
     * @type {number}
     * @memberof PipelineItemV2
     */
    assetVersion: number;
    /**
     * Pipeline version (semantic versioning string, e.g., \"1.2.3\")
     * @type {string}
     * @memberof PipelineItemV2
     */
    pipelineVersion: string;
    /**
     * Parent asset identifier
     * @type {string}
     * @memberof PipelineItemV2
     */
    parentId: string;
    /**
     * Whether universally available
     * @type {boolean}
     * @memberof PipelineItemV2
     */
    universalAvailable: boolean;
    /**
     * Universal build version (semantic versioning string, e.g., \"2.3.4\")
     * @type {string}
     * @memberof PipelineItemV2
     */
    universalBuildVersion: string;
    /**
     * Old addressables address for migration from CMS (optional)
     * @type {string}
     * @memberof PipelineItemV2
     */
    assetAddress?: string;
}
/**
 * 
 * @export
 * @interface ProductSkuMapping
 */
export interface ProductSkuMapping {
    /**
     * 
     * @type {string}
     * @memberof ProductSkuMapping
     */
    partyId?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductSkuMapping
     */
    storeId?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductSkuMapping
     */
    productId?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductSkuMapping
     */
    productSku?: string;
}
/**
 * Rendering animation videos and thumbnail images from pipeline
 * @export
 * @interface RenderingUrl
 */
export interface RenderingUrl {
    /**
     * 
     * @type {string}
     * @memberof RenderingUrl
     */
    previewURL?: string;
    /**
     * 
     * @type {string}
     * @memberof RenderingUrl
     */
    videoURL?: string;
}
/**
 * 
 * @export
 * @interface SetMetadataTagsRequest
 */
export interface SetMetadataTagsRequest {
    /**
     * 
     * @type {Array<InventoryMetadataTag>}
     * @memberof SetMetadataTagsRequest
     */
    tags?: Array<InventoryMetadataTag>;
}
/**
 * 
 * @export
 * @interface SetMetadataTagsResponse
 */
export interface SetMetadataTagsResponse {
}
/**
 * 
 * @export
 * @interface SoftCurrencyProductMetadata
 */
export interface SoftCurrencyProductMetadata {
    /**
     * 
     * @type {string}
     * @memberof SoftCurrencyProductMetadata
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof SoftCurrencyProductMetadata
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof SoftCurrencyProductMetadata
     */
    iconUrl?: string;
}
/**
 * 
 * @export
 * @interface SoftCurrencyProductWithMetadata
 */
export interface SoftCurrencyProductWithMetadata {
    /**
     * 
     * @type {string}
     * @memberof SoftCurrencyProductWithMetadata
     */
    currencyId?: string;
    /**
     * 
     * @type {string}
     * @memberof SoftCurrencyProductWithMetadata
     */
    productSku?: string;
    /**
     * 
     * @type {number}
     * @memberof SoftCurrencyProductWithMetadata
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof SoftCurrencyProductWithMetadata
     */
    hcCost?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SoftCurrencyProductWithMetadata
     */
    isActive?: boolean;
    /**
     * 
     * @type {SoftCurrencyProductMetadata}
     * @memberof SoftCurrencyProductWithMetadata
     */
    metadata?: SoftCurrencyProductMetadata;
}
/**
 * Representation of the singular object to update store
 * @export
 * @interface StoreItemUpdate
 */
export interface StoreItemUpdate {
    /**
     * Unique identifier for the item
     * @type {string}
     * @memberof StoreItemUpdate
     */
    itemId: string;
    /**
     * Defined type of the store item
     * @type {string}
     * @memberof StoreItemUpdate
     */
    itemType?: string;
    /**
     * Definition of the item
     * @type {string}
     * @memberof StoreItemUpdate
     */
    definition?: string;
}
/**
 * Representation of the properties to update store with items
 * @export
 * @interface StoreItemUpdates
 */
export interface StoreItemUpdates {
    /**
     * Operation to perform for this specified object
     * @type {string}
     * @memberof StoreItemUpdates
     */
    operation?: StoreItemUpdates.OperationEnum;
    /**
     * 
     * @type {Array<StoreItemUpdate>}
     * @memberof StoreItemUpdates
     */
    items?: Array<StoreItemUpdate>;
}

/**
 * @export
 * @namespace StoreItemUpdates
 */
export namespace StoreItemUpdates {
    /**
     * @export
     * @enum {string}
     */
    export enum OperationEnum {
        ADD = <any> 'ADD',
        REMOVE = <any> 'REMOVE'
    }
}
/**
 * 
 * @export
 * @interface SubmitAssetForReviewRequest
 */
export interface SubmitAssetForReviewRequest {
    /**
     * Optional notes from the asset creator
     * @type {string}
     * @memberof SubmitAssetForReviewRequest
     */
    notes?: string;
}
/**
 * 
 * @export
 * @interface SubmitAssetForReviewResponse
 */
export interface SubmitAssetForReviewResponse {
    /**
     * 
     * @type {string}
     * @memberof SubmitAssetForReviewResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof SubmitAssetForReviewResponse
     */
    assetId?: string;
    /**
     * 
     * @type {ModerationStatus}
     * @memberof SubmitAssetForReviewResponse
     */
    status?: ModerationStatus;
}
/**
 * 
 * @export
 * @interface TraitSignalRequest
 */
export interface TraitSignalRequest {
    /**
     * 
     * @type {string}
     * @memberof TraitSignalRequest
     */
    source: TraitSignalRequest.SourceEnum;
    /**
     * 
     * @type {string}
     * @memberof TraitSignalRequest
     */
    smartAssetId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TraitSignalRequest
     */
    equip?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof TraitSignalRequest
     */
    traitIds: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TraitSignalRequest
     */
    idempotencyKey: string;
    /**
     * 
     * @type {string}
     * @memberof TraitSignalRequest
     */
    experienceId?: string;
}

/**
 * @export
 * @namespace TraitSignalRequest
 */
export namespace TraitSignalRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum SourceEnum {
        EXPMICRO = <any> 'SOURCE_EXP_MICRO',
        EXPCORE = <any> 'SOURCE_EXP_CORE',
        EXPEMOTE = <any> 'SOURCE_EXP_EMOTE',
        EXPSOCIAL = <any> 'SOURCE_EXP_SOCIAL',
        EXPMETA = <any> 'SOURCE_EXP_META',
        EXPCONDITIONLARGE = <any> 'SOURCE_EXP_CONDITION_LARGE',
        EXPCONDITIONMEDIUM = <any> 'SOURCE_EXP_CONDITION_MEDIUM',
        EXPCONDITIONSMALL = <any> 'SOURCE_EXP_CONDITION_SMALL',
        EXPROLE = <any> 'SOURCE_EXP_ROLE',
        SPACEEQUIPWEARABLE = <any> 'SOURCE_SPACE_EQUIP_WEARABLE',
        SPACEEQUIPHANDPROP = <any> 'SOURCE_SPACE_EQUIP_HAND_PROP',
        SPACEEQUIPAVATAR = <any> 'SOURCE_SPACE_EQUIP_AVATAR',
        EXPEQUIPWEARABLE = <any> 'SOURCE_EXP_EQUIP_WEARABLE',
        EXPEQUIPHANDPROP = <any> 'SOURCE_EXP_EQUIP_HAND_PROP',
        EXPEQUIPAVATAR = <any> 'SOURCE_EXP_EQUIP_AVATAR'
    }
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    transactionType?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    spentCurrencyType?: string;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    spentCurrencyAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    purchasedCurrencyType?: string;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    purchasedCurrencyAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    store?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    productId?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    appSku?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface UpdateAssetStatusRequest
 */
export interface UpdateAssetStatusRequest {
    /**
     * 
     * @type {AssetLifecycleStatus}
     * @memberof UpdateAssetStatusRequest
     */
    status: AssetLifecycleStatus;
    /**
     * Optional reason for status change
     * @type {string}
     * @memberof UpdateAssetStatusRequest
     */
    reason?: string;
}
/**
 * Request body for updating an existing custom color preset
 * @export
 * @interface UpdateCustomColorRequest
 */
export interface UpdateCustomColorRequest {
    /**
     * Updated array of hex color values
     * @type {Array<string>}
     * @memberof UpdateCustomColorRequest
     */
    colorsHex?: Array<string>;
    /**
     * Updated display name
     * @type {string}
     * @memberof UpdateCustomColorRequest
     */
    name?: string;
}
/**
 * Represents the updated product
 * @export
 * @interface UpdateHardCurrencyProductBody
 */
export interface UpdateHardCurrencyProductBody {
    /**
     * product sku 
     * @type {string}
     * @memberof UpdateHardCurrencyProductBody
     */
    productSku: string;
    /**
     * amount of hard currency reward 
     * @type {number}
     * @memberof UpdateHardCurrencyProductBody
     */
    amount?: number;
    /**
     * if the product is active or not 
     * @type {boolean}
     * @memberof UpdateHardCurrencyProductBody
     */
    isActive?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateHardCurrencyProductResponse
 */
export interface UpdateHardCurrencyProductResponse {
    /**
     * 
     * @type {string}
     * @memberof UpdateHardCurrencyProductResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHardCurrencyProductResponse
     */
    productSku?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateHardCurrencyProductResponse
     */
    amount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateHardCurrencyProductResponse
     */
    isActive?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateMetadataTagRequest
 */
export interface UpdateMetadataTagRequest {
    /**
     * Updated metadata tag body
     * @type {{ [key: string]: any; }}
     * @memberof UpdateMetadataTagRequest
     */
    body?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface UpdateMetadataTagResponse
 */
export interface UpdateMetadataTagResponse {
    /**
     * Whether the update was successful
     * @type {boolean}
     * @memberof UpdateMetadataTagResponse
     */
    success?: boolean;
    /**
     * 
     * @type {InventoryMetadataTag}
     * @memberof UpdateMetadataTagResponse
     */
    tag?: InventoryMetadataTag;
}
/**
 * 
 * @export
 * @interface UpdateModerationStatusRequest
 */
export interface UpdateModerationStatusRequest {
    /**
     * 
     * @type {ModerationStatus}
     * @memberof UpdateModerationStatusRequest
     */
    status: ModerationStatus;
    /**
     * 
     * @type {ModerationType}
     * @memberof UpdateModerationStatusRequest
     */
    moderationType: ModerationType;
    /**
     * Optional reviewer user ID
     * @type {string}
     * @memberof UpdateModerationStatusRequest
     */
    reviewerUserId?: string;
    /**
     * Optional notes from the reviewer
     * @type {string}
     * @memberof UpdateModerationStatusRequest
     */
    reviewNotes?: string;
}
/**
 * 
 * @export
 * @interface UpdateSoftCurrencyProductRequest
 */
export interface UpdateSoftCurrencyProductRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateSoftCurrencyProductRequest
     */
    currencyId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSoftCurrencyProductRequest
     */
    productSku?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateSoftCurrencyProductRequest
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateSoftCurrencyProductRequest
     */
    hcCost?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSoftCurrencyProductRequest
     */
    isActive?: boolean;
    /**
     * 
     * @type {SoftCurrencyProductMetadata}
     * @memberof UpdateSoftCurrencyProductRequest
     */
    metadata?: SoftCurrencyProductMetadata;
}
/**
 * 
 * @export
 * @interface UpdateSoftCurrencyProductResponse
 */
export interface UpdateSoftCurrencyProductResponse {
    /**
     * 
     * @type {string}
     * @memberof UpdateSoftCurrencyProductResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSoftCurrencyProductResponse
     */
    currencyId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSoftCurrencyProductResponse
     */
    productSku?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateSoftCurrencyProductResponse
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateSoftCurrencyProductResponse
     */
    hcCost?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSoftCurrencyProductResponse
     */
    isActive?: boolean;
}
/**
 * 
 * @export
 * @interface UpsertHardCurrencyProductMetadataRequest
 */
export interface UpsertHardCurrencyProductMetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof UpsertHardCurrencyProductMetadataRequest
     */
    productSku?: string;
    /**
     * 
     * @type {string}
     * @memberof UpsertHardCurrencyProductMetadataRequest
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof UpsertHardCurrencyProductMetadataRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof UpsertHardCurrencyProductMetadataRequest
     */
    iconUrl?: string;
}
/**
 * 
 * @export
 * @interface UpsertHardCurrencyProductMetadataResponse
 */
export interface UpsertHardCurrencyProductMetadataResponse {
    /**
     * 
     * @type {string}
     * @memberof UpsertHardCurrencyProductMetadataResponse
     */
    message?: string;
    /**
     * 
     * @type {HardCurrencyProductMetadata}
     * @memberof UpsertHardCurrencyProductMetadataResponse
     */
    metadata?: HardCurrencyProductMetadata;
    /**
     * 
     * @type {boolean}
     * @memberof UpsertHardCurrencyProductMetadataResponse
     */
    created?: boolean;
}
/**
 * productId and productSku to associate.
 * @export
 * @interface UpsertProductSkuMappingBody
 */
export interface UpsertProductSkuMappingBody {
    /**
     * party id 
     * @type {string}
     * @memberof UpsertProductSkuMappingBody
     */
    partyId: string;
    /**
     * store id 
     * @type {number}
     * @memberof UpsertProductSkuMappingBody
     */
    storeId: number;
    /**
     * platform product id (apple/google) 
     * @type {string}
     * @memberof UpsertProductSkuMappingBody
     */
    productId: string;
    /**
     * genies party product sku 
     * @type {string}
     * @memberof UpsertProductSkuMappingBody
     */
    productSku: string;
}
/**
 * 
 * @export
 * @interface UpsertProductSkuMappingResponse
 */
export interface UpsertProductSkuMappingResponse {
    /**
     * 
     * @type {string}
     * @memberof UpsertProductSkuMappingResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof UpsertProductSkuMappingResponse
     */
    partyId?: string;
    /**
     * 
     * @type {number}
     * @memberof UpsertProductSkuMappingResponse
     */
    storeId?: number;
    /**
     * 
     * @type {string}
     * @memberof UpsertProductSkuMappingResponse
     */
    productId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpsertProductSkuMappingResponse
     */
    productSku?: string;
}
/**
 * 
 * @export
 * @interface UpsertSoftCurrencyRequest
 */
export interface UpsertSoftCurrencyRequest {
    /**
     * 
     * @type {string}
     * @memberof UpsertSoftCurrencyRequest
     */
    currencyId: string;
    /**
     * 
     * @type {string}
     * @memberof UpsertSoftCurrencyRequest
     */
    currencyName: string;
    /**
     * 
     * @type {string}
     * @memberof UpsertSoftCurrencyRequest
     */
    ownerId: string;
    /**
     * 
     * @type {string}
     * @memberof UpsertSoftCurrencyRequest
     */
    ownerType: string;
    /**
     * 
     * @type {string}
     * @memberof UpsertSoftCurrencyRequest
     */
    currencyIconUrl?: string;
}
/**
 * 
 * @export
 * @interface UpsertSoftCurrencyResponse
 */
export interface UpsertSoftCurrencyResponse {
    /**
     * 
     * @type {string}
     * @memberof UpsertSoftCurrencyResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof UpsertSoftCurrencyResponse
     */
    currencyId?: string;
}
/**
 * 
 * @export
 * @interface UserAvatarInventoryAsset
 */
export interface UserAvatarInventoryAsset extends BaseInventoryAsset {
    /**
     * Type of avatar model
     * @type {string}
     * @memberof UserAvatarInventoryAsset
     */
    modelType?: string;
}

/**
 * @export
 * @namespace UserAvatarInventoryAsset
 */
export namespace UserAvatarInventoryAsset {
}
/**
 * 
 * @export
 * @interface UserAvatarInventoryAssetInstance
 */
export interface UserAvatarInventoryAssetInstance extends BaseInventoryAssetInstance {
    /**
     * 
     * @type {UserAvatarInventoryAsset}
     * @memberof UserAvatarInventoryAssetInstance
     */
    asset?: UserAvatarInventoryAsset;
}
/**
 * Representation of the properties to update a user with store items
 * @export
 * @interface UserStoreItemUpdates
 */
export interface UserStoreItemUpdates {
    /**
     * Operation to perform for this specified object
     * @type {string}
     * @memberof UserStoreItemUpdates
     */
    operation?: UserStoreItemUpdates.OperationEnum;
    /**
     * Unique identifier that all of the store items belong to
     * @type {string}
     * @memberof UserStoreItemUpdates
     */
    storeId?: string;
    /**
     * 
     * @type {Array<StoreItemUpdate>}
     * @memberof UserStoreItemUpdates
     */
    items?: Array<StoreItemUpdate>;
}

/**
 * @export
 * @namespace UserStoreItemUpdates
 */
export namespace UserStoreItemUpdates {
    /**
     * @export
     * @enum {string}
     */
    export enum OperationEnum {
        ADD = <any> 'ADD',
        REMOVE = <any> 'REMOVE'
    }
}
/**
 * 
 * @export
 * @interface UserTraitsUpdate
 */
export interface UserTraitsUpdate {
    /**
     * 
     * @type {Array<UserTraitsUpdateTraits>}
     * @memberof UserTraitsUpdate
     */
    traits?: Array<UserTraitsUpdateTraits>;
}
/**
 * 
 * @export
 * @interface UserTraitsUpdateTraits
 */
export interface UserTraitsUpdateTraits {
    /**
     * 
     * @type {string}
     * @memberof UserTraitsUpdateTraits
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTraitsUpdateTraits
     */
    size?: UserTraitsUpdateTraits.SizeEnum;
}

/**
 * @export
 * @namespace UserTraitsUpdateTraits
 */
export namespace UserTraitsUpdateTraits {
    /**
     * @export
     * @enum {string}
     */
    export enum SizeEnum {
        S = <any> 'S',
        M = <any> 'M',
        L = <any> 'L'
    }
}
/**
 * 
 * @export
 * @interface VersionableInventoryAsset
 */
export interface VersionableInventoryAsset extends BaseInventoryAsset {
    /**
     * Pipeline information for the asset (V2 format with string versions and pipeline ID)
     * @type {Array<PipelineItemV2>}
     * @memberof VersionableInventoryAsset
     */
    pipeline?: Array<PipelineItemV2>;
}

/**
 * @export
 * @namespace VersionableInventoryAsset
 */
export namespace VersionableInventoryAsset {
}
/**
 * 
 * @export
 * @interface Wallet
 */
export interface Wallet {
    /**
     * 
     * @type {string}
     * @memberof Wallet
     */
    ID?: string;
    /**
     * 
     * @type {string}
     * @memberof Wallet
     */
    currencyID?: string;
    /**
     * 
     * @type {number}
     * @memberof Wallet
     */
    balance?: number;
    /**
     * 
     * @type {string}
     * @memberof Wallet
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Wallet
     */
    updatedAt?: string;
}
/**
 * AdminTraitsApi - fetch parameter creator
 * @export
 */
export const AdminTraitsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the traits status and other metadata (devkit where only developers will be able to access this). From shim API with trait service using devkit swaggerhub.
         * @param {string} userId UserId who will receive the items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTraitStatus(userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getTraitStatus.');
            }
            const localVarPath = `/admin/user/{userId}/trait/status`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resets the user's macro profile
         * @param {string} userId userId of the trait to set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetScore(userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling resetScore.');
            }
            const localVarPath = `/admin/user/{userId}/trait`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set score for a traitId
         * @param {string} userId userId of the trait to set
         * @param {AdminSetTraitScoreRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTraitScore(userId: string, body?: AdminSetTraitScoreRequest, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling setTraitScore.');
            }
            const localVarPath = `/admin/user/{userId}/trait`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AdminSetTraitScoreRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminTraitsApi - functional programming interface
 * @export
 */
export const AdminTraitsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the traits status and other metadata (devkit where only developers will be able to access this). From shim API with trait service using devkit swaggerhub.
         * @param {string} userId UserId who will receive the items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTraitStatus(userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AdminGetTraitStatusResponse> {
            const localVarFetchArgs = AdminTraitsApiFetchParamCreator(configuration).getTraitStatus(userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Resets the user's macro profile
         * @param {string} userId userId of the trait to set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetScore(userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
            const localVarFetchArgs = AdminTraitsApiFetchParamCreator(configuration).resetScore(userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set score for a traitId
         * @param {string} userId userId of the trait to set
         * @param {AdminSetTraitScoreRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTraitScore(userId: string, body?: AdminSetTraitScoreRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
            const localVarFetchArgs = AdminTraitsApiFetchParamCreator(configuration).setTraitScore(userId, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AdminTraitsApi - factory interface
 * @export
 */
export const AdminTraitsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the traits status and other metadata (devkit where only developers will be able to access this). From shim API with trait service using devkit swaggerhub.
         * @param {string} userId UserId who will receive the items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTraitStatus(userId: string, options?: any) {
            return AdminTraitsApiFp(configuration).getTraitStatus(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Resets the user's macro profile
         * @param {string} userId userId of the trait to set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetScore(userId: string, options?: any) {
            return AdminTraitsApiFp(configuration).resetScore(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set score for a traitId
         * @param {string} userId userId of the trait to set
         * @param {AdminSetTraitScoreRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTraitScore(userId: string, body?: AdminSetTraitScoreRequest, options?: any) {
            return AdminTraitsApiFp(configuration).setTraitScore(userId, body, options)(fetch, basePath);
        },
    };
};

/**
 * AdminTraitsApi - object-oriented interface
 * @export
 * @class AdminTraitsApi
 * @extends {BaseAPI}
 */
export class AdminTraitsApi extends BaseAPI {
    /**
     * 
     * @summary Get the traits status and other metadata (devkit where only developers will be able to access this). From shim API with trait service using devkit swaggerhub.
     * @param {string} userId UserId who will receive the items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminTraitsApi
     */
    public getTraitStatus(userId: string, options?: any) {
        return AdminTraitsApiFp(this.configuration).getTraitStatus(userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Resets the user's macro profile
     * @param {string} userId userId of the trait to set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminTraitsApi
     */
    public resetScore(userId: string, options?: any) {
        return AdminTraitsApiFp(this.configuration).resetScore(userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set score for a traitId
     * @param {string} userId userId of the trait to set
     * @param {AdminSetTraitScoreRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminTraitsApi
     */
    public setTraitScore(userId: string, body?: AdminSetTraitScoreRequest, options?: any) {
        return AdminTraitsApiFp(this.configuration).setTraitScore(userId, body, options)(this.fetch, this.basePath);
    }

}
/**
 * AvatarEditorApi - fetch parameter creator
 * @export
 */
export const AvatarEditorApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new user-generated custom color preset for hair, skin, or flair. The color will be associated with the user and can be used in avatar customization.
         * @summary Create a new custom color preset
         * @param {CreateCustomColorRequest} body 
         * @param {string} userId User ID who owns the custom color
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomColor(body: CreateCustomColorRequest, userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCustomColor.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling createCustomColor.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/custom-colors`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateCustomColorRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a custom color preset. Only the owner can delete their custom colors.
         * @summary Delete a custom color
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomColor(userId: string, instanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteCustomColor.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling deleteCustomColor.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/custom-colors/{instanceId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of a specific custom color preset by its instance ID.
         * @summary Get a specific custom color by ID
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomColor(userId: string, instanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getCustomColor.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling getCustomColor.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/custom-colors/{instanceId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default animation library assets including gestures, expressions, and movements for avatar animation
         * @summary Get default animation library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
         * @param {Array<string>} [color] Filter by animation theme color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAnimationLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/animation-library`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default base customization items for avatar editor like hairstyles, facial features, and body characteristics
         * @summary Get default base avatar customization assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
         * @param {Array<string>} [color] Filter by base color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarBase(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/avatar/base`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default avatar eye assets like eye colors, styles, and expressions
         * @summary Get default eye avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
         * @param {Array<string>} [color] Filter by eye color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarEyes(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/avatar/eyes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
         * @summary Get default flair avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
         * @param {Array<string>} [color] Filter by flair color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarFlair(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/avatar/flair`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
         * @summary Get default makeup avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
         * @param {Array<string>} [color] Filter by makeup color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarMakeup(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/avatar/makeup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default color preset assets that provide predefined color combinations and palettes for avatar customization
         * @summary Get default color preset assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
         * @param {Array<string>} [color] Filter by dominant color in preset
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultColorPresets(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/color-presets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default image library assets including textures, patterns, and images used for avatar customization
         * @summary Get default image library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
         * @param {Array<string>} [color] Filter by dominant color in image
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultImageLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/image-library`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
         * @summary Get default model library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
         * @param {Array<string>} [color] Filter by model color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultModelLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/model-library`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns animation library assets including gestures, expressions, and movements for avatar animation
         * @summary Get animation library assets for a user
         * @param {string} userId The ID of the user whose animation library assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by animation theme color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AnimationLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2AnimationLibrary.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/animation-library`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns avatar base customization items like hairstyles, facial features, and body characteristics
         * @summary Get base avatar customization assets for a user
         * @param {string} userId The ID of the user whose base customization assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by base color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarBase(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2AvatarBase.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/avatar/base`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns avatar eye assets like eye colors, styles, and expressions
         * @summary Get eye avatar assets for a user
         * @param {string} userId The ID of the user whose eye assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by eye color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarEyes(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2AvatarEyes.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/avatar/eyes`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
         * @summary Get flair avatar assets for a user
         * @param {string} userId The ID of the user whose flair assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by flair color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarFlair(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2AvatarFlair.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/avatar/flair`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
         * @summary Get makeup avatar assets for a user
         * @param {string} userId The ID of the user whose makeup assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by makeup color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarMakeup(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2AvatarMakeup.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/avatar/makeup`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns color preset assets that provide predefined color combinations and palettes for avatar customization
         * @summary Get color preset assets for a user
         * @param {string} userId The ID of the user whose color preset assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by dominant color in preset
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2ColorPresets(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2ColorPresets.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/color-presets`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns image library assets including textures, patterns, and images used for avatar customization
         * @summary Get image library assets for a user
         * @param {string} userId The ID of the user whose image library assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by dominant color in image
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2ImageLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2ImageLibrary.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/image-library`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
         * @summary Get model library assets for a user
         * @param {string} userId The ID of the user whose model library assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by model color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2ModelLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2ModelLibrary.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/model-library`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all custom color presets created by the user. Supports filtering by category, app ID, and org ID.
         * @summary List all custom colors for a user
         * @param {string} userId User ID who owns the custom colors
         * @param {string} [category] Filter by category (hair, skin, or flair)
         * @param {string} [appId] Application ID to filter custom colors
         * @param {string} [orgId] Organization ID to filter custom colors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomColors(userId: string, category?: string, appId?: string, orgId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling listCustomColors.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/custom-colors`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the colors or name of an existing custom color preset. Only the owner can update their custom colors.
         * @summary Update a custom color
         * @param {UpdateCustomColorRequest} body 
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomColor(body: UpdateCustomColorRequest, userId: string, instanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateCustomColor.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateCustomColor.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling updateCustomColor.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/custom-colors/{instanceId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateCustomColorRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AvatarEditorApi - functional programming interface
 * @export
 */
export const AvatarEditorApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new user-generated custom color preset for hair, skin, or flair. The color will be associated with the user and can be used in avatar customization.
         * @summary Create a new custom color preset
         * @param {CreateCustomColorRequest} body 
         * @param {string} userId User ID who owns the custom color
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomColor(body: CreateCustomColorRequest, userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomColorResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).createCustomColor(body, userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a custom color preset. Only the owner can delete their custom colors.
         * @summary Delete a custom color
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomColor(userId: string, instanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteCustomColorResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).deleteCustomColor(userId, instanceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns details of a specific custom color preset by its instance ID.
         * @summary Get a specific custom color by ID
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomColor(userId: string, instanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomColorResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).getCustomColor(userId, instanceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default animation library assets including gestures, expressions, and movements for avatar animation
         * @summary Get default animation library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
         * @param {Array<string>} [color] Filter by animation theme color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAnimationLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AnimationLibraryResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).getDefaultAnimationLibrary(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default base customization items for avatar editor like hairstyles, facial features, and body characteristics
         * @summary Get default base avatar customization assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
         * @param {Array<string>} [color] Filter by base color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarBase(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarBaseResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).getDefaultAvatarBase(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default avatar eye assets like eye colors, styles, and expressions
         * @summary Get default eye avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
         * @param {Array<string>} [color] Filter by eye color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarEyes(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarEyesResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).getDefaultAvatarEyes(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
         * @summary Get default flair avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
         * @param {Array<string>} [color] Filter by flair color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarFlair(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarFlairResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).getDefaultAvatarFlair(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
         * @summary Get default makeup avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
         * @param {Array<string>} [color] Filter by makeup color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarMakeup(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarMakeupResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).getDefaultAvatarMakeup(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default color preset assets that provide predefined color combinations and palettes for avatar customization
         * @summary Get default color preset assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
         * @param {Array<string>} [color] Filter by dominant color in preset
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultColorPresets(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2ColorPresetsResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).getDefaultColorPresets(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default image library assets including textures, patterns, and images used for avatar customization
         * @summary Get default image library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
         * @param {Array<string>} [color] Filter by dominant color in image
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultImageLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2ImageLibraryResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).getDefaultImageLibrary(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
         * @summary Get default model library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
         * @param {Array<string>} [color] Filter by model color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultModelLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2ModelLibraryResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).getDefaultModelLibrary(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns animation library assets including gestures, expressions, and movements for avatar animation
         * @summary Get animation library assets for a user
         * @param {string} userId The ID of the user whose animation library assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by animation theme color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AnimationLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AnimationLibraryResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).getInventoryV2AnimationLibrary(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns avatar base customization items like hairstyles, facial features, and body characteristics
         * @summary Get base avatar customization assets for a user
         * @param {string} userId The ID of the user whose base customization assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by base color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarBase(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarBaseResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).getInventoryV2AvatarBase(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns avatar eye assets like eye colors, styles, and expressions
         * @summary Get eye avatar assets for a user
         * @param {string} userId The ID of the user whose eye assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by eye color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarEyes(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarEyesResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).getInventoryV2AvatarEyes(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
         * @summary Get flair avatar assets for a user
         * @param {string} userId The ID of the user whose flair assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by flair color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarFlair(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarFlairResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).getInventoryV2AvatarFlair(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
         * @summary Get makeup avatar assets for a user
         * @param {string} userId The ID of the user whose makeup assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by makeup color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarMakeup(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarMakeupResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).getInventoryV2AvatarMakeup(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns color preset assets that provide predefined color combinations and palettes for avatar customization
         * @summary Get color preset assets for a user
         * @param {string} userId The ID of the user whose color preset assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by dominant color in preset
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2ColorPresets(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2ColorPresetsResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).getInventoryV2ColorPresets(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns image library assets including textures, patterns, and images used for avatar customization
         * @summary Get image library assets for a user
         * @param {string} userId The ID of the user whose image library assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by dominant color in image
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2ImageLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2ImageLibraryResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).getInventoryV2ImageLibrary(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
         * @summary Get model library assets for a user
         * @param {string} userId The ID of the user whose model library assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by model color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2ModelLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2ModelLibraryResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).getInventoryV2ModelLibrary(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all custom color presets created by the user. Supports filtering by category, app ID, and org ID.
         * @summary List all custom colors for a user
         * @param {string} userId User ID who owns the custom colors
         * @param {string} [category] Filter by category (hair, skin, or flair)
         * @param {string} [appId] Application ID to filter custom colors
         * @param {string} [orgId] Organization ID to filter custom colors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomColors(userId: string, category?: string, appId?: string, orgId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListCustomColorsResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).listCustomColors(userId, category, appId, orgId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the colors or name of an existing custom color preset. Only the owner can update their custom colors.
         * @summary Update a custom color
         * @param {UpdateCustomColorRequest} body 
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomColor(body: UpdateCustomColorRequest, userId: string, instanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomColorResponse> {
            const localVarFetchArgs = AvatarEditorApiFetchParamCreator(configuration).updateCustomColor(body, userId, instanceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AvatarEditorApi - factory interface
 * @export
 */
export const AvatarEditorApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a new user-generated custom color preset for hair, skin, or flair. The color will be associated with the user and can be used in avatar customization.
         * @summary Create a new custom color preset
         * @param {CreateCustomColorRequest} body 
         * @param {string} userId User ID who owns the custom color
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomColor(body: CreateCustomColorRequest, userId: string, options?: any) {
            return AvatarEditorApiFp(configuration).createCustomColor(body, userId, options)(fetch, basePath);
        },
        /**
         * Deletes a custom color preset. Only the owner can delete their custom colors.
         * @summary Delete a custom color
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomColor(userId: string, instanceId: string, options?: any) {
            return AvatarEditorApiFp(configuration).deleteCustomColor(userId, instanceId, options)(fetch, basePath);
        },
        /**
         * Returns details of a specific custom color preset by its instance ID.
         * @summary Get a specific custom color by ID
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomColor(userId: string, instanceId: string, options?: any) {
            return AvatarEditorApiFp(configuration).getCustomColor(userId, instanceId, options)(fetch, basePath);
        },
        /**
         * Returns default animation library assets including gestures, expressions, and movements for avatar animation
         * @summary Get default animation library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
         * @param {Array<string>} [color] Filter by animation theme color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAnimationLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return AvatarEditorApiFp(configuration).getDefaultAnimationLibrary(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default base customization items for avatar editor like hairstyles, facial features, and body characteristics
         * @summary Get default base avatar customization assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
         * @param {Array<string>} [color] Filter by base color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarBase(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return AvatarEditorApiFp(configuration).getDefaultAvatarBase(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default avatar eye assets like eye colors, styles, and expressions
         * @summary Get default eye avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
         * @param {Array<string>} [color] Filter by eye color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarEyes(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return AvatarEditorApiFp(configuration).getDefaultAvatarEyes(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
         * @summary Get default flair avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
         * @param {Array<string>} [color] Filter by flair color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarFlair(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return AvatarEditorApiFp(configuration).getDefaultAvatarFlair(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
         * @summary Get default makeup avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
         * @param {Array<string>} [color] Filter by makeup color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarMakeup(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return AvatarEditorApiFp(configuration).getDefaultAvatarMakeup(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default color preset assets that provide predefined color combinations and palettes for avatar customization
         * @summary Get default color preset assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
         * @param {Array<string>} [color] Filter by dominant color in preset
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultColorPresets(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return AvatarEditorApiFp(configuration).getDefaultColorPresets(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default image library assets including textures, patterns, and images used for avatar customization
         * @summary Get default image library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
         * @param {Array<string>} [color] Filter by dominant color in image
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultImageLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return AvatarEditorApiFp(configuration).getDefaultImageLibrary(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
         * @summary Get default model library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
         * @param {Array<string>} [color] Filter by model color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultModelLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return AvatarEditorApiFp(configuration).getDefaultModelLibrary(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns animation library assets including gestures, expressions, and movements for avatar animation
         * @summary Get animation library assets for a user
         * @param {string} userId The ID of the user whose animation library assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by animation theme color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AnimationLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return AvatarEditorApiFp(configuration).getInventoryV2AnimationLibrary(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns avatar base customization items like hairstyles, facial features, and body characteristics
         * @summary Get base avatar customization assets for a user
         * @param {string} userId The ID of the user whose base customization assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by base color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarBase(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return AvatarEditorApiFp(configuration).getInventoryV2AvatarBase(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns avatar eye assets like eye colors, styles, and expressions
         * @summary Get eye avatar assets for a user
         * @param {string} userId The ID of the user whose eye assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by eye color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarEyes(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return AvatarEditorApiFp(configuration).getInventoryV2AvatarEyes(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
         * @summary Get flair avatar assets for a user
         * @param {string} userId The ID of the user whose flair assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by flair color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarFlair(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return AvatarEditorApiFp(configuration).getInventoryV2AvatarFlair(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
         * @summary Get makeup avatar assets for a user
         * @param {string} userId The ID of the user whose makeup assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by makeup color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarMakeup(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return AvatarEditorApiFp(configuration).getInventoryV2AvatarMakeup(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns color preset assets that provide predefined color combinations and palettes for avatar customization
         * @summary Get color preset assets for a user
         * @param {string} userId The ID of the user whose color preset assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by dominant color in preset
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2ColorPresets(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return AvatarEditorApiFp(configuration).getInventoryV2ColorPresets(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns image library assets including textures, patterns, and images used for avatar customization
         * @summary Get image library assets for a user
         * @param {string} userId The ID of the user whose image library assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by dominant color in image
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2ImageLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return AvatarEditorApiFp(configuration).getInventoryV2ImageLibrary(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns all model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
         * @summary Get model library assets for a user
         * @param {string} userId The ID of the user whose model library assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by model color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2ModelLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return AvatarEditorApiFp(configuration).getInventoryV2ModelLibrary(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns all custom color presets created by the user. Supports filtering by category, app ID, and org ID.
         * @summary List all custom colors for a user
         * @param {string} userId User ID who owns the custom colors
         * @param {string} [category] Filter by category (hair, skin, or flair)
         * @param {string} [appId] Application ID to filter custom colors
         * @param {string} [orgId] Organization ID to filter custom colors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomColors(userId: string, category?: string, appId?: string, orgId?: string, options?: any) {
            return AvatarEditorApiFp(configuration).listCustomColors(userId, category, appId, orgId, options)(fetch, basePath);
        },
        /**
         * Updates the colors or name of an existing custom color preset. Only the owner can update their custom colors.
         * @summary Update a custom color
         * @param {UpdateCustomColorRequest} body 
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomColor(body: UpdateCustomColorRequest, userId: string, instanceId: string, options?: any) {
            return AvatarEditorApiFp(configuration).updateCustomColor(body, userId, instanceId, options)(fetch, basePath);
        },
    };
};

/**
 * AvatarEditorApi - object-oriented interface
 * @export
 * @class AvatarEditorApi
 * @extends {BaseAPI}
 */
export class AvatarEditorApi extends BaseAPI {
    /**
     * Creates a new user-generated custom color preset for hair, skin, or flair. The color will be associated with the user and can be used in avatar customization.
     * @summary Create a new custom color preset
     * @param {CreateCustomColorRequest} body 
     * @param {string} userId User ID who owns the custom color
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public createCustomColor(body: CreateCustomColorRequest, userId: string, options?: any) {
        return AvatarEditorApiFp(this.configuration).createCustomColor(body, userId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a custom color preset. Only the owner can delete their custom colors.
     * @summary Delete a custom color
     * @param {string} userId User ID who owns the custom color
     * @param {string} instanceId Instance ID of the custom color to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public deleteCustomColor(userId: string, instanceId: string, options?: any) {
        return AvatarEditorApiFp(this.configuration).deleteCustomColor(userId, instanceId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns details of a specific custom color preset by its instance ID.
     * @summary Get a specific custom color by ID
     * @param {string} userId User ID who owns the custom color
     * @param {string} instanceId Instance ID of the custom color
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public getCustomColor(userId: string, instanceId: string, options?: any) {
        return AvatarEditorApiFp(this.configuration).getCustomColor(userId, instanceId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default animation library assets including gestures, expressions, and movements for avatar animation
     * @summary Get default animation library assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
     * @param {Array<string>} [color] Filter by animation theme color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public getDefaultAnimationLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return AvatarEditorApiFp(this.configuration).getDefaultAnimationLibrary(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default base customization items for avatar editor like hairstyles, facial features, and body characteristics
     * @summary Get default base avatar customization assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
     * @param {Array<string>} [color] Filter by base color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public getDefaultAvatarBase(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return AvatarEditorApiFp(this.configuration).getDefaultAvatarBase(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default avatar eye assets like eye colors, styles, and expressions
     * @summary Get default eye avatar assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
     * @param {Array<string>} [color] Filter by eye color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public getDefaultAvatarEyes(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return AvatarEditorApiFp(this.configuration).getDefaultAvatarEyes(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
     * @summary Get default flair avatar assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
     * @param {Array<string>} [color] Filter by flair color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public getDefaultAvatarFlair(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return AvatarEditorApiFp(this.configuration).getDefaultAvatarFlair(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
     * @summary Get default makeup avatar assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
     * @param {Array<string>} [color] Filter by makeup color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public getDefaultAvatarMakeup(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return AvatarEditorApiFp(this.configuration).getDefaultAvatarMakeup(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default color preset assets that provide predefined color combinations and palettes for avatar customization
     * @summary Get default color preset assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
     * @param {Array<string>} [color] Filter by dominant color in preset
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public getDefaultColorPresets(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return AvatarEditorApiFp(this.configuration).getDefaultColorPresets(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default image library assets including textures, patterns, and images used for avatar customization
     * @summary Get default image library assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
     * @param {Array<string>} [color] Filter by dominant color in image
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public getDefaultImageLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return AvatarEditorApiFp(this.configuration).getDefaultImageLibrary(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
     * @summary Get default model library assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
     * @param {Array<string>} [color] Filter by model color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public getDefaultModelLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return AvatarEditorApiFp(this.configuration).getDefaultModelLibrary(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns animation library assets including gestures, expressions, and movements for avatar animation
     * @summary Get animation library assets for a user
     * @param {string} userId The ID of the user whose animation library assets to retrieve
     * @param {string} [appId] Application ID to filter inventory items
     * @param {string} [orgId] Organization ID to filter inventory items
     * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
     * @param {Array<string>} [subcategory] Filter by item subcategory
     * @param {Array<string>} [color] Filter by animation theme color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public getInventoryV2AnimationLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return AvatarEditorApiFp(this.configuration).getInventoryV2AnimationLibrary(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns avatar base customization items like hairstyles, facial features, and body characteristics
     * @summary Get base avatar customization assets for a user
     * @param {string} userId The ID of the user whose base customization assets to retrieve
     * @param {string} [appId] Application ID to filter inventory items
     * @param {string} [orgId] Organization ID to filter inventory items
     * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
     * @param {Array<string>} [subcategory] Filter by item subcategory
     * @param {Array<string>} [color] Filter by base color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public getInventoryV2AvatarBase(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return AvatarEditorApiFp(this.configuration).getInventoryV2AvatarBase(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns avatar eye assets like eye colors, styles, and expressions
     * @summary Get eye avatar assets for a user
     * @param {string} userId The ID of the user whose eye assets to retrieve
     * @param {string} [appId] Application ID to filter inventory items
     * @param {string} [orgId] Organization ID to filter inventory items
     * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
     * @param {Array<string>} [subcategory] Filter by item subcategory
     * @param {Array<string>} [color] Filter by eye color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public getInventoryV2AvatarEyes(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return AvatarEditorApiFp(this.configuration).getInventoryV2AvatarEyes(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
     * @summary Get flair avatar assets for a user
     * @param {string} userId The ID of the user whose flair assets to retrieve
     * @param {string} [appId] Application ID to filter inventory items
     * @param {string} [orgId] Organization ID to filter inventory items
     * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
     * @param {Array<string>} [subcategory] Filter by item subcategory
     * @param {Array<string>} [color] Filter by flair color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public getInventoryV2AvatarFlair(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return AvatarEditorApiFp(this.configuration).getInventoryV2AvatarFlair(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
     * @summary Get makeup avatar assets for a user
     * @param {string} userId The ID of the user whose makeup assets to retrieve
     * @param {string} [appId] Application ID to filter inventory items
     * @param {string} [orgId] Organization ID to filter inventory items
     * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
     * @param {Array<string>} [subcategory] Filter by item subcategory
     * @param {Array<string>} [color] Filter by makeup color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public getInventoryV2AvatarMakeup(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return AvatarEditorApiFp(this.configuration).getInventoryV2AvatarMakeup(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns color preset assets that provide predefined color combinations and palettes for avatar customization
     * @summary Get color preset assets for a user
     * @param {string} userId The ID of the user whose color preset assets to retrieve
     * @param {string} [appId] Application ID to filter inventory items
     * @param {string} [orgId] Organization ID to filter inventory items
     * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
     * @param {Array<string>} [subcategory] Filter by item subcategory
     * @param {Array<string>} [color] Filter by dominant color in preset
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public getInventoryV2ColorPresets(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return AvatarEditorApiFp(this.configuration).getInventoryV2ColorPresets(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns image library assets including textures, patterns, and images used for avatar customization
     * @summary Get image library assets for a user
     * @param {string} userId The ID of the user whose image library assets to retrieve
     * @param {string} [appId] Application ID to filter inventory items
     * @param {string} [orgId] Organization ID to filter inventory items
     * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
     * @param {Array<string>} [subcategory] Filter by item subcategory
     * @param {Array<string>} [color] Filter by dominant color in image
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public getInventoryV2ImageLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return AvatarEditorApiFp(this.configuration).getInventoryV2ImageLibrary(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
     * @summary Get model library assets for a user
     * @param {string} userId The ID of the user whose model library assets to retrieve
     * @param {string} [appId] Application ID to filter inventory items
     * @param {string} [orgId] Organization ID to filter inventory items
     * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
     * @param {Array<string>} [subcategory] Filter by item subcategory
     * @param {Array<string>} [color] Filter by model color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public getInventoryV2ModelLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return AvatarEditorApiFp(this.configuration).getInventoryV2ModelLibrary(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all custom color presets created by the user. Supports filtering by category, app ID, and org ID.
     * @summary List all custom colors for a user
     * @param {string} userId User ID who owns the custom colors
     * @param {string} [category] Filter by category (hair, skin, or flair)
     * @param {string} [appId] Application ID to filter custom colors
     * @param {string} [orgId] Organization ID to filter custom colors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public listCustomColors(userId: string, category?: string, appId?: string, orgId?: string, options?: any) {
        return AvatarEditorApiFp(this.configuration).listCustomColors(userId, category, appId, orgId, options)(this.fetch, this.basePath);
    }

    /**
     * Updates the colors or name of an existing custom color preset. Only the owner can update their custom colors.
     * @summary Update a custom color
     * @param {UpdateCustomColorRequest} body 
     * @param {string} userId User ID who owns the custom color
     * @param {string} instanceId Instance ID of the custom color to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarEditorApi
     */
    public updateCustomColor(body: UpdateCustomColorRequest, userId: string, instanceId: string, options?: any) {
        return AvatarEditorApiFp(this.configuration).updateCustomColor(body, userId, instanceId, options)(this.fetch, this.basePath);
    }

}
/**
 * CloudsaveApi - fetch parameter creator
 * @export
 */
export const CloudsaveApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Admin create cloud save for user
         * @param {AdminCloudSaveCreateRequest} body Create cloud save
         * @param {string} experienceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateCloudSave(body: AdminCloudSaveCreateRequest, experienceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling adminCreateCloudSave.');
            }
            // verify required parameter 'experienceId' is not null or undefined
            if (experienceId === null || experienceId === undefined) {
                throw new RequiredError('experienceId','Required parameter experienceId was null or undefined when calling adminCreateCloudSave.');
            }
            const localVarPath = `/admin/cloud-save/{experienceId}`
                .replace(`{${"experienceId"}}`, encodeURIComponent(String(experienceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AdminCloudSaveCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Admin delete cloud save
         * @param {string} experienceId 
         * @param {string} instanceId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteCloudSave(experienceId: string, instanceId: string, userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'experienceId' is not null or undefined
            if (experienceId === null || experienceId === undefined) {
                throw new RequiredError('experienceId','Required parameter experienceId was null or undefined when calling adminDeleteCloudSave.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling adminDeleteCloudSave.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling adminDeleteCloudSave.');
            }
            const localVarPath = `/admin/cloud-save/{experienceId}/{instanceId}`
                .replace(`{${"experienceId"}}`, encodeURIComponent(String(experienceId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Admin get private cloud save
         * @param {string} experienceId 
         * @param {string} instanceId 
         * @param {string} userId id of the user whose cloud save the admin wants to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetCloudSave(experienceId: string, instanceId: string, userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'experienceId' is not null or undefined
            if (experienceId === null || experienceId === undefined) {
                throw new RequiredError('experienceId','Required parameter experienceId was null or undefined when calling adminGetCloudSave.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling adminGetCloudSave.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling adminGetCloudSave.');
            }
            const localVarPath = `/admin/cloud-save/{experienceId}/{instanceId}`
                .replace(`{${"experienceId"}}`, encodeURIComponent(String(experienceId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Admin update cloud save
         * @param {AdminCloudSaveUpdateRequest} body Admin update cloud save
         * @param {string} experienceId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateCloudSave(body: AdminCloudSaveUpdateRequest, experienceId: string, instanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling adminUpdateCloudSave.');
            }
            // verify required parameter 'experienceId' is not null or undefined
            if (experienceId === null || experienceId === undefined) {
                throw new RequiredError('experienceId','Required parameter experienceId was null or undefined when calling adminUpdateCloudSave.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling adminUpdateCloudSave.');
            }
            const localVarPath = `/admin/cloud-save/{experienceId}/{instanceId}`
                .replace(`{${"experienceId"}}`, encodeURIComponent(String(experienceId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AdminCloudSaveUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Internal create cloud save
         * @param {CloudSaveCreateRequest} body Create cloud save
         * @param {string} experienceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalCreateCloudSave(body: CloudSaveCreateRequest, experienceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling internalCreateCloudSave.');
            }
            // verify required parameter 'experienceId' is not null or undefined
            if (experienceId === null || experienceId === undefined) {
                throw new RequiredError('experienceId','Required parameter experienceId was null or undefined when calling internalCreateCloudSave.');
            }
            const localVarPath = `/internal/cloud-save/{experienceId}`
                .replace(`{${"experienceId"}}`, encodeURIComponent(String(experienceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CloudSaveCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Internal delete cloud save
         * @param {string} experienceId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalDeleteCloudSave(experienceId: string, instanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'experienceId' is not null or undefined
            if (experienceId === null || experienceId === undefined) {
                throw new RequiredError('experienceId','Required parameter experienceId was null or undefined when calling internalDeleteCloudSave.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling internalDeleteCloudSave.');
            }
            const localVarPath = `/internal/cloud-save/{experienceId}/{instanceId}`
                .replace(`{${"experienceId"}}`, encodeURIComponent(String(experienceId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Internal get cloud save
         * @param {string} experienceId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalGetCloudSave(experienceId: string, instanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'experienceId' is not null or undefined
            if (experienceId === null || experienceId === undefined) {
                throw new RequiredError('experienceId','Required parameter experienceId was null or undefined when calling internalGetCloudSave.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling internalGetCloudSave.');
            }
            const localVarPath = `/internal/cloud-save/{experienceId}/{instanceId}`
                .replace(`{${"experienceId"}}`, encodeURIComponent(String(experienceId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Internal update cloud save
         * @param {CloudSaveUpdateRequest} body Admin update cloud save
         * @param {string} experienceId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalUpdateCloudSave(body: CloudSaveUpdateRequest, experienceId: string, instanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling internalUpdateCloudSave.');
            }
            // verify required parameter 'experienceId' is not null or undefined
            if (experienceId === null || experienceId === undefined) {
                throw new RequiredError('experienceId','Required parameter experienceId was null or undefined when calling internalUpdateCloudSave.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling internalUpdateCloudSave.');
            }
            const localVarPath = `/internal/cloud-save/{experienceId}/{instanceId}`
                .replace(`{${"experienceId"}}`, encodeURIComponent(String(experienceId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CloudSaveUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudsaveApi - functional programming interface
 * @export
 */
export const CloudsaveApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Admin create cloud save for user
         * @param {AdminCloudSaveCreateRequest} body Create cloud save
         * @param {string} experienceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateCloudSave(body: AdminCloudSaveCreateRequest, experienceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
            const localVarFetchArgs = CloudsaveApiFetchParamCreator(configuration).adminCreateCloudSave(body, experienceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Admin delete cloud save
         * @param {string} experienceId 
         * @param {string} instanceId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteCloudSave(experienceId: string, instanceId: string, userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
            const localVarFetchArgs = CloudsaveApiFetchParamCreator(configuration).adminDeleteCloudSave(experienceId, instanceId, userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Admin get private cloud save
         * @param {string} experienceId 
         * @param {string} instanceId 
         * @param {string} userId id of the user whose cloud save the admin wants to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetCloudSave(experienceId: string, instanceId: string, userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CloudSaveGetResponse> {
            const localVarFetchArgs = CloudsaveApiFetchParamCreator(configuration).adminGetCloudSave(experienceId, instanceId, userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Admin update cloud save
         * @param {AdminCloudSaveUpdateRequest} body Admin update cloud save
         * @param {string} experienceId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateCloudSave(body: AdminCloudSaveUpdateRequest, experienceId: string, instanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CloudSaveUpdateResponse> {
            const localVarFetchArgs = CloudsaveApiFetchParamCreator(configuration).adminUpdateCloudSave(body, experienceId, instanceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Internal create cloud save
         * @param {CloudSaveCreateRequest} body Create cloud save
         * @param {string} experienceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalCreateCloudSave(body: CloudSaveCreateRequest, experienceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
            const localVarFetchArgs = CloudsaveApiFetchParamCreator(configuration).internalCreateCloudSave(body, experienceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Internal delete cloud save
         * @param {string} experienceId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalDeleteCloudSave(experienceId: string, instanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
            const localVarFetchArgs = CloudsaveApiFetchParamCreator(configuration).internalDeleteCloudSave(experienceId, instanceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Internal get cloud save
         * @param {string} experienceId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalGetCloudSave(experienceId: string, instanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CloudSaveGetResponse> {
            const localVarFetchArgs = CloudsaveApiFetchParamCreator(configuration).internalGetCloudSave(experienceId, instanceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Internal update cloud save
         * @param {CloudSaveUpdateRequest} body Admin update cloud save
         * @param {string} experienceId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalUpdateCloudSave(body: CloudSaveUpdateRequest, experienceId: string, instanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CloudSaveUpdateResponse> {
            const localVarFetchArgs = CloudsaveApiFetchParamCreator(configuration).internalUpdateCloudSave(body, experienceId, instanceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CloudsaveApi - factory interface
 * @export
 */
export const CloudsaveApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Admin create cloud save for user
         * @param {AdminCloudSaveCreateRequest} body Create cloud save
         * @param {string} experienceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateCloudSave(body: AdminCloudSaveCreateRequest, experienceId: string, options?: any) {
            return CloudsaveApiFp(configuration).adminCreateCloudSave(body, experienceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Admin delete cloud save
         * @param {string} experienceId 
         * @param {string} instanceId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteCloudSave(experienceId: string, instanceId: string, userId: string, options?: any) {
            return CloudsaveApiFp(configuration).adminDeleteCloudSave(experienceId, instanceId, userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Admin get private cloud save
         * @param {string} experienceId 
         * @param {string} instanceId 
         * @param {string} userId id of the user whose cloud save the admin wants to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetCloudSave(experienceId: string, instanceId: string, userId: string, options?: any) {
            return CloudsaveApiFp(configuration).adminGetCloudSave(experienceId, instanceId, userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Admin update cloud save
         * @param {AdminCloudSaveUpdateRequest} body Admin update cloud save
         * @param {string} experienceId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateCloudSave(body: AdminCloudSaveUpdateRequest, experienceId: string, instanceId: string, options?: any) {
            return CloudsaveApiFp(configuration).adminUpdateCloudSave(body, experienceId, instanceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Internal create cloud save
         * @param {CloudSaveCreateRequest} body Create cloud save
         * @param {string} experienceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalCreateCloudSave(body: CloudSaveCreateRequest, experienceId: string, options?: any) {
            return CloudsaveApiFp(configuration).internalCreateCloudSave(body, experienceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Internal delete cloud save
         * @param {string} experienceId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalDeleteCloudSave(experienceId: string, instanceId: string, options?: any) {
            return CloudsaveApiFp(configuration).internalDeleteCloudSave(experienceId, instanceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Internal get cloud save
         * @param {string} experienceId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalGetCloudSave(experienceId: string, instanceId: string, options?: any) {
            return CloudsaveApiFp(configuration).internalGetCloudSave(experienceId, instanceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Internal update cloud save
         * @param {CloudSaveUpdateRequest} body Admin update cloud save
         * @param {string} experienceId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalUpdateCloudSave(body: CloudSaveUpdateRequest, experienceId: string, instanceId: string, options?: any) {
            return CloudsaveApiFp(configuration).internalUpdateCloudSave(body, experienceId, instanceId, options)(fetch, basePath);
        },
    };
};

/**
 * CloudsaveApi - object-oriented interface
 * @export
 * @class CloudsaveApi
 * @extends {BaseAPI}
 */
export class CloudsaveApi extends BaseAPI {
    /**
     * 
     * @summary Admin create cloud save for user
     * @param {AdminCloudSaveCreateRequest} body Create cloud save
     * @param {string} experienceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudsaveApi
     */
    public adminCreateCloudSave(body: AdminCloudSaveCreateRequest, experienceId: string, options?: any) {
        return CloudsaveApiFp(this.configuration).adminCreateCloudSave(body, experienceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Admin delete cloud save
     * @param {string} experienceId 
     * @param {string} instanceId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudsaveApi
     */
    public adminDeleteCloudSave(experienceId: string, instanceId: string, userId: string, options?: any) {
        return CloudsaveApiFp(this.configuration).adminDeleteCloudSave(experienceId, instanceId, userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Admin get private cloud save
     * @param {string} experienceId 
     * @param {string} instanceId 
     * @param {string} userId id of the user whose cloud save the admin wants to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudsaveApi
     */
    public adminGetCloudSave(experienceId: string, instanceId: string, userId: string, options?: any) {
        return CloudsaveApiFp(this.configuration).adminGetCloudSave(experienceId, instanceId, userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Admin update cloud save
     * @param {AdminCloudSaveUpdateRequest} body Admin update cloud save
     * @param {string} experienceId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudsaveApi
     */
    public adminUpdateCloudSave(body: AdminCloudSaveUpdateRequest, experienceId: string, instanceId: string, options?: any) {
        return CloudsaveApiFp(this.configuration).adminUpdateCloudSave(body, experienceId, instanceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Internal create cloud save
     * @param {CloudSaveCreateRequest} body Create cloud save
     * @param {string} experienceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudsaveApi
     */
    public internalCreateCloudSave(body: CloudSaveCreateRequest, experienceId: string, options?: any) {
        return CloudsaveApiFp(this.configuration).internalCreateCloudSave(body, experienceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Internal delete cloud save
     * @param {string} experienceId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudsaveApi
     */
    public internalDeleteCloudSave(experienceId: string, instanceId: string, options?: any) {
        return CloudsaveApiFp(this.configuration).internalDeleteCloudSave(experienceId, instanceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Internal get cloud save
     * @param {string} experienceId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudsaveApi
     */
    public internalGetCloudSave(experienceId: string, instanceId: string, options?: any) {
        return CloudsaveApiFp(this.configuration).internalGetCloudSave(experienceId, instanceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Internal update cloud save
     * @param {CloudSaveUpdateRequest} body Admin update cloud save
     * @param {string} experienceId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudsaveApi
     */
    public internalUpdateCloudSave(body: CloudSaveUpdateRequest, experienceId: string, instanceId: string, options?: any) {
        return CloudsaveApiFp(this.configuration).internalUpdateCloudSave(body, experienceId, instanceId, options)(this.fetch, this.basePath);
    }

}
/**
 * CustomColorsApi - fetch parameter creator
 * @export
 */
export const CustomColorsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new user-generated custom color preset for hair, skin, or flair. The color will be associated with the user and can be used in avatar customization.
         * @summary Create a new custom color preset
         * @param {CreateCustomColorRequest} body 
         * @param {string} userId User ID who owns the custom color
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomColor(body: CreateCustomColorRequest, userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCustomColor.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling createCustomColor.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/custom-colors`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateCustomColorRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a custom color preset. Only the owner can delete their custom colors.
         * @summary Delete a custom color
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomColor(userId: string, instanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteCustomColor.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling deleteCustomColor.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/custom-colors/{instanceId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of a specific custom color preset by its instance ID.
         * @summary Get a specific custom color by ID
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomColor(userId: string, instanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getCustomColor.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling getCustomColor.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/custom-colors/{instanceId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all custom color presets created by the user. Supports filtering by category, app ID, and org ID.
         * @summary List all custom colors for a user
         * @param {string} userId User ID who owns the custom colors
         * @param {string} [category] Filter by category (hair, skin, or flair)
         * @param {string} [appId] Application ID to filter custom colors
         * @param {string} [orgId] Organization ID to filter custom colors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomColors(userId: string, category?: string, appId?: string, orgId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling listCustomColors.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/custom-colors`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the colors or name of an existing custom color preset. Only the owner can update their custom colors.
         * @summary Update a custom color
         * @param {UpdateCustomColorRequest} body 
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomColor(body: UpdateCustomColorRequest, userId: string, instanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateCustomColor.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateCustomColor.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling updateCustomColor.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/custom-colors/{instanceId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateCustomColorRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomColorsApi - functional programming interface
 * @export
 */
export const CustomColorsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new user-generated custom color preset for hair, skin, or flair. The color will be associated with the user and can be used in avatar customization.
         * @summary Create a new custom color preset
         * @param {CreateCustomColorRequest} body 
         * @param {string} userId User ID who owns the custom color
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomColor(body: CreateCustomColorRequest, userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomColorResponse> {
            const localVarFetchArgs = CustomColorsApiFetchParamCreator(configuration).createCustomColor(body, userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a custom color preset. Only the owner can delete their custom colors.
         * @summary Delete a custom color
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomColor(userId: string, instanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteCustomColorResponse> {
            const localVarFetchArgs = CustomColorsApiFetchParamCreator(configuration).deleteCustomColor(userId, instanceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns details of a specific custom color preset by its instance ID.
         * @summary Get a specific custom color by ID
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomColor(userId: string, instanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomColorResponse> {
            const localVarFetchArgs = CustomColorsApiFetchParamCreator(configuration).getCustomColor(userId, instanceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all custom color presets created by the user. Supports filtering by category, app ID, and org ID.
         * @summary List all custom colors for a user
         * @param {string} userId User ID who owns the custom colors
         * @param {string} [category] Filter by category (hair, skin, or flair)
         * @param {string} [appId] Application ID to filter custom colors
         * @param {string} [orgId] Organization ID to filter custom colors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomColors(userId: string, category?: string, appId?: string, orgId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListCustomColorsResponse> {
            const localVarFetchArgs = CustomColorsApiFetchParamCreator(configuration).listCustomColors(userId, category, appId, orgId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the colors or name of an existing custom color preset. Only the owner can update their custom colors.
         * @summary Update a custom color
         * @param {UpdateCustomColorRequest} body 
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomColor(body: UpdateCustomColorRequest, userId: string, instanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomColorResponse> {
            const localVarFetchArgs = CustomColorsApiFetchParamCreator(configuration).updateCustomColor(body, userId, instanceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomColorsApi - factory interface
 * @export
 */
export const CustomColorsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a new user-generated custom color preset for hair, skin, or flair. The color will be associated with the user and can be used in avatar customization.
         * @summary Create a new custom color preset
         * @param {CreateCustomColorRequest} body 
         * @param {string} userId User ID who owns the custom color
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomColor(body: CreateCustomColorRequest, userId: string, options?: any) {
            return CustomColorsApiFp(configuration).createCustomColor(body, userId, options)(fetch, basePath);
        },
        /**
         * Deletes a custom color preset. Only the owner can delete their custom colors.
         * @summary Delete a custom color
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomColor(userId: string, instanceId: string, options?: any) {
            return CustomColorsApiFp(configuration).deleteCustomColor(userId, instanceId, options)(fetch, basePath);
        },
        /**
         * Returns details of a specific custom color preset by its instance ID.
         * @summary Get a specific custom color by ID
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomColor(userId: string, instanceId: string, options?: any) {
            return CustomColorsApiFp(configuration).getCustomColor(userId, instanceId, options)(fetch, basePath);
        },
        /**
         * Returns all custom color presets created by the user. Supports filtering by category, app ID, and org ID.
         * @summary List all custom colors for a user
         * @param {string} userId User ID who owns the custom colors
         * @param {string} [category] Filter by category (hair, skin, or flair)
         * @param {string} [appId] Application ID to filter custom colors
         * @param {string} [orgId] Organization ID to filter custom colors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomColors(userId: string, category?: string, appId?: string, orgId?: string, options?: any) {
            return CustomColorsApiFp(configuration).listCustomColors(userId, category, appId, orgId, options)(fetch, basePath);
        },
        /**
         * Updates the colors or name of an existing custom color preset. Only the owner can update their custom colors.
         * @summary Update a custom color
         * @param {UpdateCustomColorRequest} body 
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomColor(body: UpdateCustomColorRequest, userId: string, instanceId: string, options?: any) {
            return CustomColorsApiFp(configuration).updateCustomColor(body, userId, instanceId, options)(fetch, basePath);
        },
    };
};

/**
 * CustomColorsApi - object-oriented interface
 * @export
 * @class CustomColorsApi
 * @extends {BaseAPI}
 */
export class CustomColorsApi extends BaseAPI {
    /**
     * Creates a new user-generated custom color preset for hair, skin, or flair. The color will be associated with the user and can be used in avatar customization.
     * @summary Create a new custom color preset
     * @param {CreateCustomColorRequest} body 
     * @param {string} userId User ID who owns the custom color
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomColorsApi
     */
    public createCustomColor(body: CreateCustomColorRequest, userId: string, options?: any) {
        return CustomColorsApiFp(this.configuration).createCustomColor(body, userId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a custom color preset. Only the owner can delete their custom colors.
     * @summary Delete a custom color
     * @param {string} userId User ID who owns the custom color
     * @param {string} instanceId Instance ID of the custom color to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomColorsApi
     */
    public deleteCustomColor(userId: string, instanceId: string, options?: any) {
        return CustomColorsApiFp(this.configuration).deleteCustomColor(userId, instanceId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns details of a specific custom color preset by its instance ID.
     * @summary Get a specific custom color by ID
     * @param {string} userId User ID who owns the custom color
     * @param {string} instanceId Instance ID of the custom color
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomColorsApi
     */
    public getCustomColor(userId: string, instanceId: string, options?: any) {
        return CustomColorsApiFp(this.configuration).getCustomColor(userId, instanceId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all custom color presets created by the user. Supports filtering by category, app ID, and org ID.
     * @summary List all custom colors for a user
     * @param {string} userId User ID who owns the custom colors
     * @param {string} [category] Filter by category (hair, skin, or flair)
     * @param {string} [appId] Application ID to filter custom colors
     * @param {string} [orgId] Organization ID to filter custom colors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomColorsApi
     */
    public listCustomColors(userId: string, category?: string, appId?: string, orgId?: string, options?: any) {
        return CustomColorsApiFp(this.configuration).listCustomColors(userId, category, appId, orgId, options)(this.fetch, this.basePath);
    }

    /**
     * Updates the colors or name of an existing custom color preset. Only the owner can update their custom colors.
     * @summary Update a custom color
     * @param {UpdateCustomColorRequest} body 
     * @param {string} userId User ID who owns the custom color
     * @param {string} instanceId Instance ID of the custom color to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomColorsApi
     */
    public updateCustomColor(body: UpdateCustomColorRequest, userId: string, instanceId: string, options?: any) {
        return CustomColorsApiFp(this.configuration).updateCustomColor(body, userId, instanceId, options)(this.fetch, this.basePath);
    }

}
/**
 * DefaultItemsApi - fetch parameter creator
 * @export
 */
export const DefaultItemsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns default animation library assets including gestures, expressions, and movements for avatar animation
         * @summary Get default animation library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
         * @param {Array<string>} [color] Filter by animation theme color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAnimationLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/animation-library`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default user avatar items filtered by organization and application
         * @summary Get default avatar items
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by avatar category
         * @param {Array<string>} [color] Filter by avatar color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatar(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/avatar`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default base customization items for avatar editor like hairstyles, facial features, and body characteristics
         * @summary Get default base avatar customization assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
         * @param {Array<string>} [color] Filter by base color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarBase(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/avatar/base`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default avatar eye assets like eye colors, styles, and expressions
         * @summary Get default eye avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
         * @param {Array<string>} [color] Filter by eye color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarEyes(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/avatar/eyes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
         * @summary Get default flair avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
         * @param {Array<string>} [color] Filter by flair color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarFlair(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/avatar/flair`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
         * @summary Get default makeup avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
         * @param {Array<string>} [color] Filter by makeup color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarMakeup(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/avatar/makeup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default color preset assets that provide predefined color combinations and palettes for avatar customization
         * @summary Get default color preset assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
         * @param {Array<string>} [color] Filter by dominant color in preset
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultColorPresets(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/color-presets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default decorative items filtered by organization and application
         * @summary Get default decor items
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by decor category
         * @param {Array<string>} [color] Filter by decor color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultDecor(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/decor`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default gear/wearable items filtered by organization and application
         * @summary Get default gear items
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by gear category
         * @param {Array<string>} [color] Filter by gear color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultGear(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/gear`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default image library assets including textures, patterns, and images used for avatar customization
         * @summary Get default image library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
         * @param {Array<string>} [color] Filter by dominant color in image
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultImageLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/image-library`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
         * @summary Get default model library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
         * @param {Array<string>} [color] Filter by model color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultModelLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/model-library`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultItemsApi - functional programming interface
 * @export
 */
export const DefaultItemsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns default animation library assets including gestures, expressions, and movements for avatar animation
         * @summary Get default animation library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
         * @param {Array<string>} [color] Filter by animation theme color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAnimationLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AnimationLibraryResponse> {
            const localVarFetchArgs = DefaultItemsApiFetchParamCreator(configuration).getDefaultAnimationLibrary(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default user avatar items filtered by organization and application
         * @summary Get default avatar items
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by avatar category
         * @param {Array<string>} [color] Filter by avatar color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatar(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarResponse> {
            const localVarFetchArgs = DefaultItemsApiFetchParamCreator(configuration).getDefaultAvatar(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default base customization items for avatar editor like hairstyles, facial features, and body characteristics
         * @summary Get default base avatar customization assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
         * @param {Array<string>} [color] Filter by base color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarBase(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarBaseResponse> {
            const localVarFetchArgs = DefaultItemsApiFetchParamCreator(configuration).getDefaultAvatarBase(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default avatar eye assets like eye colors, styles, and expressions
         * @summary Get default eye avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
         * @param {Array<string>} [color] Filter by eye color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarEyes(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarEyesResponse> {
            const localVarFetchArgs = DefaultItemsApiFetchParamCreator(configuration).getDefaultAvatarEyes(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
         * @summary Get default flair avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
         * @param {Array<string>} [color] Filter by flair color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarFlair(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarFlairResponse> {
            const localVarFetchArgs = DefaultItemsApiFetchParamCreator(configuration).getDefaultAvatarFlair(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
         * @summary Get default makeup avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
         * @param {Array<string>} [color] Filter by makeup color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarMakeup(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarMakeupResponse> {
            const localVarFetchArgs = DefaultItemsApiFetchParamCreator(configuration).getDefaultAvatarMakeup(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default color preset assets that provide predefined color combinations and palettes for avatar customization
         * @summary Get default color preset assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
         * @param {Array<string>} [color] Filter by dominant color in preset
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultColorPresets(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2ColorPresetsResponse> {
            const localVarFetchArgs = DefaultItemsApiFetchParamCreator(configuration).getDefaultColorPresets(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default decorative items filtered by organization and application
         * @summary Get default decor items
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by decor category
         * @param {Array<string>} [color] Filter by decor color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultDecor(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2DecorResponse> {
            const localVarFetchArgs = DefaultItemsApiFetchParamCreator(configuration).getDefaultDecor(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default gear/wearable items filtered by organization and application
         * @summary Get default gear items
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by gear category
         * @param {Array<string>} [color] Filter by gear color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultGear(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2GearResponse> {
            const localVarFetchArgs = DefaultItemsApiFetchParamCreator(configuration).getDefaultGear(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default image library assets including textures, patterns, and images used for avatar customization
         * @summary Get default image library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
         * @param {Array<string>} [color] Filter by dominant color in image
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultImageLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2ImageLibraryResponse> {
            const localVarFetchArgs = DefaultItemsApiFetchParamCreator(configuration).getDefaultImageLibrary(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
         * @summary Get default model library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
         * @param {Array<string>} [color] Filter by model color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultModelLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2ModelLibraryResponse> {
            const localVarFetchArgs = DefaultItemsApiFetchParamCreator(configuration).getDefaultModelLibrary(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultItemsApi - factory interface
 * @export
 */
export const DefaultItemsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns default animation library assets including gestures, expressions, and movements for avatar animation
         * @summary Get default animation library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
         * @param {Array<string>} [color] Filter by animation theme color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAnimationLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return DefaultItemsApiFp(configuration).getDefaultAnimationLibrary(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default user avatar items filtered by organization and application
         * @summary Get default avatar items
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by avatar category
         * @param {Array<string>} [color] Filter by avatar color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatar(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return DefaultItemsApiFp(configuration).getDefaultAvatar(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default base customization items for avatar editor like hairstyles, facial features, and body characteristics
         * @summary Get default base avatar customization assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
         * @param {Array<string>} [color] Filter by base color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarBase(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return DefaultItemsApiFp(configuration).getDefaultAvatarBase(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default avatar eye assets like eye colors, styles, and expressions
         * @summary Get default eye avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
         * @param {Array<string>} [color] Filter by eye color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarEyes(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return DefaultItemsApiFp(configuration).getDefaultAvatarEyes(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
         * @summary Get default flair avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
         * @param {Array<string>} [color] Filter by flair color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarFlair(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return DefaultItemsApiFp(configuration).getDefaultAvatarFlair(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
         * @summary Get default makeup avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
         * @param {Array<string>} [color] Filter by makeup color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarMakeup(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return DefaultItemsApiFp(configuration).getDefaultAvatarMakeup(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default color preset assets that provide predefined color combinations and palettes for avatar customization
         * @summary Get default color preset assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
         * @param {Array<string>} [color] Filter by dominant color in preset
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultColorPresets(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return DefaultItemsApiFp(configuration).getDefaultColorPresets(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default decorative items filtered by organization and application
         * @summary Get default decor items
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by decor category
         * @param {Array<string>} [color] Filter by decor color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultDecor(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return DefaultItemsApiFp(configuration).getDefaultDecor(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default gear/wearable items filtered by organization and application
         * @summary Get default gear items
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by gear category
         * @param {Array<string>} [color] Filter by gear color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultGear(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return DefaultItemsApiFp(configuration).getDefaultGear(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default image library assets including textures, patterns, and images used for avatar customization
         * @summary Get default image library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
         * @param {Array<string>} [color] Filter by dominant color in image
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultImageLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return DefaultItemsApiFp(configuration).getDefaultImageLibrary(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
         * @summary Get default model library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
         * @param {Array<string>} [color] Filter by model color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultModelLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return DefaultItemsApiFp(configuration).getDefaultModelLibrary(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultItemsApi - object-oriented interface
 * @export
 * @class DefaultItemsApi
 * @extends {BaseAPI}
 */
export class DefaultItemsApi extends BaseAPI {
    /**
     * Returns default animation library assets including gestures, expressions, and movements for avatar animation
     * @summary Get default animation library assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
     * @param {Array<string>} [color] Filter by animation theme color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultItemsApi
     */
    public getDefaultAnimationLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return DefaultItemsApiFp(this.configuration).getDefaultAnimationLibrary(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default user avatar items filtered by organization and application
     * @summary Get default avatar items
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by avatar category
     * @param {Array<string>} [color] Filter by avatar color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultItemsApi
     */
    public getDefaultAvatar(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return DefaultItemsApiFp(this.configuration).getDefaultAvatar(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default base customization items for avatar editor like hairstyles, facial features, and body characteristics
     * @summary Get default base avatar customization assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
     * @param {Array<string>} [color] Filter by base color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultItemsApi
     */
    public getDefaultAvatarBase(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return DefaultItemsApiFp(this.configuration).getDefaultAvatarBase(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default avatar eye assets like eye colors, styles, and expressions
     * @summary Get default eye avatar assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
     * @param {Array<string>} [color] Filter by eye color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultItemsApi
     */
    public getDefaultAvatarEyes(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return DefaultItemsApiFp(this.configuration).getDefaultAvatarEyes(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
     * @summary Get default flair avatar assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
     * @param {Array<string>} [color] Filter by flair color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultItemsApi
     */
    public getDefaultAvatarFlair(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return DefaultItemsApiFp(this.configuration).getDefaultAvatarFlair(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
     * @summary Get default makeup avatar assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
     * @param {Array<string>} [color] Filter by makeup color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultItemsApi
     */
    public getDefaultAvatarMakeup(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return DefaultItemsApiFp(this.configuration).getDefaultAvatarMakeup(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default color preset assets that provide predefined color combinations and palettes for avatar customization
     * @summary Get default color preset assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
     * @param {Array<string>} [color] Filter by dominant color in preset
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultItemsApi
     */
    public getDefaultColorPresets(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return DefaultItemsApiFp(this.configuration).getDefaultColorPresets(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default decorative items filtered by organization and application
     * @summary Get default decor items
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by decor category
     * @param {Array<string>} [color] Filter by decor color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultItemsApi
     */
    public getDefaultDecor(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return DefaultItemsApiFp(this.configuration).getDefaultDecor(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default gear/wearable items filtered by organization and application
     * @summary Get default gear items
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by gear category
     * @param {Array<string>} [color] Filter by gear color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultItemsApi
     */
    public getDefaultGear(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return DefaultItemsApiFp(this.configuration).getDefaultGear(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default image library assets including textures, patterns, and images used for avatar customization
     * @summary Get default image library assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
     * @param {Array<string>} [color] Filter by dominant color in image
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultItemsApi
     */
    public getDefaultImageLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return DefaultItemsApiFp(this.configuration).getDefaultImageLibrary(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
     * @summary Get default model library assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
     * @param {Array<string>} [color] Filter by model color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultItemsApi
     */
    public getDefaultModelLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return DefaultItemsApiFp(this.configuration).getDefaultModelLibrary(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

}
/**
 * EconomyApi - fetch parameter creator
 * @export
 */
export const EconomyApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new hard currency product
         * @param {AddHardCurrencyProductBody} body body of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addHardCurrencyProduct(body: AddHardCurrencyProductBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addHardCurrencyProduct.');
            }
            const localVarPath = `/admin/economy/hard-currency/product`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddHardCurrencyProductBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary add a soft currency product
         * @param {AddSoftCurrencyProductRequest} body product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSoftCurrencyProduct(body: AddSoftCurrencyProductRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addSoftCurrencyProduct.');
            }
            const localVarPath = `/admin/economy/soft-currency/product`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddSoftCurrencyProductRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete hard currency product metadata
         * @param {string} productSku productSku to delete metadata for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHardCurrencyProductMetadata(productSku: string, options: any = {}): FetchArgs {
            // verify required parameter 'productSku' is not null or undefined
            if (productSku === null || productSku === undefined) {
                throw new RequiredError('productSku','Required parameter productSku was null or undefined when calling deleteHardCurrencyProductMetadata.');
            }
            const localVarPath = `/admin/economy/hard-currency/product/metadata/{productSku}`
                .replace(`{${"productSku"}}`, encodeURIComponent(String(productSku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific soft currency definition by its unique identifier. Requires admin privileges.
         * @summary Delete Soft Currency
         * @param {string} currencyId The unique identifier (ID) of the soft currency to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSoftCurrency(currencyId: string, options: any = {}): FetchArgs {
            // verify required parameter 'currencyId' is not null or undefined
            if (currencyId === null || currencyId === undefined) {
                throw new RequiredError('currencyId','Required parameter currencyId was null or undefined when calling deleteSoftCurrency.');
            }
            const localVarPath = `/admin/economy/soft-currency/{currencyId}`
                .replace(`{${"currencyId"}}`, encodeURIComponent(String(currencyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete soft currency product
         * @param {string} currencyId currencyId of product
         * @param {boolean} productSku productSku of product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSoftCurrencyProduct(currencyId: string, productSku: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'currencyId' is not null or undefined
            if (currencyId === null || currencyId === undefined) {
                throw new RequiredError('currencyId','Required parameter currencyId was null or undefined when calling deleteSoftCurrencyProduct.');
            }
            // verify required parameter 'productSku' is not null or undefined
            if (productSku === null || productSku === undefined) {
                throw new RequiredError('productSku','Required parameter productSku was null or undefined when calling deleteSoftCurrencyProduct.');
            }
            const localVarPath = `/admin/economy/soft-currency/product/{currencyId}/{productSku}`
                .replace(`{${"currencyId"}}`, encodeURIComponent(String(currencyId)))
                .replace(`{${"productSku"}}`, encodeURIComponent(String(productSku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Force add hard currency to a user
         * @param {ForceAddHardCurrencyBody} body amount
         * @param {string} id user ID to add hard currency to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceAddHardCurrency(body: ForceAddHardCurrencyBody, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling forceAddHardCurrency.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling forceAddHardCurrency.');
            }
            const localVarPath = `/admin/economy/hard-currency/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ForceAddHardCurrencyBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all soft currency products
         * @param {string} currencyId currencyId to get products for
         * @param {boolean} [includeInactive] include inactive products in response
         * @param {boolean} [includeMetadata] include metadata of products in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveSoftCurrencyProducts(currencyId: string, includeInactive?: boolean, includeMetadata?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'currencyId' is not null or undefined
            if (currencyId === null || currencyId === undefined) {
                throw new RequiredError('currencyId','Required parameter currencyId was null or undefined when calling getActiveSoftCurrencyProducts.');
            }
            const localVarPath = `/admin/economy/soft-currency/product`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (includeInactive !== undefined) {
                localVarQueryParameter['include_inactive'] = includeInactive;
            }

            if (includeMetadata !== undefined) {
                localVarQueryParameter['include_metadata'] = includeMetadata;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all currencies for a user
         * @param {string} ownerId owner ID to get currencies for (partyId or experienceSku)
         * @param {string} [externalOwnerId] optional external ownerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCurrenciesForOwner(ownerId: string, externalOwnerId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'ownerId' is not null or undefined
            if (ownerId === null || ownerId === undefined) {
                throw new RequiredError('ownerId','Required parameter ownerId was null or undefined when calling getAllCurrenciesForOwner.');
            }
            const localVarPath = `/admin/economy/soft-currency/{ownerId}`
                .replace(`{${"ownerId"}}`, encodeURIComponent(String(ownerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            if (externalOwnerId !== undefined) {
                localVarQueryParameter['externalOwnerId'] = externalOwnerId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all hard currency product metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllHardCurrencyProductMetadata(options: any = {}): FetchArgs {
            const localVarPath = `/admin/economy/hard-currency/product/metadata`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all currencies for a user
         * @param {string} id user ID to get currencies for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWalletsForUser(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAllWalletsForUser.');
            }
            const localVarPath = `/admin/economy/currencies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get hard currency product metadata
         * @param {string} productSku productSku to get metadata for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHardCurrencyProductMetadata(productSku: string, options: any = {}): FetchArgs {
            // verify required parameter 'productSku' is not null or undefined
            if (productSku === null || productSku === undefined) {
                throw new RequiredError('productSku','Required parameter productSku was null or undefined when calling getHardCurrencyProductMetadata.');
            }
            const localVarPath = `/admin/economy/hard-currency/product/metadata/{productSku}`
                .replace(`{${"productSku"}}`, encodeURIComponent(String(productSku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get hard currency products with mappings
         * @param {boolean} [activeOnly] only get active product mappings
         * @param {string} [partyId] the partyId to request product mappings for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHardCurrencyProductsWithMappings(activeOnly?: boolean, partyId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/admin/economy/hard-currency/product/mapping`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            if (activeOnly !== undefined) {
                localVarQueryParameter['active_only'] = activeOnly;
            }

            if (partyId !== undefined) {
                localVarQueryParameter['party_id'] = partyId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get soft currency product
         * @param {string} currencyId currencyId of product
         * @param {boolean} productSku productSku of product
         * @param {boolean} [includeMetadata] include metadata of product in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSoftCurrencyProduct(currencyId: string, productSku: boolean, includeMetadata?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'currencyId' is not null or undefined
            if (currencyId === null || currencyId === undefined) {
                throw new RequiredError('currencyId','Required parameter currencyId was null or undefined when calling getSoftCurrencyProduct.');
            }
            // verify required parameter 'productSku' is not null or undefined
            if (productSku === null || productSku === undefined) {
                throw new RequiredError('productSku','Required parameter productSku was null or undefined when calling getSoftCurrencyProduct.');
            }
            const localVarPath = `/admin/economy/soft-currency/product/{currencyId}/{productSku}`
                .replace(`{${"currencyId"}}`, encodeURIComponent(String(currencyId)))
                .replace(`{${"productSku"}}`, encodeURIComponent(String(productSku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            if (includeMetadata !== undefined) {
                localVarQueryParameter['include_metadata'] = includeMetadata;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transaction history for a user
         * @param {string} id user ID to get transaction history for
         * @param {number} page the page number
         * @param {number} pageSize the pagination size
         * @param {string} [transactionType] the type of transaction
         * @param {string} [spentCurrencyType] the type of spent currency
         * @param {string} [purchasedCurrencyType] the type of purchased currency
         * @param {string} [store] the store where purchase was made
         * @param {string} [productId] the platform productId
         * @param {string} [appSku] the appsku
         * @param {string} [status] the transaction status
         * @param {string} [createdAtStart] start creation date string
         * @param {string} [createdAtEnd] end creation date string
         * @param {string} [updatedAtStart] start update date string
         * @param {string} [updatedAtEnd] end update date string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionHistory(id: string, page: number, pageSize: number, transactionType?: string, spentCurrencyType?: string, purchasedCurrencyType?: string, store?: string, productId?: string, appSku?: string, status?: string, createdAtStart?: string, createdAtEnd?: string, updatedAtStart?: string, updatedAtEnd?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTransactionHistory.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getTransactionHistory.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getTransactionHistory.');
            }
            const localVarPath = `/admin/economy/transaction-history/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (transactionType !== undefined) {
                localVarQueryParameter['transaction_type'] = transactionType;
            }

            if (spentCurrencyType !== undefined) {
                localVarQueryParameter['spent_currency_type'] = spentCurrencyType;
            }

            if (purchasedCurrencyType !== undefined) {
                localVarQueryParameter['purchased_currency_type'] = purchasedCurrencyType;
            }

            if (store !== undefined) {
                localVarQueryParameter['store'] = store;
            }

            if (productId !== undefined) {
                localVarQueryParameter['product_id'] = productId;
            }

            if (appSku !== undefined) {
                localVarQueryParameter['app_sku'] = appSku;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (createdAtStart !== undefined) {
                localVarQueryParameter['created_at_start'] = createdAtStart;
            }

            if (createdAtEnd !== undefined) {
                localVarQueryParameter['created_at_end'] = createdAtEnd;
            }

            if (updatedAtStart !== undefined) {
                localVarQueryParameter['updated_at_start'] = updatedAtStart;
            }

            if (updatedAtEnd !== undefined) {
                localVarQueryParameter['updated_at_end'] = updatedAtEnd;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update hard currency product
         * @param {UpdateHardCurrencyProductBody} body body of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHardCurrencyProduct(body: UpdateHardCurrencyProductBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateHardCurrencyProduct.');
            }
            const localVarPath = `/admin/economy/hard-currency/product`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateHardCurrencyProductBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update a soft currency product
         * @param {UpdateSoftCurrencyProductRequest} body product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSoftCurrencyProduct(body: UpdateSoftCurrencyProductRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSoftCurrencyProduct.');
            }
            const localVarPath = `/admin/economy/soft-currency/product`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateSoftCurrencyProductRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upsert hard currency product metadata
         * @param {UpsertHardCurrencyProductMetadataRequest} body body of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertHardCurrencyProductMetadata(body: UpsertHardCurrencyProductMetadataRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling upsertHardCurrencyProductMetadata.');
            }
            const localVarPath = `/admin/economy/hard-currency/product/metadata`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpsertHardCurrencyProductMetadataRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new mapping from productSku to productId
         * @param {UpsertProductSkuMappingBody} body body of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertProductSkuMapping(body: UpsertProductSkuMappingBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling upsertProductSkuMapping.');
            }
            const localVarPath = `/admin/economy/hard-currency/product/mapping`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpsertProductSkuMappingBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary upsert a soft currency type
         * @param {UpsertSoftCurrencyRequest} body Upsert soft currency type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertSoftCurrency(body: UpsertSoftCurrencyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling upsertSoftCurrency.');
            }
            const localVarPath = `/admin/economy/soft-currency`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpsertSoftCurrencyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EconomyApi - functional programming interface
 * @export
 */
export const EconomyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new hard currency product
         * @param {AddHardCurrencyProductBody} body body of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addHardCurrencyProduct(body: AddHardCurrencyProductBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddHardCurrencyProductResponse> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).addHardCurrencyProduct(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary add a soft currency product
         * @param {AddSoftCurrencyProductRequest} body product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSoftCurrencyProduct(body: AddSoftCurrencyProductRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddSoftCurrencyProductResponse> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).addSoftCurrencyProduct(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete hard currency product metadata
         * @param {string} productSku productSku to delete metadata for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHardCurrencyProductMetadata(productSku: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteHardCurrencyProductMetadataResponse> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).deleteHardCurrencyProductMetadata(productSku, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a specific soft currency definition by its unique identifier. Requires admin privileges.
         * @summary Delete Soft Currency
         * @param {string} currencyId The unique identifier (ID) of the soft currency to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSoftCurrency(currencyId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteSoftCurrencyResponse> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).deleteSoftCurrency(currencyId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete soft currency product
         * @param {string} currencyId currencyId of product
         * @param {boolean} productSku productSku of product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSoftCurrencyProduct(currencyId: string, productSku: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteSoftCurrencyProductResponse> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).deleteSoftCurrencyProduct(currencyId, productSku, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Force add hard currency to a user
         * @param {ForceAddHardCurrencyBody} body amount
         * @param {string} id user ID to add hard currency to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceAddHardCurrency(body: ForceAddHardCurrencyBody, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ForceAddHardCurrencyResponse> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).forceAddHardCurrency(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all soft currency products
         * @param {string} currencyId currencyId to get products for
         * @param {boolean} [includeInactive] include inactive products in response
         * @param {boolean} [includeMetadata] include metadata of products in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveSoftCurrencyProducts(currencyId: string, includeInactive?: boolean, includeMetadata?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetActiveSoftCurrencyProductsResponse> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).getActiveSoftCurrencyProducts(currencyId, includeInactive, includeMetadata, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all currencies for a user
         * @param {string} ownerId owner ID to get currencies for (partyId or experienceSku)
         * @param {string} [externalOwnerId] optional external ownerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCurrenciesForOwner(ownerId: string, externalOwnerId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAllCurrenciesForOwnerResponse> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).getAllCurrenciesForOwner(ownerId, externalOwnerId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all hard currency product metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllHardCurrencyProductMetadata(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAllHardCurrencyProductMetadataResponse> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).getAllHardCurrencyProductMetadata(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all currencies for a user
         * @param {string} id user ID to get currencies for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWalletsForUser(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAllWalletsForUserResponse> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).getAllWalletsForUser(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get hard currency product metadata
         * @param {string} productSku productSku to get metadata for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHardCurrencyProductMetadata(productSku: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetHardCurrencyProductMetadataResponse> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).getHardCurrencyProductMetadata(productSku, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get hard currency products with mappings
         * @param {boolean} [activeOnly] only get active product mappings
         * @param {string} [partyId] the partyId to request product mappings for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHardCurrencyProductsWithMappings(activeOnly?: boolean, partyId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetHardCurrencyProductsWithMappingsResponse> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).getHardCurrencyProductsWithMappings(activeOnly, partyId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get soft currency product
         * @param {string} currencyId currencyId of product
         * @param {boolean} productSku productSku of product
         * @param {boolean} [includeMetadata] include metadata of product in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSoftCurrencyProduct(currencyId: string, productSku: boolean, includeMetadata?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSoftCurrencyProductResponse> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).getSoftCurrencyProduct(currencyId, productSku, includeMetadata, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get transaction history for a user
         * @param {string} id user ID to get transaction history for
         * @param {number} page the page number
         * @param {number} pageSize the pagination size
         * @param {string} [transactionType] the type of transaction
         * @param {string} [spentCurrencyType] the type of spent currency
         * @param {string} [purchasedCurrencyType] the type of purchased currency
         * @param {string} [store] the store where purchase was made
         * @param {string} [productId] the platform productId
         * @param {string} [appSku] the appsku
         * @param {string} [status] the transaction status
         * @param {string} [createdAtStart] start creation date string
         * @param {string} [createdAtEnd] end creation date string
         * @param {string} [updatedAtStart] start update date string
         * @param {string} [updatedAtEnd] end update date string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionHistory(id: string, page: number, pageSize: number, transactionType?: string, spentCurrencyType?: string, purchasedCurrencyType?: string, store?: string, productId?: string, appSku?: string, status?: string, createdAtStart?: string, createdAtEnd?: string, updatedAtStart?: string, updatedAtEnd?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetTransactionHistoryResponse> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).getTransactionHistory(id, page, pageSize, transactionType, spentCurrencyType, purchasedCurrencyType, store, productId, appSku, status, createdAtStart, createdAtEnd, updatedAtStart, updatedAtEnd, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update hard currency product
         * @param {UpdateHardCurrencyProductBody} body body of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHardCurrencyProduct(body: UpdateHardCurrencyProductBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateHardCurrencyProductResponse> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).updateHardCurrencyProduct(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary update a soft currency product
         * @param {UpdateSoftCurrencyProductRequest} body product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSoftCurrencyProduct(body: UpdateSoftCurrencyProductRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateSoftCurrencyProductResponse> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).updateSoftCurrencyProduct(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Upsert hard currency product metadata
         * @param {UpsertHardCurrencyProductMetadataRequest} body body of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertHardCurrencyProductMetadata(body: UpsertHardCurrencyProductMetadataRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpsertHardCurrencyProductMetadataResponse> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).upsertHardCurrencyProductMetadata(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Add new mapping from productSku to productId
         * @param {UpsertProductSkuMappingBody} body body of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertProductSkuMapping(body: UpsertProductSkuMappingBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpsertProductSkuMappingResponse> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).upsertProductSkuMapping(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary upsert a soft currency type
         * @param {UpsertSoftCurrencyRequest} body Upsert soft currency type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertSoftCurrency(body: UpsertSoftCurrencyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpsertSoftCurrencyResponse> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).upsertSoftCurrency(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EconomyApi - factory interface
 * @export
 */
export const EconomyApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add new hard currency product
         * @param {AddHardCurrencyProductBody} body body of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addHardCurrencyProduct(body: AddHardCurrencyProductBody, options?: any) {
            return EconomyApiFp(configuration).addHardCurrencyProduct(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary add a soft currency product
         * @param {AddSoftCurrencyProductRequest} body product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSoftCurrencyProduct(body: AddSoftCurrencyProductRequest, options?: any) {
            return EconomyApiFp(configuration).addSoftCurrencyProduct(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete hard currency product metadata
         * @param {string} productSku productSku to delete metadata for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHardCurrencyProductMetadata(productSku: string, options?: any) {
            return EconomyApiFp(configuration).deleteHardCurrencyProductMetadata(productSku, options)(fetch, basePath);
        },
        /**
         * Deletes a specific soft currency definition by its unique identifier. Requires admin privileges.
         * @summary Delete Soft Currency
         * @param {string} currencyId The unique identifier (ID) of the soft currency to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSoftCurrency(currencyId: string, options?: any) {
            return EconomyApiFp(configuration).deleteSoftCurrency(currencyId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete soft currency product
         * @param {string} currencyId currencyId of product
         * @param {boolean} productSku productSku of product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSoftCurrencyProduct(currencyId: string, productSku: boolean, options?: any) {
            return EconomyApiFp(configuration).deleteSoftCurrencyProduct(currencyId, productSku, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Force add hard currency to a user
         * @param {ForceAddHardCurrencyBody} body amount
         * @param {string} id user ID to add hard currency to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceAddHardCurrency(body: ForceAddHardCurrencyBody, id: string, options?: any) {
            return EconomyApiFp(configuration).forceAddHardCurrency(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all soft currency products
         * @param {string} currencyId currencyId to get products for
         * @param {boolean} [includeInactive] include inactive products in response
         * @param {boolean} [includeMetadata] include metadata of products in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveSoftCurrencyProducts(currencyId: string, includeInactive?: boolean, includeMetadata?: boolean, options?: any) {
            return EconomyApiFp(configuration).getActiveSoftCurrencyProducts(currencyId, includeInactive, includeMetadata, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all currencies for a user
         * @param {string} ownerId owner ID to get currencies for (partyId or experienceSku)
         * @param {string} [externalOwnerId] optional external ownerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCurrenciesForOwner(ownerId: string, externalOwnerId?: string, options?: any) {
            return EconomyApiFp(configuration).getAllCurrenciesForOwner(ownerId, externalOwnerId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all hard currency product metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllHardCurrencyProductMetadata(options?: any) {
            return EconomyApiFp(configuration).getAllHardCurrencyProductMetadata(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all currencies for a user
         * @param {string} id user ID to get currencies for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWalletsForUser(id: string, options?: any) {
            return EconomyApiFp(configuration).getAllWalletsForUser(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get hard currency product metadata
         * @param {string} productSku productSku to get metadata for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHardCurrencyProductMetadata(productSku: string, options?: any) {
            return EconomyApiFp(configuration).getHardCurrencyProductMetadata(productSku, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get hard currency products with mappings
         * @param {boolean} [activeOnly] only get active product mappings
         * @param {string} [partyId] the partyId to request product mappings for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHardCurrencyProductsWithMappings(activeOnly?: boolean, partyId?: string, options?: any) {
            return EconomyApiFp(configuration).getHardCurrencyProductsWithMappings(activeOnly, partyId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get soft currency product
         * @param {string} currencyId currencyId of product
         * @param {boolean} productSku productSku of product
         * @param {boolean} [includeMetadata] include metadata of product in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSoftCurrencyProduct(currencyId: string, productSku: boolean, includeMetadata?: boolean, options?: any) {
            return EconomyApiFp(configuration).getSoftCurrencyProduct(currencyId, productSku, includeMetadata, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get transaction history for a user
         * @param {string} id user ID to get transaction history for
         * @param {number} page the page number
         * @param {number} pageSize the pagination size
         * @param {string} [transactionType] the type of transaction
         * @param {string} [spentCurrencyType] the type of spent currency
         * @param {string} [purchasedCurrencyType] the type of purchased currency
         * @param {string} [store] the store where purchase was made
         * @param {string} [productId] the platform productId
         * @param {string} [appSku] the appsku
         * @param {string} [status] the transaction status
         * @param {string} [createdAtStart] start creation date string
         * @param {string} [createdAtEnd] end creation date string
         * @param {string} [updatedAtStart] start update date string
         * @param {string} [updatedAtEnd] end update date string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionHistory(id: string, page: number, pageSize: number, transactionType?: string, spentCurrencyType?: string, purchasedCurrencyType?: string, store?: string, productId?: string, appSku?: string, status?: string, createdAtStart?: string, createdAtEnd?: string, updatedAtStart?: string, updatedAtEnd?: string, options?: any) {
            return EconomyApiFp(configuration).getTransactionHistory(id, page, pageSize, transactionType, spentCurrencyType, purchasedCurrencyType, store, productId, appSku, status, createdAtStart, createdAtEnd, updatedAtStart, updatedAtEnd, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update hard currency product
         * @param {UpdateHardCurrencyProductBody} body body of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHardCurrencyProduct(body: UpdateHardCurrencyProductBody, options?: any) {
            return EconomyApiFp(configuration).updateHardCurrencyProduct(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary update a soft currency product
         * @param {UpdateSoftCurrencyProductRequest} body product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSoftCurrencyProduct(body: UpdateSoftCurrencyProductRequest, options?: any) {
            return EconomyApiFp(configuration).updateSoftCurrencyProduct(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Upsert hard currency product metadata
         * @param {UpsertHardCurrencyProductMetadataRequest} body body of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertHardCurrencyProductMetadata(body: UpsertHardCurrencyProductMetadataRequest, options?: any) {
            return EconomyApiFp(configuration).upsertHardCurrencyProductMetadata(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add new mapping from productSku to productId
         * @param {UpsertProductSkuMappingBody} body body of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertProductSkuMapping(body: UpsertProductSkuMappingBody, options?: any) {
            return EconomyApiFp(configuration).upsertProductSkuMapping(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary upsert a soft currency type
         * @param {UpsertSoftCurrencyRequest} body Upsert soft currency type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertSoftCurrency(body: UpsertSoftCurrencyRequest, options?: any) {
            return EconomyApiFp(configuration).upsertSoftCurrency(body, options)(fetch, basePath);
        },
    };
};

/**
 * EconomyApi - object-oriented interface
 * @export
 * @class EconomyApi
 * @extends {BaseAPI}
 */
export class EconomyApi extends BaseAPI {
    /**
     * 
     * @summary Add new hard currency product
     * @param {AddHardCurrencyProductBody} body body of request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public addHardCurrencyProduct(body: AddHardCurrencyProductBody, options?: any) {
        return EconomyApiFp(this.configuration).addHardCurrencyProduct(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary add a soft currency product
     * @param {AddSoftCurrencyProductRequest} body product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public addSoftCurrencyProduct(body: AddSoftCurrencyProductRequest, options?: any) {
        return EconomyApiFp(this.configuration).addSoftCurrencyProduct(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete hard currency product metadata
     * @param {string} productSku productSku to delete metadata for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public deleteHardCurrencyProductMetadata(productSku: string, options?: any) {
        return EconomyApiFp(this.configuration).deleteHardCurrencyProductMetadata(productSku, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a specific soft currency definition by its unique identifier. Requires admin privileges.
     * @summary Delete Soft Currency
     * @param {string} currencyId The unique identifier (ID) of the soft currency to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public deleteSoftCurrency(currencyId: string, options?: any) {
        return EconomyApiFp(this.configuration).deleteSoftCurrency(currencyId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete soft currency product
     * @param {string} currencyId currencyId of product
     * @param {boolean} productSku productSku of product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public deleteSoftCurrencyProduct(currencyId: string, productSku: boolean, options?: any) {
        return EconomyApiFp(this.configuration).deleteSoftCurrencyProduct(currencyId, productSku, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Force add hard currency to a user
     * @param {ForceAddHardCurrencyBody} body amount
     * @param {string} id user ID to add hard currency to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public forceAddHardCurrency(body: ForceAddHardCurrencyBody, id: string, options?: any) {
        return EconomyApiFp(this.configuration).forceAddHardCurrency(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all soft currency products
     * @param {string} currencyId currencyId to get products for
     * @param {boolean} [includeInactive] include inactive products in response
     * @param {boolean} [includeMetadata] include metadata of products in response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getActiveSoftCurrencyProducts(currencyId: string, includeInactive?: boolean, includeMetadata?: boolean, options?: any) {
        return EconomyApiFp(this.configuration).getActiveSoftCurrencyProducts(currencyId, includeInactive, includeMetadata, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all currencies for a user
     * @param {string} ownerId owner ID to get currencies for (partyId or experienceSku)
     * @param {string} [externalOwnerId] optional external ownerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getAllCurrenciesForOwner(ownerId: string, externalOwnerId?: string, options?: any) {
        return EconomyApiFp(this.configuration).getAllCurrenciesForOwner(ownerId, externalOwnerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all hard currency product metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getAllHardCurrencyProductMetadata(options?: any) {
        return EconomyApiFp(this.configuration).getAllHardCurrencyProductMetadata(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all currencies for a user
     * @param {string} id user ID to get currencies for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getAllWalletsForUser(id: string, options?: any) {
        return EconomyApiFp(this.configuration).getAllWalletsForUser(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get hard currency product metadata
     * @param {string} productSku productSku to get metadata for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getHardCurrencyProductMetadata(productSku: string, options?: any) {
        return EconomyApiFp(this.configuration).getHardCurrencyProductMetadata(productSku, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get hard currency products with mappings
     * @param {boolean} [activeOnly] only get active product mappings
     * @param {string} [partyId] the partyId to request product mappings for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getHardCurrencyProductsWithMappings(activeOnly?: boolean, partyId?: string, options?: any) {
        return EconomyApiFp(this.configuration).getHardCurrencyProductsWithMappings(activeOnly, partyId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get soft currency product
     * @param {string} currencyId currencyId of product
     * @param {boolean} productSku productSku of product
     * @param {boolean} [includeMetadata] include metadata of product in response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getSoftCurrencyProduct(currencyId: string, productSku: boolean, includeMetadata?: boolean, options?: any) {
        return EconomyApiFp(this.configuration).getSoftCurrencyProduct(currencyId, productSku, includeMetadata, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get transaction history for a user
     * @param {string} id user ID to get transaction history for
     * @param {number} page the page number
     * @param {number} pageSize the pagination size
     * @param {string} [transactionType] the type of transaction
     * @param {string} [spentCurrencyType] the type of spent currency
     * @param {string} [purchasedCurrencyType] the type of purchased currency
     * @param {string} [store] the store where purchase was made
     * @param {string} [productId] the platform productId
     * @param {string} [appSku] the appsku
     * @param {string} [status] the transaction status
     * @param {string} [createdAtStart] start creation date string
     * @param {string} [createdAtEnd] end creation date string
     * @param {string} [updatedAtStart] start update date string
     * @param {string} [updatedAtEnd] end update date string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getTransactionHistory(id: string, page: number, pageSize: number, transactionType?: string, spentCurrencyType?: string, purchasedCurrencyType?: string, store?: string, productId?: string, appSku?: string, status?: string, createdAtStart?: string, createdAtEnd?: string, updatedAtStart?: string, updatedAtEnd?: string, options?: any) {
        return EconomyApiFp(this.configuration).getTransactionHistory(id, page, pageSize, transactionType, spentCurrencyType, purchasedCurrencyType, store, productId, appSku, status, createdAtStart, createdAtEnd, updatedAtStart, updatedAtEnd, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update hard currency product
     * @param {UpdateHardCurrencyProductBody} body body of request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public updateHardCurrencyProduct(body: UpdateHardCurrencyProductBody, options?: any) {
        return EconomyApiFp(this.configuration).updateHardCurrencyProduct(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary update a soft currency product
     * @param {UpdateSoftCurrencyProductRequest} body product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public updateSoftCurrencyProduct(body: UpdateSoftCurrencyProductRequest, options?: any) {
        return EconomyApiFp(this.configuration).updateSoftCurrencyProduct(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Upsert hard currency product metadata
     * @param {UpsertHardCurrencyProductMetadataRequest} body body of request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public upsertHardCurrencyProductMetadata(body: UpsertHardCurrencyProductMetadataRequest, options?: any) {
        return EconomyApiFp(this.configuration).upsertHardCurrencyProductMetadata(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Add new mapping from productSku to productId
     * @param {UpsertProductSkuMappingBody} body body of request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public upsertProductSkuMapping(body: UpsertProductSkuMappingBody, options?: any) {
        return EconomyApiFp(this.configuration).upsertProductSkuMapping(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary upsert a soft currency type
     * @param {UpsertSoftCurrencyRequest} body Upsert soft currency type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public upsertSoftCurrency(body: UpsertSoftCurrencyRequest, options?: any) {
        return EconomyApiFp(this.configuration).upsertSoftCurrency(body, options)(this.fetch, this.basePath);
    }

}
/**
 * GearApi - fetch parameter creator
 * @export
 */
export const GearApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of gears
         * @param {string} [cursor] the pagination cursor
         * @param {number} [limit] the pagination size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetGears(cursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/admin/gears`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a gear
         * @param {GearCreateRequest} body Create gear
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGear(body: GearCreateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createGear.');
            }
            const localVarPath = `/gear`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GearCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of gears
         * @param {string} [cursor] the pagination cursor
         * @param {number} [limit] the pagination size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGearList(cursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/gear`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pipeline get a gear
         * @param {string} gearId Identifier of the gear
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineGetGear(gearId: string, options: any = {}): FetchArgs {
            // verify required parameter 'gearId' is not null or undefined
            if (gearId === null || gearId === undefined) {
                throw new RequiredError('gearId','Required parameter gearId was null or undefined when calling pipelineGetGear.');
            }
            const localVarPath = `/pipeline/gear/{gearId}`
                .replace(`{${"gearId"}}`, encodeURIComponent(String(gearId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication privateToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-private-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-private-token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pipeline update a gear
         * @param {GearUpdateRequest} body Create gear
         * @param {string} gearId Identifier of the gear
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineUpdateGear(body: GearUpdateRequest, gearId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling pipelineUpdateGear.');
            }
            // verify required parameter 'gearId' is not null or undefined
            if (gearId === null || gearId === undefined) {
                throw new RequiredError('gearId','Required parameter gearId was null or undefined when calling pipelineUpdateGear.');
            }
            const localVarPath = `/pipeline/gear/{gearId}`
                .replace(`{${"gearId"}}`, encodeURIComponent(String(gearId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication privateToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-private-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-private-token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GearUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a gear
         * @param {GearUpdateRequest} body Create gear
         * @param {string} gearId Identifier of the gear
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGear(body: GearUpdateRequest, gearId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateGear.');
            }
            // verify required parameter 'gearId' is not null or undefined
            if (gearId === null || gearId === undefined) {
                throw new RequiredError('gearId','Required parameter gearId was null or undefined when calling updateGear.');
            }
            const localVarPath = `/gear/{gearId}`
                .replace(`{${"gearId"}}`, encodeURIComponent(String(gearId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GearUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GearApi - functional programming interface
 * @export
 */
export const GearApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of gears
         * @param {string} [cursor] the pagination cursor
         * @param {number} [limit] the pagination size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetGears(cursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GearListResponse> {
            const localVarFetchArgs = GearApiFetchParamCreator(configuration).adminGetGears(cursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a gear
         * @param {GearCreateRequest} body Create gear
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGear(body: GearCreateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GearCreateResponse> {
            const localVarFetchArgs = GearApiFetchParamCreator(configuration).createGear(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of gears
         * @param {string} [cursor] the pagination cursor
         * @param {number} [limit] the pagination size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGearList(cursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GearListResponse> {
            const localVarFetchArgs = GearApiFetchParamCreator(configuration).getGearList(cursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Pipeline get a gear
         * @param {string} gearId Identifier of the gear
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineGetGear(gearId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GearGetByIdResponse> {
            const localVarFetchArgs = GearApiFetchParamCreator(configuration).pipelineGetGear(gearId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Pipeline update a gear
         * @param {GearUpdateRequest} body Create gear
         * @param {string} gearId Identifier of the gear
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineUpdateGear(body: GearUpdateRequest, gearId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GearUpdateRequest> {
            const localVarFetchArgs = GearApiFetchParamCreator(configuration).pipelineUpdateGear(body, gearId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a gear
         * @param {GearUpdateRequest} body Create gear
         * @param {string} gearId Identifier of the gear
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGear(body: GearUpdateRequest, gearId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GearUpdateRequest> {
            const localVarFetchArgs = GearApiFetchParamCreator(configuration).updateGear(body, gearId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GearApi - factory interface
 * @export
 */
export const GearApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get a list of gears
         * @param {string} [cursor] the pagination cursor
         * @param {number} [limit] the pagination size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetGears(cursor?: string, limit?: number, options?: any) {
            return GearApiFp(configuration).adminGetGears(cursor, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a gear
         * @param {GearCreateRequest} body Create gear
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGear(body: GearCreateRequest, options?: any) {
            return GearApiFp(configuration).createGear(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of gears
         * @param {string} [cursor] the pagination cursor
         * @param {number} [limit] the pagination size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGearList(cursor?: string, limit?: number, options?: any) {
            return GearApiFp(configuration).getGearList(cursor, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Pipeline get a gear
         * @param {string} gearId Identifier of the gear
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineGetGear(gearId: string, options?: any) {
            return GearApiFp(configuration).pipelineGetGear(gearId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Pipeline update a gear
         * @param {GearUpdateRequest} body Create gear
         * @param {string} gearId Identifier of the gear
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineUpdateGear(body: GearUpdateRequest, gearId: string, options?: any) {
            return GearApiFp(configuration).pipelineUpdateGear(body, gearId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a gear
         * @param {GearUpdateRequest} body Create gear
         * @param {string} gearId Identifier of the gear
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGear(body: GearUpdateRequest, gearId: string, options?: any) {
            return GearApiFp(configuration).updateGear(body, gearId, options)(fetch, basePath);
        },
    };
};

/**
 * GearApi - object-oriented interface
 * @export
 * @class GearApi
 * @extends {BaseAPI}
 */
export class GearApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of gears
     * @param {string} [cursor] the pagination cursor
     * @param {number} [limit] the pagination size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GearApi
     */
    public adminGetGears(cursor?: string, limit?: number, options?: any) {
        return GearApiFp(this.configuration).adminGetGears(cursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a gear
     * @param {GearCreateRequest} body Create gear
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GearApi
     */
    public createGear(body: GearCreateRequest, options?: any) {
        return GearApiFp(this.configuration).createGear(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of gears
     * @param {string} [cursor] the pagination cursor
     * @param {number} [limit] the pagination size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GearApi
     */
    public getGearList(cursor?: string, limit?: number, options?: any) {
        return GearApiFp(this.configuration).getGearList(cursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Pipeline get a gear
     * @param {string} gearId Identifier of the gear
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GearApi
     */
    public pipelineGetGear(gearId: string, options?: any) {
        return GearApiFp(this.configuration).pipelineGetGear(gearId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Pipeline update a gear
     * @param {GearUpdateRequest} body Create gear
     * @param {string} gearId Identifier of the gear
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GearApi
     */
    public pipelineUpdateGear(body: GearUpdateRequest, gearId: string, options?: any) {
        return GearApiFp(this.configuration).pipelineUpdateGear(body, gearId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a gear
     * @param {GearUpdateRequest} body Create gear
     * @param {string} gearId Identifier of the gear
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GearApi
     */
    public updateGear(body: GearUpdateRequest, gearId: string, options?: any) {
        return GearApiFp(this.configuration).updateGear(body, gearId, options)(this.fetch, this.basePath);
    }

}
/**
 * InventoryApi - fetch parameter creator
 * @export
 */
export const InventoryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new instance of an existing asset and assigns ownership. The optional fields (partyId, orgId, experienceId) will be stored as metadata on the asset instance. 
         * @summary Mint an asset instance
         * @param {MintAssetRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminInventoryAssetsInstancePost(body: MintAssetRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling adminInventoryAssetsInstancePost.');
            }
            const localVarPath = `/admin/inventory/assets/instance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MintAssetRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete asset instance
         * @param {string} instanceId asset instance id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        burnAssetInstance(instanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling burnAssetInstance.');
            }
            const localVarPath = `/admin/inventory/assets/instance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            if (instanceId !== undefined) {
                localVarQueryParameter['instanceId'] = instanceId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new asset supply in the inventory system
         * @summary Create a new asset supply
         * @param {CreateAssetSupplyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssetSupply(body: CreateAssetSupplyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createAssetSupply.');
            }
            const localVarPath = `/admin/inventory/assets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateAssetSupplyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates the tag_defaultCloset metadata store with indexed fields for orgId, appId, and isDefault
         * @summary Create tag_defaultCloset metadata namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDefaultClosetNamespace(options: any = {}): FetchArgs {
            const localVarPath = `/admin/inventory/metadata-stores/default-closet-namespace`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an asset supply and tags it with the tag_defaultCloset namespace for use as a default item.  **Important**: Before calling this endpoint, ensure the asset has been properly tagged with relevant metadata in the following namespaces: - `tag_name` (name) - `tag_description` (description, longDescription) - `tag_category` (category) - `tag_subcategories` (subcategories) - `tag_colors` or `tag_colorsHex` (colors array) - `tag_origin` (origin tag for filtering) - `tag_mood` (for AnimationLibrary assets) - `tag_protocol` (protocolTags for AnimationLibrary assets) - `pipeline_0` (pipeline version information)  This endpoint specifically tags the asset as a default item for the specified orgId/appId combination. 
         * @summary Create a default item
         * @param {CreateDefaultItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDefaultItem(body: CreateDefaultItemRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createDefaultItem.');
            }
            const localVarPath = `/admin/inventory/metadata-stores/default-item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateDefaultItemRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create inventory metadata store
         * @param {CreateMetadataStoreRequest} body body of request
         * @param {string} namespace namespace of the metadatastore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetadataStore(body: CreateMetadataStoreRequest, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createMetadataStore.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createMetadataStore.');
            }
            const localVarPath = `/admin/inventory/metadata`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateMetadataStoreRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete assets
         * @param {DeleteAssetsRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssets(body?: DeleteAssetsRequest, options: any = {}): FetchArgs {
            const localVarPath = `/admin/inventory/assets/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeleteAssetsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns inventory items for a specified user. Admin access required.
         * @summary Admin endpoint to get inventory for a user
         * @param {string} userId The ID of the user whose inventory to retrieve
         * @param {Array<string>} [category] Filter by item category
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by item color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminUserInventory(userId: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getAdminUserInventory.');
            }
            const localVarPath = `/admin/inventory/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves information about all available metadata stores and their configurations
         * @summary Get all metadata stores
         * @param {string} [type] Filter stores by type (core, app-specific, instance)
         * @param {string} [appId] Application ID to filter app-specific stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMetadataStores(type?: string, appId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/admin/inventory/metadata-stores`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves information about a specific metadata store
         * @summary Get metadata store information
         * @param {string} metadataStoreKey Unique identifier for the metadata store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataStore(metadataStoreKey: string, options: any = {}): FetchArgs {
            // verify required parameter 'metadataStoreKey' is not null or undefined
            if (metadataStoreKey === null || metadataStoreKey === undefined) {
                throw new RequiredError('metadataStoreKey','Required parameter metadataStoreKey was null or undefined when calling getMetadataStore.');
            }
            const localVarPath = `/admin/inventory/metadata/store/{metadataStoreKey}`
                .replace(`{${"metadataStoreKey"}}`, encodeURIComponent(String(metadataStoreKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get inventory metadata tag
         * @param {string} tagId id of the tag to get
         * @param {string} namespace namespace of the metadatastore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataTag(tagId: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling getMetadataTag.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMetadataTag.');
            }
            const localVarPath = `/admin/inventory/metadata/tag`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            if (tagId !== undefined) {
                localVarQueryParameter['tagId'] = tagId;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets or updates metadata tags for assets in a specific namespace.  **Automatic Field Processing**: - `category`: Automatically denormalized from array to single string (e.g., `[\"hair\"]`  `\"hair\"`) - `orgId`, `appId`, `colorsHex`, `colors`, `subcategories`: Automatically normalized from stringified JSON arrays to proper arrays  **Note**: The API handles both string and stringified array inputs for these fields to ensure compatibility with various clients. 
         * @summary Set inventory metadata tags
         * @param {SetMetadataTagsRequest} body body of request
         * @param {string} namespace namespace of the metadatastore
         * @param {string} metadataStoreKey id of the metadata store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMetadataTags(body: SetMetadataTagsRequest, namespace: string, metadataStoreKey: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setMetadataTags.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMetadataTags.');
            }
            // verify required parameter 'metadataStoreKey' is not null or undefined
            if (metadataStoreKey === null || metadataStoreKey === undefined) {
                throw new RequiredError('metadataStoreKey','Required parameter metadataStoreKey was null or undefined when calling setMetadataTags.');
            }
            const localVarPath = `/admin/inventory/metadata/tag`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (metadataStoreKey !== undefined) {
                localVarQueryParameter['metadataStoreKey'] = metadataStoreKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SetMetadataTagsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update inventory metadata tag
         * @param {UpdateMetadataTagRequest} body body of request
         * @param {string} tagId id of the tag to update
         * @param {string} namespace namespace of the metadatastore
         * @param {string} metadataStoreKey id of the metadata store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetadataTag(body: UpdateMetadataTagRequest, tagId: string, namespace: string, metadataStoreKey: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateMetadataTag.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling updateMetadataTag.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling updateMetadataTag.');
            }
            // verify required parameter 'metadataStoreKey' is not null or undefined
            if (metadataStoreKey === null || metadataStoreKey === undefined) {
                throw new RequiredError('metadataStoreKey','Required parameter metadataStoreKey was null or undefined when calling updateMetadataTag.');
            }
            const localVarPath = `/admin/inventory/metadata/tag/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (metadataStoreKey !== undefined) {
                localVarQueryParameter['metadataStoreKey'] = metadataStoreKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateMetadataTagRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InventoryApi - functional programming interface
 * @export
 */
export const InventoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new instance of an existing asset and assigns ownership. The optional fields (partyId, orgId, experienceId) will be stored as metadata on the asset instance. 
         * @summary Mint an asset instance
         * @param {MintAssetRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminInventoryAssetsInstancePost(body: MintAssetRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MintAssetResponse> {
            const localVarFetchArgs = InventoryApiFetchParamCreator(configuration).adminInventoryAssetsInstancePost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete asset instance
         * @param {string} instanceId asset instance id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        burnAssetInstance(instanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteAssetInstanceResponse> {
            const localVarFetchArgs = InventoryApiFetchParamCreator(configuration).burnAssetInstance(instanceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a new asset supply in the inventory system
         * @summary Create a new asset supply
         * @param {CreateAssetSupplyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssetSupply(body: CreateAssetSupplyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateAssetSupplyResponse> {
            const localVarFetchArgs = InventoryApiFetchParamCreator(configuration).createAssetSupply(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates the tag_defaultCloset metadata store with indexed fields for orgId, appId, and isDefault
         * @summary Create tag_defaultCloset metadata namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDefaultClosetNamespace(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateDefaultClosetNamespaceResponse> {
            const localVarFetchArgs = InventoryApiFetchParamCreator(configuration).createDefaultClosetNamespace(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates an asset supply and tags it with the tag_defaultCloset namespace for use as a default item.  **Important**: Before calling this endpoint, ensure the asset has been properly tagged with relevant metadata in the following namespaces: - `tag_name` (name) - `tag_description` (description, longDescription) - `tag_category` (category) - `tag_subcategories` (subcategories) - `tag_colors` or `tag_colorsHex` (colors array) - `tag_origin` (origin tag for filtering) - `tag_mood` (for AnimationLibrary assets) - `tag_protocol` (protocolTags for AnimationLibrary assets) - `pipeline_0` (pipeline version information)  This endpoint specifically tags the asset as a default item for the specified orgId/appId combination. 
         * @summary Create a default item
         * @param {CreateDefaultItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDefaultItem(body: CreateDefaultItemRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateDefaultItemResponse> {
            const localVarFetchArgs = InventoryApiFetchParamCreator(configuration).createDefaultItem(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create inventory metadata store
         * @param {CreateMetadataStoreRequest} body body of request
         * @param {string} namespace namespace of the metadatastore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetadataStore(body: CreateMetadataStoreRequest, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateMetadataStoreResponse> {
            const localVarFetchArgs = InventoryApiFetchParamCreator(configuration).createMetadataStore(body, namespace, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete assets
         * @param {DeleteAssetsRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssets(body?: DeleteAssetsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteAssetsResponse> {
            const localVarFetchArgs = InventoryApiFetchParamCreator(configuration).deleteAssets(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns inventory items for a specified user. Admin access required.
         * @summary Admin endpoint to get inventory for a user
         * @param {string} userId The ID of the user whose inventory to retrieve
         * @param {Array<string>} [category] Filter by item category
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by item color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminUserInventory(userId: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InventoryGetResponse> {
            const localVarFetchArgs = InventoryApiFetchParamCreator(configuration).getAdminUserInventory(userId, category, subcategory, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves information about all available metadata stores and their configurations
         * @summary Get all metadata stores
         * @param {string} [type] Filter stores by type (core, app-specific, instance)
         * @param {string} [appId] Application ID to filter app-specific stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMetadataStores(type?: string, appId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAllStoresResponse> {
            const localVarFetchArgs = InventoryApiFetchParamCreator(configuration).getAllMetadataStores(type, appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves information about a specific metadata store
         * @summary Get metadata store information
         * @param {string} metadataStoreKey Unique identifier for the metadata store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataStore(metadataStoreKey: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetMetadataStoreResponse> {
            const localVarFetchArgs = InventoryApiFetchParamCreator(configuration).getMetadataStore(metadataStoreKey, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get inventory metadata tag
         * @param {string} tagId id of the tag to get
         * @param {string} namespace namespace of the metadatastore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataTag(tagId: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetMetadataTagResponse> {
            const localVarFetchArgs = InventoryApiFetchParamCreator(configuration).getMetadataTag(tagId, namespace, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sets or updates metadata tags for assets in a specific namespace.  **Automatic Field Processing**: - `category`: Automatically denormalized from array to single string (e.g., `[\"hair\"]`  `\"hair\"`) - `orgId`, `appId`, `colorsHex`, `colors`, `subcategories`: Automatically normalized from stringified JSON arrays to proper arrays  **Note**: The API handles both string and stringified array inputs for these fields to ensure compatibility with various clients. 
         * @summary Set inventory metadata tags
         * @param {SetMetadataTagsRequest} body body of request
         * @param {string} namespace namespace of the metadatastore
         * @param {string} metadataStoreKey id of the metadata store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMetadataTags(body: SetMetadataTagsRequest, namespace: string, metadataStoreKey: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SetMetadataTagsResponse> {
            const localVarFetchArgs = InventoryApiFetchParamCreator(configuration).setMetadataTags(body, namespace, metadataStoreKey, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update inventory metadata tag
         * @param {UpdateMetadataTagRequest} body body of request
         * @param {string} tagId id of the tag to update
         * @param {string} namespace namespace of the metadatastore
         * @param {string} metadataStoreKey id of the metadata store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetadataTag(body: UpdateMetadataTagRequest, tagId: string, namespace: string, metadataStoreKey: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateMetadataTagResponse> {
            const localVarFetchArgs = InventoryApiFetchParamCreator(configuration).updateMetadataTag(body, tagId, namespace, metadataStoreKey, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InventoryApi - factory interface
 * @export
 */
export const InventoryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a new instance of an existing asset and assigns ownership. The optional fields (partyId, orgId, experienceId) will be stored as metadata on the asset instance. 
         * @summary Mint an asset instance
         * @param {MintAssetRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminInventoryAssetsInstancePost(body: MintAssetRequest, options?: any) {
            return InventoryApiFp(configuration).adminInventoryAssetsInstancePost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete asset instance
         * @param {string} instanceId asset instance id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        burnAssetInstance(instanceId: string, options?: any) {
            return InventoryApiFp(configuration).burnAssetInstance(instanceId, options)(fetch, basePath);
        },
        /**
         * Creates a new asset supply in the inventory system
         * @summary Create a new asset supply
         * @param {CreateAssetSupplyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssetSupply(body: CreateAssetSupplyRequest, options?: any) {
            return InventoryApiFp(configuration).createAssetSupply(body, options)(fetch, basePath);
        },
        /**
         * Creates the tag_defaultCloset metadata store with indexed fields for orgId, appId, and isDefault
         * @summary Create tag_defaultCloset metadata namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDefaultClosetNamespace(options?: any) {
            return InventoryApiFp(configuration).createDefaultClosetNamespace(options)(fetch, basePath);
        },
        /**
         * Creates an asset supply and tags it with the tag_defaultCloset namespace for use as a default item.  **Important**: Before calling this endpoint, ensure the asset has been properly tagged with relevant metadata in the following namespaces: - `tag_name` (name) - `tag_description` (description, longDescription) - `tag_category` (category) - `tag_subcategories` (subcategories) - `tag_colors` or `tag_colorsHex` (colors array) - `tag_origin` (origin tag for filtering) - `tag_mood` (for AnimationLibrary assets) - `tag_protocol` (protocolTags for AnimationLibrary assets) - `pipeline_0` (pipeline version information)  This endpoint specifically tags the asset as a default item for the specified orgId/appId combination. 
         * @summary Create a default item
         * @param {CreateDefaultItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDefaultItem(body: CreateDefaultItemRequest, options?: any) {
            return InventoryApiFp(configuration).createDefaultItem(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create inventory metadata store
         * @param {CreateMetadataStoreRequest} body body of request
         * @param {string} namespace namespace of the metadatastore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetadataStore(body: CreateMetadataStoreRequest, namespace: string, options?: any) {
            return InventoryApiFp(configuration).createMetadataStore(body, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete assets
         * @param {DeleteAssetsRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssets(body?: DeleteAssetsRequest, options?: any) {
            return InventoryApiFp(configuration).deleteAssets(body, options)(fetch, basePath);
        },
        /**
         * Returns inventory items for a specified user. Admin access required.
         * @summary Admin endpoint to get inventory for a user
         * @param {string} userId The ID of the user whose inventory to retrieve
         * @param {Array<string>} [category] Filter by item category
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by item color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminUserInventory(userId: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryApiFp(configuration).getAdminUserInventory(userId, category, subcategory, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Retrieves information about all available metadata stores and their configurations
         * @summary Get all metadata stores
         * @param {string} [type] Filter stores by type (core, app-specific, instance)
         * @param {string} [appId] Application ID to filter app-specific stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMetadataStores(type?: string, appId?: string, options?: any) {
            return InventoryApiFp(configuration).getAllMetadataStores(type, appId, options)(fetch, basePath);
        },
        /**
         * Retrieves information about a specific metadata store
         * @summary Get metadata store information
         * @param {string} metadataStoreKey Unique identifier for the metadata store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataStore(metadataStoreKey: string, options?: any) {
            return InventoryApiFp(configuration).getMetadataStore(metadataStoreKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get inventory metadata tag
         * @param {string} tagId id of the tag to get
         * @param {string} namespace namespace of the metadatastore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataTag(tagId: string, namespace: string, options?: any) {
            return InventoryApiFp(configuration).getMetadataTag(tagId, namespace, options)(fetch, basePath);
        },
        /**
         * Sets or updates metadata tags for assets in a specific namespace.  **Automatic Field Processing**: - `category`: Automatically denormalized from array to single string (e.g., `[\"hair\"]`  `\"hair\"`) - `orgId`, `appId`, `colorsHex`, `colors`, `subcategories`: Automatically normalized from stringified JSON arrays to proper arrays  **Note**: The API handles both string and stringified array inputs for these fields to ensure compatibility with various clients. 
         * @summary Set inventory metadata tags
         * @param {SetMetadataTagsRequest} body body of request
         * @param {string} namespace namespace of the metadatastore
         * @param {string} metadataStoreKey id of the metadata store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMetadataTags(body: SetMetadataTagsRequest, namespace: string, metadataStoreKey: string, options?: any) {
            return InventoryApiFp(configuration).setMetadataTags(body, namespace, metadataStoreKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update inventory metadata tag
         * @param {UpdateMetadataTagRequest} body body of request
         * @param {string} tagId id of the tag to update
         * @param {string} namespace namespace of the metadatastore
         * @param {string} metadataStoreKey id of the metadata store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetadataTag(body: UpdateMetadataTagRequest, tagId: string, namespace: string, metadataStoreKey: string, options?: any) {
            return InventoryApiFp(configuration).updateMetadataTag(body, tagId, namespace, metadataStoreKey, options)(fetch, basePath);
        },
    };
};

/**
 * InventoryApi - object-oriented interface
 * @export
 * @class InventoryApi
 * @extends {BaseAPI}
 */
export class InventoryApi extends BaseAPI {
    /**
     * Creates a new instance of an existing asset and assigns ownership. The optional fields (partyId, orgId, experienceId) will be stored as metadata on the asset instance. 
     * @summary Mint an asset instance
     * @param {MintAssetRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public adminInventoryAssetsInstancePost(body: MintAssetRequest, options?: any) {
        return InventoryApiFp(this.configuration).adminInventoryAssetsInstancePost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete asset instance
     * @param {string} instanceId asset instance id to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public burnAssetInstance(instanceId: string, options?: any) {
        return InventoryApiFp(this.configuration).burnAssetInstance(instanceId, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a new asset supply in the inventory system
     * @summary Create a new asset supply
     * @param {CreateAssetSupplyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public createAssetSupply(body: CreateAssetSupplyRequest, options?: any) {
        return InventoryApiFp(this.configuration).createAssetSupply(body, options)(this.fetch, this.basePath);
    }

    /**
     * Creates the tag_defaultCloset metadata store with indexed fields for orgId, appId, and isDefault
     * @summary Create tag_defaultCloset metadata namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public createDefaultClosetNamespace(options?: any) {
        return InventoryApiFp(this.configuration).createDefaultClosetNamespace(options)(this.fetch, this.basePath);
    }

    /**
     * Creates an asset supply and tags it with the tag_defaultCloset namespace for use as a default item.  **Important**: Before calling this endpoint, ensure the asset has been properly tagged with relevant metadata in the following namespaces: - `tag_name` (name) - `tag_description` (description, longDescription) - `tag_category` (category) - `tag_subcategories` (subcategories) - `tag_colors` or `tag_colorsHex` (colors array) - `tag_origin` (origin tag for filtering) - `tag_mood` (for AnimationLibrary assets) - `tag_protocol` (protocolTags for AnimationLibrary assets) - `pipeline_0` (pipeline version information)  This endpoint specifically tags the asset as a default item for the specified orgId/appId combination. 
     * @summary Create a default item
     * @param {CreateDefaultItemRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public createDefaultItem(body: CreateDefaultItemRequest, options?: any) {
        return InventoryApiFp(this.configuration).createDefaultItem(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create inventory metadata store
     * @param {CreateMetadataStoreRequest} body body of request
     * @param {string} namespace namespace of the metadatastore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public createMetadataStore(body: CreateMetadataStoreRequest, namespace: string, options?: any) {
        return InventoryApiFp(this.configuration).createMetadataStore(body, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete assets
     * @param {DeleteAssetsRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public deleteAssets(body?: DeleteAssetsRequest, options?: any) {
        return InventoryApiFp(this.configuration).deleteAssets(body, options)(this.fetch, this.basePath);
    }

    /**
     * Returns inventory items for a specified user. Admin access required.
     * @summary Admin endpoint to get inventory for a user
     * @param {string} userId The ID of the user whose inventory to retrieve
     * @param {Array<string>} [category] Filter by item category
     * @param {Array<string>} [subcategory] Filter by item subcategory
     * @param {Array<string>} [color] Filter by item color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public getAdminUserInventory(userId: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryApiFp(this.configuration).getAdminUserInventory(userId, category, subcategory, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves information about all available metadata stores and their configurations
     * @summary Get all metadata stores
     * @param {string} [type] Filter stores by type (core, app-specific, instance)
     * @param {string} [appId] Application ID to filter app-specific stores
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public getAllMetadataStores(type?: string, appId?: string, options?: any) {
        return InventoryApiFp(this.configuration).getAllMetadataStores(type, appId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves information about a specific metadata store
     * @summary Get metadata store information
     * @param {string} metadataStoreKey Unique identifier for the metadata store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public getMetadataStore(metadataStoreKey: string, options?: any) {
        return InventoryApiFp(this.configuration).getMetadataStore(metadataStoreKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get inventory metadata tag
     * @param {string} tagId id of the tag to get
     * @param {string} namespace namespace of the metadatastore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public getMetadataTag(tagId: string, namespace: string, options?: any) {
        return InventoryApiFp(this.configuration).getMetadataTag(tagId, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * Sets or updates metadata tags for assets in a specific namespace.  **Automatic Field Processing**: - `category`: Automatically denormalized from array to single string (e.g., `[\"hair\"]`  `\"hair\"`) - `orgId`, `appId`, `colorsHex`, `colors`, `subcategories`: Automatically normalized from stringified JSON arrays to proper arrays  **Note**: The API handles both string and stringified array inputs for these fields to ensure compatibility with various clients. 
     * @summary Set inventory metadata tags
     * @param {SetMetadataTagsRequest} body body of request
     * @param {string} namespace namespace of the metadatastore
     * @param {string} metadataStoreKey id of the metadata store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public setMetadataTags(body: SetMetadataTagsRequest, namespace: string, metadataStoreKey: string, options?: any) {
        return InventoryApiFp(this.configuration).setMetadataTags(body, namespace, metadataStoreKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update inventory metadata tag
     * @param {UpdateMetadataTagRequest} body body of request
     * @param {string} tagId id of the tag to update
     * @param {string} namespace namespace of the metadatastore
     * @param {string} metadataStoreKey id of the metadata store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public updateMetadataTag(body: UpdateMetadataTagRequest, tagId: string, namespace: string, metadataStoreKey: string, options?: any) {
        return InventoryApiFp(this.configuration).updateMetadataTag(body, tagId, namespace, metadataStoreKey, options)(this.fetch, this.basePath);
    }

}
/**
 * InventoryModerationApi - fetch parameter creator
 * @export
 */
export const InventoryModerationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create the asset lifecycle metadata store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssetStatusMetadataStore(options: any = {}): FetchArgs {
            const localVarPath = `/admin/inventory/asset-status/metadata-store`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create the moderation metadata store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModerationMetadataStore(options: any = {}): FetchArgs {
            const localVarPath = `/admin/inventory/moderation/metadata-store`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get moderation status for a specific asset
         * @param {string} assetId The ID of the asset to retrieve moderation info for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetModerationStatus(assetId: string, options: any = {}): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling getAssetModerationStatus.');
            }
            const localVarPath = `/v2/inventory/moderation/assets/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get assets filtered by moderation status
         * @param {Array<ModerationStatus>} status Filter by status
         * @param {Array<ModerationType>} [moderationType] Filter by moderation type
         * @param {string} [creatorId] Filter by creator id
         * @param {number} [limit] Pagination limit
         * @param {string} [nextCursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsByModerationStatus(status: Array<ModerationStatus>, moderationType?: Array<ModerationType>, creatorId?: string, limit?: number, nextCursor?: string, options: any = {}): FetchArgs {
            // verify required parameter 'status' is not null or undefined
            if (status === null || status === undefined) {
                throw new RequiredError('status','Required parameter status was null or undefined when calling getAssetsByModerationStatus.');
            }
            const localVarPath = `/v2/inventory/moderation/assets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (moderationType) {
                localVarQueryParameter['moderationType'] = moderationType;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit an asset for moderation review
         * @param {string} assetId ID of the asset being submitted for review
         * @param {SubmitAssetForReviewRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitAssetForReview(assetId: string, body?: SubmitAssetForReviewRequest, options: any = {}): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling submitAssetForReview.');
            }
            const localVarPath = `/v2/inventory/moderation/assets/{assetId}/submit`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmitAssetForReviewRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an asset's lifecycle status
         * @param {UpdateAssetStatusRequest} body 
         * @param {string} assetId ID of the asset to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssetLifecycleStatus(body: UpdateAssetStatusRequest, assetId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateAssetLifecycleStatus.');
            }
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling updateAssetLifecycleStatus.');
            }
            const localVarPath = `/admin/inventory/asset-status/assets/{assetId}/status`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateAssetStatusRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an asset's moderation status
         * @param {UpdateModerationStatusRequest} body 
         * @param {string} assetId ID of the asset to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssetModerationStatus(body: UpdateModerationStatusRequest, assetId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateAssetModerationStatus.');
            }
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling updateAssetModerationStatus.');
            }
            const localVarPath = `/admin/inventory/moderation/assets/{assetId}/status`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateModerationStatusRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InventoryModerationApi - functional programming interface
 * @export
 */
export const InventoryModerationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create the asset lifecycle metadata store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssetStatusMetadataStore(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MetadataStoreCreatedResponse> {
            const localVarFetchArgs = InventoryModerationApiFetchParamCreator(configuration).createAssetStatusMetadataStore(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create the moderation metadata store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModerationMetadataStore(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MetadataStoreCreatedResponse> {
            const localVarFetchArgs = InventoryModerationApiFetchParamCreator(configuration).createModerationMetadataStore(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get moderation status for a specific asset
         * @param {string} assetId The ID of the asset to retrieve moderation info for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetModerationStatus(assetId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AssetModerationDetailResponse> {
            const localVarFetchArgs = InventoryModerationApiFetchParamCreator(configuration).getAssetModerationStatus(assetId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get assets filtered by moderation status
         * @param {Array<ModerationStatus>} status Filter by status
         * @param {Array<ModerationType>} [moderationType] Filter by moderation type
         * @param {string} [creatorId] Filter by creator id
         * @param {number} [limit] Pagination limit
         * @param {string} [nextCursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsByModerationStatus(status: Array<ModerationStatus>, moderationType?: Array<ModerationType>, creatorId?: string, limit?: number, nextCursor?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModerationStatusResponse> {
            const localVarFetchArgs = InventoryModerationApiFetchParamCreator(configuration).getAssetsByModerationStatus(status, moderationType, creatorId, limit, nextCursor, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Submit an asset for moderation review
         * @param {string} assetId ID of the asset being submitted for review
         * @param {SubmitAssetForReviewRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitAssetForReview(assetId: string, body?: SubmitAssetForReviewRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmitAssetForReviewResponse> {
            const localVarFetchArgs = InventoryModerationApiFetchParamCreator(configuration).submitAssetForReview(assetId, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update an asset's lifecycle status
         * @param {UpdateAssetStatusRequest} body 
         * @param {string} assetId ID of the asset to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssetLifecycleStatus(body: UpdateAssetStatusRequest, assetId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GenericMessageResponse> {
            const localVarFetchArgs = InventoryModerationApiFetchParamCreator(configuration).updateAssetLifecycleStatus(body, assetId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update an asset's moderation status
         * @param {UpdateModerationStatusRequest} body 
         * @param {string} assetId ID of the asset to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssetModerationStatus(body: UpdateModerationStatusRequest, assetId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GenericMessageResponse> {
            const localVarFetchArgs = InventoryModerationApiFetchParamCreator(configuration).updateAssetModerationStatus(body, assetId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InventoryModerationApi - factory interface
 * @export
 */
export const InventoryModerationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create the asset lifecycle metadata store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssetStatusMetadataStore(options?: any) {
            return InventoryModerationApiFp(configuration).createAssetStatusMetadataStore(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create the moderation metadata store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModerationMetadataStore(options?: any) {
            return InventoryModerationApiFp(configuration).createModerationMetadataStore(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get moderation status for a specific asset
         * @param {string} assetId The ID of the asset to retrieve moderation info for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetModerationStatus(assetId: string, options?: any) {
            return InventoryModerationApiFp(configuration).getAssetModerationStatus(assetId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get assets filtered by moderation status
         * @param {Array<ModerationStatus>} status Filter by status
         * @param {Array<ModerationType>} [moderationType] Filter by moderation type
         * @param {string} [creatorId] Filter by creator id
         * @param {number} [limit] Pagination limit
         * @param {string} [nextCursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsByModerationStatus(status: Array<ModerationStatus>, moderationType?: Array<ModerationType>, creatorId?: string, limit?: number, nextCursor?: string, options?: any) {
            return InventoryModerationApiFp(configuration).getAssetsByModerationStatus(status, moderationType, creatorId, limit, nextCursor, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Submit an asset for moderation review
         * @param {string} assetId ID of the asset being submitted for review
         * @param {SubmitAssetForReviewRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitAssetForReview(assetId: string, body?: SubmitAssetForReviewRequest, options?: any) {
            return InventoryModerationApiFp(configuration).submitAssetForReview(assetId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an asset's lifecycle status
         * @param {UpdateAssetStatusRequest} body 
         * @param {string} assetId ID of the asset to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssetLifecycleStatus(body: UpdateAssetStatusRequest, assetId: string, options?: any) {
            return InventoryModerationApiFp(configuration).updateAssetLifecycleStatus(body, assetId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an asset's moderation status
         * @param {UpdateModerationStatusRequest} body 
         * @param {string} assetId ID of the asset to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssetModerationStatus(body: UpdateModerationStatusRequest, assetId: string, options?: any) {
            return InventoryModerationApiFp(configuration).updateAssetModerationStatus(body, assetId, options)(fetch, basePath);
        },
    };
};

/**
 * InventoryModerationApi - object-oriented interface
 * @export
 * @class InventoryModerationApi
 * @extends {BaseAPI}
 */
export class InventoryModerationApi extends BaseAPI {
    /**
     * 
     * @summary Create the asset lifecycle metadata store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryModerationApi
     */
    public createAssetStatusMetadataStore(options?: any) {
        return InventoryModerationApiFp(this.configuration).createAssetStatusMetadataStore(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create the moderation metadata store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryModerationApi
     */
    public createModerationMetadataStore(options?: any) {
        return InventoryModerationApiFp(this.configuration).createModerationMetadataStore(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get moderation status for a specific asset
     * @param {string} assetId The ID of the asset to retrieve moderation info for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryModerationApi
     */
    public getAssetModerationStatus(assetId: string, options?: any) {
        return InventoryModerationApiFp(this.configuration).getAssetModerationStatus(assetId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get assets filtered by moderation status
     * @param {Array<ModerationStatus>} status Filter by status
     * @param {Array<ModerationType>} [moderationType] Filter by moderation type
     * @param {string} [creatorId] Filter by creator id
     * @param {number} [limit] Pagination limit
     * @param {string} [nextCursor] Pagination cursor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryModerationApi
     */
    public getAssetsByModerationStatus(status: Array<ModerationStatus>, moderationType?: Array<ModerationType>, creatorId?: string, limit?: number, nextCursor?: string, options?: any) {
        return InventoryModerationApiFp(this.configuration).getAssetsByModerationStatus(status, moderationType, creatorId, limit, nextCursor, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Submit an asset for moderation review
     * @param {string} assetId ID of the asset being submitted for review
     * @param {SubmitAssetForReviewRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryModerationApi
     */
    public submitAssetForReview(assetId: string, body?: SubmitAssetForReviewRequest, options?: any) {
        return InventoryModerationApiFp(this.configuration).submitAssetForReview(assetId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update an asset's lifecycle status
     * @param {UpdateAssetStatusRequest} body 
     * @param {string} assetId ID of the asset to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryModerationApi
     */
    public updateAssetLifecycleStatus(body: UpdateAssetStatusRequest, assetId: string, options?: any) {
        return InventoryModerationApiFp(this.configuration).updateAssetLifecycleStatus(body, assetId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update an asset's moderation status
     * @param {UpdateModerationStatusRequest} body 
     * @param {string} assetId ID of the asset to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryModerationApi
     */
    public updateAssetModerationStatus(body: UpdateModerationStatusRequest, assetId: string, options?: any) {
        return InventoryModerationApiFp(this.configuration).updateAssetModerationStatus(body, assetId, options)(this.fetch, this.basePath);
    }

}
/**
 * InventoryV2Api - fetch parameter creator
 * @export
 */
export const InventoryV2ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new user-generated custom color preset for hair, skin, or flair. The color will be associated with the user and can be used in avatar customization.
         * @summary Create a new custom color preset
         * @param {CreateCustomColorRequest} body 
         * @param {string} userId User ID who owns the custom color
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomColor(body: CreateCustomColorRequest, userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCustomColor.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling createCustomColor.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/custom-colors`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateCustomColorRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a custom color preset. Only the owner can delete their custom colors.
         * @summary Delete a custom color
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomColor(userId: string, instanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteCustomColor.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling deleteCustomColor.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/custom-colors/{instanceId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of a specific custom color preset by its instance ID.
         * @summary Get a specific custom color by ID
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomColor(userId: string, instanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getCustomColor.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling getCustomColor.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/custom-colors/{instanceId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default animation library assets including gestures, expressions, and movements for avatar animation
         * @summary Get default animation library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
         * @param {Array<string>} [color] Filter by animation theme color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAnimationLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/animation-library`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default user avatar items filtered by organization and application
         * @summary Get default avatar items
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by avatar category
         * @param {Array<string>} [color] Filter by avatar color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatar(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/avatar`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default base customization items for avatar editor like hairstyles, facial features, and body characteristics
         * @summary Get default base avatar customization assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
         * @param {Array<string>} [color] Filter by base color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarBase(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/avatar/base`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default avatar eye assets like eye colors, styles, and expressions
         * @summary Get default eye avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
         * @param {Array<string>} [color] Filter by eye color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarEyes(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/avatar/eyes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
         * @summary Get default flair avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
         * @param {Array<string>} [color] Filter by flair color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarFlair(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/avatar/flair`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
         * @summary Get default makeup avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
         * @param {Array<string>} [color] Filter by makeup color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarMakeup(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/avatar/makeup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default color preset assets that provide predefined color combinations and palettes for avatar customization
         * @summary Get default color preset assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
         * @param {Array<string>} [color] Filter by dominant color in preset
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultColorPresets(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/color-presets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default decorative items filtered by organization and application
         * @summary Get default decor items
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by decor category
         * @param {Array<string>} [color] Filter by decor color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultDecor(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/decor`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default gear/wearable items filtered by organization and application
         * @summary Get default gear items
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by gear category
         * @param {Array<string>} [color] Filter by gear color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultGear(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/gear`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default image library assets including textures, patterns, and images used for avatar customization
         * @summary Get default image library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
         * @param {Array<string>} [color] Filter by dominant color in image
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultImageLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/image-library`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns default model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
         * @summary Get default model library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
         * @param {Array<string>} [color] Filter by model color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultModelLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/inventory/defaults/model-library`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **DEPRECATED**: This endpoint has been removed due to unsolvable pagination issues when combining multiple asset types.  Please use type-specific endpoints instead: - `/v2/inventory/user/{userId}/gear` - Get gear/wearable items - `/v2/inventory/user/{userId}/avatar` - Get avatar items - `/v2/inventory/user/{userId}/avatar/base` - Get avatar base items - `/v2/inventory/user/{userId}/avatar/makeup` - Get makeup items - `/v2/inventory/user/{userId}/avatar/flair` - Get flair items - `/v2/inventory/user/{userId}/avatar/eyes` - Get eye items - `/v2/inventory/user/{userId}/color-presets` - Get color presets - `/v2/inventory/user/{userId}/image-library` - Get image library items - `/v2/inventory/user/{userId}/animation-library` - Get animation library items - `/v2/inventory/user/{userId}/model-library` - Get model library items  Each type-specific endpoint supports proper pagination with `limit` and `nextCursor` parameters. 
         * @summary [DEPRECATED] Get all inventory items for a user (V2)
         * @param {string} userId The ID of the user whose inventory to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2All(userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2All.');
            }
            const localVarPath = `/v2/inventory/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns animation library assets including gestures, expressions, and movements for avatar animation
         * @summary Get animation library assets for a user
         * @param {string} userId The ID of the user whose animation library assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by animation theme color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AnimationLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2AnimationLibrary.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/animation-library`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns only user avatar items for a specified user
         * @summary Get user avatar inventory items for a user (V2)
         * @param {string} userId The ID of the user whose avatar inventory to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by avatar category
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by avatar color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2Avatar(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2Avatar.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/avatar`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns avatar base customization items like hairstyles, facial features, and body characteristics
         * @summary Get base avatar customization assets for a user
         * @param {string} userId The ID of the user whose base customization assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by base color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarBase(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2AvatarBase.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/avatar/base`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns avatar eye assets like eye colors, styles, and expressions
         * @summary Get eye avatar assets for a user
         * @param {string} userId The ID of the user whose eye assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by eye color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarEyes(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2AvatarEyes.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/avatar/eyes`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
         * @summary Get flair avatar assets for a user
         * @param {string} userId The ID of the user whose flair assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by flair color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarFlair(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2AvatarFlair.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/avatar/flair`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
         * @summary Get makeup avatar assets for a user
         * @param {string} userId The ID of the user whose makeup assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by makeup color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarMakeup(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2AvatarMakeup.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/avatar/makeup`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns color preset assets that provide predefined color combinations and palettes for avatar customization
         * @summary Get color preset assets for a user
         * @param {string} userId The ID of the user whose color preset assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by dominant color in preset
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2ColorPresets(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2ColorPresets.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/color-presets`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns only decorative items (filtered from ModelLibrary with category=\"decor\") for a specified user
         * @summary Get decor inventory items for a user (V2)
         * @param {string} userId The ID of the user whose decor inventory to retrieve
         * @param {Array<string>} [category] Filter by decor subcategory
         * @param {Array<string>} [color] Filter by decor color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2Decor(userId: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2Decor.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/decor`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns only gear/wearable items for a specified user
         * @summary Get gear inventory items for a user (V2)
         * @param {string} userId The ID of the user whose gear inventory to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by gear category
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by gear color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2Gear(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2Gear.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/gear`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns image library assets including textures, patterns, and images used for avatar customization
         * @summary Get image library assets for a user
         * @param {string} userId The ID of the user whose image library assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by dominant color in image
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2ImageLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2ImageLibrary.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/image-library`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
         * @summary Get model library assets for a user
         * @param {string} userId The ID of the user whose model library assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by model color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2ModelLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getInventoryV2ModelLibrary.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/model-library`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (color) {
                localVarQueryParameter['color'] = color;
            }

            if (nextCursor !== undefined) {
                localVarQueryParameter['nextCursor'] = nextCursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all custom color presets created by the user. Supports filtering by category, app ID, and org ID.
         * @summary List all custom colors for a user
         * @param {string} userId User ID who owns the custom colors
         * @param {string} [category] Filter by category (hair, skin, or flair)
         * @param {string} [appId] Application ID to filter custom colors
         * @param {string} [orgId] Organization ID to filter custom colors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomColors(userId: string, category?: string, appId?: string, orgId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling listCustomColors.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/custom-colors`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the colors or name of an existing custom color preset. Only the owner can update their custom colors.
         * @summary Update a custom color
         * @param {UpdateCustomColorRequest} body 
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomColor(body: UpdateCustomColorRequest, userId: string, instanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateCustomColor.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateCustomColor.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling updateCustomColor.');
            }
            const localVarPath = `/v2/inventory/user/{userId}/custom-colors/{instanceId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication partyId required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("party-id")
					: configuration.apiKey;
                localVarHeaderParameter["party-id"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateCustomColorRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InventoryV2Api - functional programming interface
 * @export
 */
export const InventoryV2ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new user-generated custom color preset for hair, skin, or flair. The color will be associated with the user and can be used in avatar customization.
         * @summary Create a new custom color preset
         * @param {CreateCustomColorRequest} body 
         * @param {string} userId User ID who owns the custom color
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomColor(body: CreateCustomColorRequest, userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomColorResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).createCustomColor(body, userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a custom color preset. Only the owner can delete their custom colors.
         * @summary Delete a custom color
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomColor(userId: string, instanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteCustomColorResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).deleteCustomColor(userId, instanceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns details of a specific custom color preset by its instance ID.
         * @summary Get a specific custom color by ID
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomColor(userId: string, instanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomColorResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getCustomColor(userId, instanceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default animation library assets including gestures, expressions, and movements for avatar animation
         * @summary Get default animation library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
         * @param {Array<string>} [color] Filter by animation theme color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAnimationLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AnimationLibraryResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getDefaultAnimationLibrary(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default user avatar items filtered by organization and application
         * @summary Get default avatar items
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by avatar category
         * @param {Array<string>} [color] Filter by avatar color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatar(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getDefaultAvatar(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default base customization items for avatar editor like hairstyles, facial features, and body characteristics
         * @summary Get default base avatar customization assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
         * @param {Array<string>} [color] Filter by base color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarBase(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarBaseResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getDefaultAvatarBase(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default avatar eye assets like eye colors, styles, and expressions
         * @summary Get default eye avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
         * @param {Array<string>} [color] Filter by eye color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarEyes(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarEyesResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getDefaultAvatarEyes(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
         * @summary Get default flair avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
         * @param {Array<string>} [color] Filter by flair color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarFlair(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarFlairResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getDefaultAvatarFlair(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
         * @summary Get default makeup avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
         * @param {Array<string>} [color] Filter by makeup color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarMakeup(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarMakeupResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getDefaultAvatarMakeup(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default color preset assets that provide predefined color combinations and palettes for avatar customization
         * @summary Get default color preset assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
         * @param {Array<string>} [color] Filter by dominant color in preset
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultColorPresets(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2ColorPresetsResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getDefaultColorPresets(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default decorative items filtered by organization and application
         * @summary Get default decor items
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by decor category
         * @param {Array<string>} [color] Filter by decor color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultDecor(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2DecorResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getDefaultDecor(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default gear/wearable items filtered by organization and application
         * @summary Get default gear items
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by gear category
         * @param {Array<string>} [color] Filter by gear color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultGear(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2GearResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getDefaultGear(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default image library assets including textures, patterns, and images used for avatar customization
         * @summary Get default image library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
         * @param {Array<string>} [color] Filter by dominant color in image
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultImageLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2ImageLibraryResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getDefaultImageLibrary(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns default model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
         * @summary Get default model library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
         * @param {Array<string>} [color] Filter by model color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultModelLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2ModelLibraryResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getDefaultModelLibrary(orgId, appId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **DEPRECATED**: This endpoint has been removed due to unsolvable pagination issues when combining multiple asset types.  Please use type-specific endpoints instead: - `/v2/inventory/user/{userId}/gear` - Get gear/wearable items - `/v2/inventory/user/{userId}/avatar` - Get avatar items - `/v2/inventory/user/{userId}/avatar/base` - Get avatar base items - `/v2/inventory/user/{userId}/avatar/makeup` - Get makeup items - `/v2/inventory/user/{userId}/avatar/flair` - Get flair items - `/v2/inventory/user/{userId}/avatar/eyes` - Get eye items - `/v2/inventory/user/{userId}/color-presets` - Get color presets - `/v2/inventory/user/{userId}/image-library` - Get image library items - `/v2/inventory/user/{userId}/animation-library` - Get animation library items - `/v2/inventory/user/{userId}/model-library` - Get model library items  Each type-specific endpoint supports proper pagination with `limit` and `nextCursor` parameters. 
         * @summary [DEPRECATED] Get all inventory items for a user (V2)
         * @param {string} userId The ID of the user whose inventory to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2All(userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getInventoryV2All(userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns animation library assets including gestures, expressions, and movements for avatar animation
         * @summary Get animation library assets for a user
         * @param {string} userId The ID of the user whose animation library assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by animation theme color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AnimationLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AnimationLibraryResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getInventoryV2AnimationLibrary(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns only user avatar items for a specified user
         * @summary Get user avatar inventory items for a user (V2)
         * @param {string} userId The ID of the user whose avatar inventory to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by avatar category
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by avatar color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2Avatar(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getInventoryV2Avatar(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns avatar base customization items like hairstyles, facial features, and body characteristics
         * @summary Get base avatar customization assets for a user
         * @param {string} userId The ID of the user whose base customization assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by base color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarBase(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarBaseResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getInventoryV2AvatarBase(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns avatar eye assets like eye colors, styles, and expressions
         * @summary Get eye avatar assets for a user
         * @param {string} userId The ID of the user whose eye assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by eye color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarEyes(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarEyesResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getInventoryV2AvatarEyes(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
         * @summary Get flair avatar assets for a user
         * @param {string} userId The ID of the user whose flair assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by flair color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarFlair(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarFlairResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getInventoryV2AvatarFlair(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
         * @summary Get makeup avatar assets for a user
         * @param {string} userId The ID of the user whose makeup assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by makeup color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarMakeup(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2AvatarMakeupResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getInventoryV2AvatarMakeup(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns color preset assets that provide predefined color combinations and palettes for avatar customization
         * @summary Get color preset assets for a user
         * @param {string} userId The ID of the user whose color preset assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by dominant color in preset
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2ColorPresets(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2ColorPresetsResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getInventoryV2ColorPresets(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns only decorative items (filtered from ModelLibrary with category=\"decor\") for a specified user
         * @summary Get decor inventory items for a user (V2)
         * @param {string} userId The ID of the user whose decor inventory to retrieve
         * @param {Array<string>} [category] Filter by decor subcategory
         * @param {Array<string>} [color] Filter by decor color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2Decor(userId: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2DecorResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getInventoryV2Decor(userId, category, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns only gear/wearable items for a specified user
         * @summary Get gear inventory items for a user (V2)
         * @param {string} userId The ID of the user whose gear inventory to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by gear category
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by gear color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2Gear(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2GearResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getInventoryV2Gear(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns image library assets including textures, patterns, and images used for avatar customization
         * @summary Get image library assets for a user
         * @param {string} userId The ID of the user whose image library assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by dominant color in image
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2ImageLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2ImageLibraryResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getInventoryV2ImageLibrary(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
         * @summary Get model library assets for a user
         * @param {string} userId The ID of the user whose model library assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by model color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2ModelLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInventoryV2ModelLibraryResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).getInventoryV2ModelLibrary(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all custom color presets created by the user. Supports filtering by category, app ID, and org ID.
         * @summary List all custom colors for a user
         * @param {string} userId User ID who owns the custom colors
         * @param {string} [category] Filter by category (hair, skin, or flair)
         * @param {string} [appId] Application ID to filter custom colors
         * @param {string} [orgId] Organization ID to filter custom colors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomColors(userId: string, category?: string, appId?: string, orgId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListCustomColorsResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).listCustomColors(userId, category, appId, orgId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the colors or name of an existing custom color preset. Only the owner can update their custom colors.
         * @summary Update a custom color
         * @param {UpdateCustomColorRequest} body 
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomColor(body: UpdateCustomColorRequest, userId: string, instanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomColorResponse> {
            const localVarFetchArgs = InventoryV2ApiFetchParamCreator(configuration).updateCustomColor(body, userId, instanceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InventoryV2Api - factory interface
 * @export
 */
export const InventoryV2ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a new user-generated custom color preset for hair, skin, or flair. The color will be associated with the user and can be used in avatar customization.
         * @summary Create a new custom color preset
         * @param {CreateCustomColorRequest} body 
         * @param {string} userId User ID who owns the custom color
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomColor(body: CreateCustomColorRequest, userId: string, options?: any) {
            return InventoryV2ApiFp(configuration).createCustomColor(body, userId, options)(fetch, basePath);
        },
        /**
         * Deletes a custom color preset. Only the owner can delete their custom colors.
         * @summary Delete a custom color
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomColor(userId: string, instanceId: string, options?: any) {
            return InventoryV2ApiFp(configuration).deleteCustomColor(userId, instanceId, options)(fetch, basePath);
        },
        /**
         * Returns details of a specific custom color preset by its instance ID.
         * @summary Get a specific custom color by ID
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomColor(userId: string, instanceId: string, options?: any) {
            return InventoryV2ApiFp(configuration).getCustomColor(userId, instanceId, options)(fetch, basePath);
        },
        /**
         * Returns default animation library assets including gestures, expressions, and movements for avatar animation
         * @summary Get default animation library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
         * @param {Array<string>} [color] Filter by animation theme color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAnimationLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getDefaultAnimationLibrary(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default user avatar items filtered by organization and application
         * @summary Get default avatar items
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by avatar category
         * @param {Array<string>} [color] Filter by avatar color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatar(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getDefaultAvatar(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default base customization items for avatar editor like hairstyles, facial features, and body characteristics
         * @summary Get default base avatar customization assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
         * @param {Array<string>} [color] Filter by base color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarBase(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getDefaultAvatarBase(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default avatar eye assets like eye colors, styles, and expressions
         * @summary Get default eye avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
         * @param {Array<string>} [color] Filter by eye color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarEyes(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getDefaultAvatarEyes(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
         * @summary Get default flair avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
         * @param {Array<string>} [color] Filter by flair color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarFlair(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getDefaultAvatarFlair(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
         * @summary Get default makeup avatar assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
         * @param {Array<string>} [color] Filter by makeup color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultAvatarMakeup(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getDefaultAvatarMakeup(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default color preset assets that provide predefined color combinations and palettes for avatar customization
         * @summary Get default color preset assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
         * @param {Array<string>} [color] Filter by dominant color in preset
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultColorPresets(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getDefaultColorPresets(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default decorative items filtered by organization and application
         * @summary Get default decor items
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by decor category
         * @param {Array<string>} [color] Filter by decor color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultDecor(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getDefaultDecor(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default gear/wearable items filtered by organization and application
         * @summary Get default gear items
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by gear category
         * @param {Array<string>} [color] Filter by gear color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultGear(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getDefaultGear(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default image library assets including textures, patterns, and images used for avatar customization
         * @summary Get default image library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
         * @param {Array<string>} [color] Filter by dominant color in image
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultImageLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getDefaultImageLibrary(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns default model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
         * @summary Get default model library assets
         * @param {string} [orgId] Organization ID to filter default items
         * @param {string} [appId] Application ID to filter default items
         * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
         * @param {Array<string>} [color] Filter by model color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultModelLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getDefaultModelLibrary(orgId, appId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * **DEPRECATED**: This endpoint has been removed due to unsolvable pagination issues when combining multiple asset types.  Please use type-specific endpoints instead: - `/v2/inventory/user/{userId}/gear` - Get gear/wearable items - `/v2/inventory/user/{userId}/avatar` - Get avatar items - `/v2/inventory/user/{userId}/avatar/base` - Get avatar base items - `/v2/inventory/user/{userId}/avatar/makeup` - Get makeup items - `/v2/inventory/user/{userId}/avatar/flair` - Get flair items - `/v2/inventory/user/{userId}/avatar/eyes` - Get eye items - `/v2/inventory/user/{userId}/color-presets` - Get color presets - `/v2/inventory/user/{userId}/image-library` - Get image library items - `/v2/inventory/user/{userId}/animation-library` - Get animation library items - `/v2/inventory/user/{userId}/model-library` - Get model library items  Each type-specific endpoint supports proper pagination with `limit` and `nextCursor` parameters. 
         * @summary [DEPRECATED] Get all inventory items for a user (V2)
         * @param {string} userId The ID of the user whose inventory to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2All(userId: string, options?: any) {
            return InventoryV2ApiFp(configuration).getInventoryV2All(userId, options)(fetch, basePath);
        },
        /**
         * Returns animation library assets including gestures, expressions, and movements for avatar animation
         * @summary Get animation library assets for a user
         * @param {string} userId The ID of the user whose animation library assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by animation theme color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AnimationLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getInventoryV2AnimationLibrary(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns only user avatar items for a specified user
         * @summary Get user avatar inventory items for a user (V2)
         * @param {string} userId The ID of the user whose avatar inventory to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by avatar category
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by avatar color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2Avatar(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getInventoryV2Avatar(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns avatar base customization items like hairstyles, facial features, and body characteristics
         * @summary Get base avatar customization assets for a user
         * @param {string} userId The ID of the user whose base customization assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by base color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarBase(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getInventoryV2AvatarBase(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns avatar eye assets like eye colors, styles, and expressions
         * @summary Get eye avatar assets for a user
         * @param {string} userId The ID of the user whose eye assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by eye color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarEyes(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getInventoryV2AvatarEyes(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
         * @summary Get flair avatar assets for a user
         * @param {string} userId The ID of the user whose flair assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by flair color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarFlair(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getInventoryV2AvatarFlair(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
         * @summary Get makeup avatar assets for a user
         * @param {string} userId The ID of the user whose makeup assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by makeup color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2AvatarMakeup(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getInventoryV2AvatarMakeup(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns color preset assets that provide predefined color combinations and palettes for avatar customization
         * @summary Get color preset assets for a user
         * @param {string} userId The ID of the user whose color preset assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by dominant color in preset
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2ColorPresets(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getInventoryV2ColorPresets(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns only decorative items (filtered from ModelLibrary with category=\"decor\") for a specified user
         * @summary Get decor inventory items for a user (V2)
         * @param {string} userId The ID of the user whose decor inventory to retrieve
         * @param {Array<string>} [category] Filter by decor subcategory
         * @param {Array<string>} [color] Filter by decor color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2Decor(userId: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getInventoryV2Decor(userId, category, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns only gear/wearable items for a specified user
         * @summary Get gear inventory items for a user (V2)
         * @param {string} userId The ID of the user whose gear inventory to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by gear category
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by gear color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2Gear(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getInventoryV2Gear(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns image library assets including textures, patterns, and images used for avatar customization
         * @summary Get image library assets for a user
         * @param {string} userId The ID of the user whose image library assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by dominant color in image
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2ImageLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getInventoryV2ImageLibrary(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns all model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
         * @summary Get model library assets for a user
         * @param {string} userId The ID of the user whose model library assets to retrieve
         * @param {string} [appId] Application ID to filter inventory items
         * @param {string} [orgId] Organization ID to filter inventory items
         * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
         * @param {Array<string>} [subcategory] Filter by item subcategory
         * @param {Array<string>} [color] Filter by model color
         * @param {string} [nextCursor] Pagination cursor for the next page of results
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryV2ModelLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
            return InventoryV2ApiFp(configuration).getInventoryV2ModelLibrary(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(fetch, basePath);
        },
        /**
         * Returns all custom color presets created by the user. Supports filtering by category, app ID, and org ID.
         * @summary List all custom colors for a user
         * @param {string} userId User ID who owns the custom colors
         * @param {string} [category] Filter by category (hair, skin, or flair)
         * @param {string} [appId] Application ID to filter custom colors
         * @param {string} [orgId] Organization ID to filter custom colors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomColors(userId: string, category?: string, appId?: string, orgId?: string, options?: any) {
            return InventoryV2ApiFp(configuration).listCustomColors(userId, category, appId, orgId, options)(fetch, basePath);
        },
        /**
         * Updates the colors or name of an existing custom color preset. Only the owner can update their custom colors.
         * @summary Update a custom color
         * @param {UpdateCustomColorRequest} body 
         * @param {string} userId User ID who owns the custom color
         * @param {string} instanceId Instance ID of the custom color to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomColor(body: UpdateCustomColorRequest, userId: string, instanceId: string, options?: any) {
            return InventoryV2ApiFp(configuration).updateCustomColor(body, userId, instanceId, options)(fetch, basePath);
        },
    };
};

/**
 * InventoryV2Api - object-oriented interface
 * @export
 * @class InventoryV2Api
 * @extends {BaseAPI}
 */
export class InventoryV2Api extends BaseAPI {
    /**
     * Creates a new user-generated custom color preset for hair, skin, or flair. The color will be associated with the user and can be used in avatar customization.
     * @summary Create a new custom color preset
     * @param {CreateCustomColorRequest} body 
     * @param {string} userId User ID who owns the custom color
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public createCustomColor(body: CreateCustomColorRequest, userId: string, options?: any) {
        return InventoryV2ApiFp(this.configuration).createCustomColor(body, userId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a custom color preset. Only the owner can delete their custom colors.
     * @summary Delete a custom color
     * @param {string} userId User ID who owns the custom color
     * @param {string} instanceId Instance ID of the custom color to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public deleteCustomColor(userId: string, instanceId: string, options?: any) {
        return InventoryV2ApiFp(this.configuration).deleteCustomColor(userId, instanceId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns details of a specific custom color preset by its instance ID.
     * @summary Get a specific custom color by ID
     * @param {string} userId User ID who owns the custom color
     * @param {string} instanceId Instance ID of the custom color
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getCustomColor(userId: string, instanceId: string, options?: any) {
        return InventoryV2ApiFp(this.configuration).getCustomColor(userId, instanceId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default animation library assets including gestures, expressions, and movements for avatar animation
     * @summary Get default animation library assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
     * @param {Array<string>} [color] Filter by animation theme color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getDefaultAnimationLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getDefaultAnimationLibrary(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default user avatar items filtered by organization and application
     * @summary Get default avatar items
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by avatar category
     * @param {Array<string>} [color] Filter by avatar color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getDefaultAvatar(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getDefaultAvatar(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default base customization items for avatar editor like hairstyles, facial features, and body characteristics
     * @summary Get default base avatar customization assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
     * @param {Array<string>} [color] Filter by base color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getDefaultAvatarBase(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getDefaultAvatarBase(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default avatar eye assets like eye colors, styles, and expressions
     * @summary Get default eye avatar assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
     * @param {Array<string>} [color] Filter by eye color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getDefaultAvatarEyes(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getDefaultAvatarEyes(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
     * @summary Get default flair avatar assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
     * @param {Array<string>} [color] Filter by flair color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getDefaultAvatarFlair(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getDefaultAvatarFlair(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
     * @summary Get default makeup avatar assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
     * @param {Array<string>} [color] Filter by makeup color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getDefaultAvatarMakeup(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getDefaultAvatarMakeup(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default color preset assets that provide predefined color combinations and palettes for avatar customization
     * @summary Get default color preset assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
     * @param {Array<string>} [color] Filter by dominant color in preset
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getDefaultColorPresets(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getDefaultColorPresets(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default decorative items filtered by organization and application
     * @summary Get default decor items
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by decor category
     * @param {Array<string>} [color] Filter by decor color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getDefaultDecor(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getDefaultDecor(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default gear/wearable items filtered by organization and application
     * @summary Get default gear items
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by gear category
     * @param {Array<string>} [color] Filter by gear color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getDefaultGear(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getDefaultGear(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default image library assets including textures, patterns, and images used for avatar customization
     * @summary Get default image library assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
     * @param {Array<string>} [color] Filter by dominant color in image
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getDefaultImageLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getDefaultImageLibrary(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns default model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
     * @summary Get default model library assets
     * @param {string} [orgId] Organization ID to filter default items
     * @param {string} [appId] Application ID to filter default items
     * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
     * @param {Array<string>} [color] Filter by model color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getDefaultModelLibrary(orgId?: string, appId?: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getDefaultModelLibrary(orgId, appId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * **DEPRECATED**: This endpoint has been removed due to unsolvable pagination issues when combining multiple asset types.  Please use type-specific endpoints instead: - `/v2/inventory/user/{userId}/gear` - Get gear/wearable items - `/v2/inventory/user/{userId}/avatar` - Get avatar items - `/v2/inventory/user/{userId}/avatar/base` - Get avatar base items - `/v2/inventory/user/{userId}/avatar/makeup` - Get makeup items - `/v2/inventory/user/{userId}/avatar/flair` - Get flair items - `/v2/inventory/user/{userId}/avatar/eyes` - Get eye items - `/v2/inventory/user/{userId}/color-presets` - Get color presets - `/v2/inventory/user/{userId}/image-library` - Get image library items - `/v2/inventory/user/{userId}/animation-library` - Get animation library items - `/v2/inventory/user/{userId}/model-library` - Get model library items  Each type-specific endpoint supports proper pagination with `limit` and `nextCursor` parameters. 
     * @summary [DEPRECATED] Get all inventory items for a user (V2)
     * @param {string} userId The ID of the user whose inventory to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getInventoryV2All(userId: string, options?: any) {
        return InventoryV2ApiFp(this.configuration).getInventoryV2All(userId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns animation library assets including gestures, expressions, and movements for avatar animation
     * @summary Get animation library assets for a user
     * @param {string} userId The ID of the user whose animation library assets to retrieve
     * @param {string} [appId] Application ID to filter inventory items
     * @param {string} [orgId] Organization ID to filter inventory items
     * @param {Array<string>} [category] Filter by animation category (e.g., dance, gesture, expression)
     * @param {Array<string>} [subcategory] Filter by item subcategory
     * @param {Array<string>} [color] Filter by animation theme color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getInventoryV2AnimationLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getInventoryV2AnimationLibrary(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns only user avatar items for a specified user
     * @summary Get user avatar inventory items for a user (V2)
     * @param {string} userId The ID of the user whose avatar inventory to retrieve
     * @param {string} [appId] Application ID to filter inventory items
     * @param {string} [orgId] Organization ID to filter inventory items
     * @param {Array<string>} [category] Filter by avatar category
     * @param {Array<string>} [subcategory] Filter by item subcategory
     * @param {Array<string>} [color] Filter by avatar color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getInventoryV2Avatar(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getInventoryV2Avatar(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns avatar base customization items like hairstyles, facial features, and body characteristics
     * @summary Get base avatar customization assets for a user
     * @param {string} userId The ID of the user whose base customization assets to retrieve
     * @param {string} [appId] Application ID to filter inventory items
     * @param {string} [orgId] Organization ID to filter inventory items
     * @param {Array<string>} [category] Filter by base category (e.g., hair, face, body)
     * @param {Array<string>} [subcategory] Filter by item subcategory
     * @param {Array<string>} [color] Filter by base color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getInventoryV2AvatarBase(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getInventoryV2AvatarBase(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns avatar eye assets like eye colors, styles, and expressions
     * @summary Get eye avatar assets for a user
     * @param {string} userId The ID of the user whose eye assets to retrieve
     * @param {string} [appId] Application ID to filter inventory items
     * @param {string} [orgId] Organization ID to filter inventory items
     * @param {Array<string>} [category] Filter by eye category (e.g., color, style, expression)
     * @param {Array<string>} [subcategory] Filter by item subcategory
     * @param {Array<string>} [color] Filter by eye color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getInventoryV2AvatarEyes(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getInventoryV2AvatarEyes(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns avatar flair assets like jewelry, accessories, and decorative items that enhance the avatar's appearance
     * @summary Get flair avatar assets for a user
     * @param {string} userId The ID of the user whose flair assets to retrieve
     * @param {string} [appId] Application ID to filter inventory items
     * @param {string} [orgId] Organization ID to filter inventory items
     * @param {Array<string>} [category] Filter by flair category (e.g., jewelry, accessories, piercings)
     * @param {Array<string>} [subcategory] Filter by item subcategory
     * @param {Array<string>} [color] Filter by flair color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getInventoryV2AvatarFlair(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getInventoryV2AvatarFlair(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns avatar makeup assets like lipstick, eyeshadow, blush, and other cosmetic items
     * @summary Get makeup avatar assets for a user
     * @param {string} userId The ID of the user whose makeup assets to retrieve
     * @param {string} [appId] Application ID to filter inventory items
     * @param {string} [orgId] Organization ID to filter inventory items
     * @param {Array<string>} [category] Filter by makeup category (e.g., lipstick, eyeshadow, blush)
     * @param {Array<string>} [subcategory] Filter by item subcategory
     * @param {Array<string>} [color] Filter by makeup color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getInventoryV2AvatarMakeup(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getInventoryV2AvatarMakeup(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns color preset assets that provide predefined color combinations and palettes for avatar customization
     * @summary Get color preset assets for a user
     * @param {string} userId The ID of the user whose color preset assets to retrieve
     * @param {string} [appId] Application ID to filter inventory items
     * @param {string} [orgId] Organization ID to filter inventory items
     * @param {Array<string>} [category] Filter by color preset category (e.g., skin, hair, theme)
     * @param {Array<string>} [subcategory] Filter by item subcategory
     * @param {Array<string>} [color] Filter by dominant color in preset
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getInventoryV2ColorPresets(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getInventoryV2ColorPresets(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns only decorative items (filtered from ModelLibrary with category=\"decor\") for a specified user
     * @summary Get decor inventory items for a user (V2)
     * @param {string} userId The ID of the user whose decor inventory to retrieve
     * @param {Array<string>} [category] Filter by decor subcategory
     * @param {Array<string>} [color] Filter by decor color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getInventoryV2Decor(userId: string, category?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getInventoryV2Decor(userId, category, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns only gear/wearable items for a specified user
     * @summary Get gear inventory items for a user (V2)
     * @param {string} userId The ID of the user whose gear inventory to retrieve
     * @param {string} [appId] Application ID to filter inventory items
     * @param {string} [orgId] Organization ID to filter inventory items
     * @param {Array<string>} [category] Filter by gear category
     * @param {Array<string>} [subcategory] Filter by item subcategory
     * @param {Array<string>} [color] Filter by gear color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getInventoryV2Gear(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getInventoryV2Gear(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns image library assets including textures, patterns, and images used for avatar customization
     * @summary Get image library assets for a user
     * @param {string} userId The ID of the user whose image library assets to retrieve
     * @param {string} [appId] Application ID to filter inventory items
     * @param {string} [orgId] Organization ID to filter inventory items
     * @param {Array<string>} [category] Filter by image category (e.g., texture, pattern, decal)
     * @param {Array<string>} [subcategory] Filter by item subcategory
     * @param {Array<string>} [color] Filter by dominant color in image
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getInventoryV2ImageLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getInventoryV2ImageLibrary(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all model library assets including furniture, decor, and 3D objects (includes items that would be filtered separately in /decor endpoint)
     * @summary Get model library assets for a user
     * @param {string} userId The ID of the user whose model library assets to retrieve
     * @param {string} [appId] Application ID to filter inventory items
     * @param {string} [orgId] Organization ID to filter inventory items
     * @param {Array<string>} [category] Filter by model category (e.g., furniture, decor, lighting, architecture)
     * @param {Array<string>} [subcategory] Filter by item subcategory
     * @param {Array<string>} [color] Filter by model color
     * @param {string} [nextCursor] Pagination cursor for the next page of results
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public getInventoryV2ModelLibrary(userId: string, appId?: string, orgId?: string, category?: Array<string>, subcategory?: Array<string>, color?: Array<string>, nextCursor?: string, limit?: number, options?: any) {
        return InventoryV2ApiFp(this.configuration).getInventoryV2ModelLibrary(userId, appId, orgId, category, subcategory, color, nextCursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all custom color presets created by the user. Supports filtering by category, app ID, and org ID.
     * @summary List all custom colors for a user
     * @param {string} userId User ID who owns the custom colors
     * @param {string} [category] Filter by category (hair, skin, or flair)
     * @param {string} [appId] Application ID to filter custom colors
     * @param {string} [orgId] Organization ID to filter custom colors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public listCustomColors(userId: string, category?: string, appId?: string, orgId?: string, options?: any) {
        return InventoryV2ApiFp(this.configuration).listCustomColors(userId, category, appId, orgId, options)(this.fetch, this.basePath);
    }

    /**
     * Updates the colors or name of an existing custom color preset. Only the owner can update their custom colors.
     * @summary Update a custom color
     * @param {UpdateCustomColorRequest} body 
     * @param {string} userId User ID who owns the custom color
     * @param {string} instanceId Instance ID of the custom color to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryV2Api
     */
    public updateCustomColor(body: UpdateCustomColorRequest, userId: string, instanceId: string, options?: any) {
        return InventoryV2ApiFp(this.configuration).updateCustomColor(body, userId, instanceId, options)(this.fetch, this.basePath);
    }

}
/**
 * LeaderboardApi - fetch parameter creator
 * @export
 */
export const LeaderboardApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a leaderboard for an experience.
         * @summary Create Leaderboard
         * @param {LeaderboardCreateRequest} body Create a leaderboard
         * @param {string} experienceId The experience ID for which the leaderboard is being created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboard(body: LeaderboardCreateRequest, experienceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createLeaderboard.');
            }
            // verify required parameter 'experienceId' is not null or undefined
            if (experienceId === null || experienceId === undefined) {
                throw new RequiredError('experienceId','Required parameter experienceId was null or undefined when calling createLeaderboard.');
            }
            const localVarPath = `/admin/leaderboard/experience/{experienceId}`
                .replace(`{${"experienceId"}}`, encodeURIComponent(String(experienceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LeaderboardCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Leaderboard
         * @param {string} leaderboardId leaderboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboard(leaderboardId: string, options: any = {}): FetchArgs {
            // verify required parameter 'leaderboardId' is not null or undefined
            if (leaderboardId === null || leaderboardId === undefined) {
                throw new RequiredError('leaderboardId','Required parameter leaderboardId was null or undefined when calling deleteLeaderboard.');
            }
            const localVarPath = `/admin/leaderboard/{leaderboardId}`
                .replace(`{${"leaderboardId"}}`, encodeURIComponent(String(leaderboardId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset Leaderboard
         * @param {string} leaderboardId leaderboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLeaderboard(leaderboardId: string, options: any = {}): FetchArgs {
            // verify required parameter 'leaderboardId' is not null or undefined
            if (leaderboardId === null || leaderboardId === undefined) {
                throw new RequiredError('leaderboardId','Required parameter leaderboardId was null or undefined when calling resetLeaderboard.');
            }
            const localVarPath = `/admin/leaderboard/{leaderboardId}`
                .replace(`{${"leaderboardId"}}`, encodeURIComponent(String(leaderboardId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeaderboardApi - functional programming interface
 * @export
 */
export const LeaderboardApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a leaderboard for an experience.
         * @summary Create Leaderboard
         * @param {LeaderboardCreateRequest} body Create a leaderboard
         * @param {string} experienceId The experience ID for which the leaderboard is being created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboard(body: LeaderboardCreateRequest, experienceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeaderboardCreateResponse> {
            const localVarFetchArgs = LeaderboardApiFetchParamCreator(configuration).createLeaderboard(body, experienceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete Leaderboard
         * @param {string} leaderboardId leaderboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboard(leaderboardId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
            const localVarFetchArgs = LeaderboardApiFetchParamCreator(configuration).deleteLeaderboard(leaderboardId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Reset Leaderboard
         * @param {string} leaderboardId leaderboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLeaderboard(leaderboardId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
            const localVarFetchArgs = LeaderboardApiFetchParamCreator(configuration).resetLeaderboard(leaderboardId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LeaderboardApi - factory interface
 * @export
 */
export const LeaderboardApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a leaderboard for an experience.
         * @summary Create Leaderboard
         * @param {LeaderboardCreateRequest} body Create a leaderboard
         * @param {string} experienceId The experience ID for which the leaderboard is being created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboard(body: LeaderboardCreateRequest, experienceId: string, options?: any) {
            return LeaderboardApiFp(configuration).createLeaderboard(body, experienceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete Leaderboard
         * @param {string} leaderboardId leaderboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboard(leaderboardId: string, options?: any) {
            return LeaderboardApiFp(configuration).deleteLeaderboard(leaderboardId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset Leaderboard
         * @param {string} leaderboardId leaderboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLeaderboard(leaderboardId: string, options?: any) {
            return LeaderboardApiFp(configuration).resetLeaderboard(leaderboardId, options)(fetch, basePath);
        },
    };
};

/**
 * LeaderboardApi - object-oriented interface
 * @export
 * @class LeaderboardApi
 * @extends {BaseAPI}
 */
export class LeaderboardApi extends BaseAPI {
    /**
     * Create a leaderboard for an experience.
     * @summary Create Leaderboard
     * @param {LeaderboardCreateRequest} body Create a leaderboard
     * @param {string} experienceId The experience ID for which the leaderboard is being created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    public createLeaderboard(body: LeaderboardCreateRequest, experienceId: string, options?: any) {
        return LeaderboardApiFp(this.configuration).createLeaderboard(body, experienceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete Leaderboard
     * @param {string} leaderboardId leaderboard ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    public deleteLeaderboard(leaderboardId: string, options?: any) {
        return LeaderboardApiFp(this.configuration).deleteLeaderboard(leaderboardId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Reset Leaderboard
     * @param {string} leaderboardId leaderboard ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    public resetLeaderboard(leaderboardId: string, options?: any) {
        return LeaderboardApiFp(this.configuration).resetLeaderboard(leaderboardId, options)(this.fetch, this.basePath);
    }

}
/**
 * MetadataStoreManagerApi - fetch parameter creator
 * @export
 */
export const MetadataStoreManagerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates the tag_defaultCloset metadata store with indexed fields for orgId, appId, and isDefault
         * @summary Create tag_defaultCloset metadata namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDefaultClosetNamespace(options: any = {}): FetchArgs {
            const localVarPath = `/admin/inventory/metadata-stores/default-closet-namespace`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an asset supply and tags it with the tag_defaultCloset namespace for use as a default item.  **Important**: Before calling this endpoint, ensure the asset has been properly tagged with relevant metadata in the following namespaces: - `tag_name` (name) - `tag_description` (description, longDescription) - `tag_category` (category) - `tag_subcategories` (subcategories) - `tag_colors` or `tag_colorsHex` (colors array) - `tag_origin` (origin tag for filtering) - `tag_mood` (for AnimationLibrary assets) - `tag_protocol` (protocolTags for AnimationLibrary assets) - `pipeline_0` (pipeline version information)  This endpoint specifically tags the asset as a default item for the specified orgId/appId combination. 
         * @summary Create a default item
         * @param {CreateDefaultItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDefaultItem(body: CreateDefaultItemRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createDefaultItem.');
            }
            const localVarPath = `/admin/inventory/metadata-stores/default-item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateDefaultItemRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves information about all available metadata stores and their configurations
         * @summary Get all metadata stores
         * @param {string} [type] Filter stores by type (core, app-specific, instance)
         * @param {string} [appId] Application ID to filter app-specific stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMetadataStores(type?: string, appId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/admin/inventory/metadata-stores`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication clientHash required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-client-hash")
					: configuration.apiKey;
                localVarHeaderParameter["x-client-hash"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (appId !== undefined) {
                localVarQueryParameter['appId'] = appId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetadataStoreManagerApi - functional programming interface
 * @export
 */
export const MetadataStoreManagerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates the tag_defaultCloset metadata store with indexed fields for orgId, appId, and isDefault
         * @summary Create tag_defaultCloset metadata namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDefaultClosetNamespace(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateDefaultClosetNamespaceResponse> {
            const localVarFetchArgs = MetadataStoreManagerApiFetchParamCreator(configuration).createDefaultClosetNamespace(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates an asset supply and tags it with the tag_defaultCloset namespace for use as a default item.  **Important**: Before calling this endpoint, ensure the asset has been properly tagged with relevant metadata in the following namespaces: - `tag_name` (name) - `tag_description` (description, longDescription) - `tag_category` (category) - `tag_subcategories` (subcategories) - `tag_colors` or `tag_colorsHex` (colors array) - `tag_origin` (origin tag for filtering) - `tag_mood` (for AnimationLibrary assets) - `tag_protocol` (protocolTags for AnimationLibrary assets) - `pipeline_0` (pipeline version information)  This endpoint specifically tags the asset as a default item for the specified orgId/appId combination. 
         * @summary Create a default item
         * @param {CreateDefaultItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDefaultItem(body: CreateDefaultItemRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateDefaultItemResponse> {
            const localVarFetchArgs = MetadataStoreManagerApiFetchParamCreator(configuration).createDefaultItem(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves information about all available metadata stores and their configurations
         * @summary Get all metadata stores
         * @param {string} [type] Filter stores by type (core, app-specific, instance)
         * @param {string} [appId] Application ID to filter app-specific stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMetadataStores(type?: string, appId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAllStoresResponse> {
            const localVarFetchArgs = MetadataStoreManagerApiFetchParamCreator(configuration).getAllMetadataStores(type, appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MetadataStoreManagerApi - factory interface
 * @export
 */
export const MetadataStoreManagerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates the tag_defaultCloset metadata store with indexed fields for orgId, appId, and isDefault
         * @summary Create tag_defaultCloset metadata namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDefaultClosetNamespace(options?: any) {
            return MetadataStoreManagerApiFp(configuration).createDefaultClosetNamespace(options)(fetch, basePath);
        },
        /**
         * Creates an asset supply and tags it with the tag_defaultCloset namespace for use as a default item.  **Important**: Before calling this endpoint, ensure the asset has been properly tagged with relevant metadata in the following namespaces: - `tag_name` (name) - `tag_description` (description, longDescription) - `tag_category` (category) - `tag_subcategories` (subcategories) - `tag_colors` or `tag_colorsHex` (colors array) - `tag_origin` (origin tag for filtering) - `tag_mood` (for AnimationLibrary assets) - `tag_protocol` (protocolTags for AnimationLibrary assets) - `pipeline_0` (pipeline version information)  This endpoint specifically tags the asset as a default item for the specified orgId/appId combination. 
         * @summary Create a default item
         * @param {CreateDefaultItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDefaultItem(body: CreateDefaultItemRequest, options?: any) {
            return MetadataStoreManagerApiFp(configuration).createDefaultItem(body, options)(fetch, basePath);
        },
        /**
         * Retrieves information about all available metadata stores and their configurations
         * @summary Get all metadata stores
         * @param {string} [type] Filter stores by type (core, app-specific, instance)
         * @param {string} [appId] Application ID to filter app-specific stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMetadataStores(type?: string, appId?: string, options?: any) {
            return MetadataStoreManagerApiFp(configuration).getAllMetadataStores(type, appId, options)(fetch, basePath);
        },
    };
};

/**
 * MetadataStoreManagerApi - object-oriented interface
 * @export
 * @class MetadataStoreManagerApi
 * @extends {BaseAPI}
 */
export class MetadataStoreManagerApi extends BaseAPI {
    /**
     * Creates the tag_defaultCloset metadata store with indexed fields for orgId, appId, and isDefault
     * @summary Create tag_defaultCloset metadata namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataStoreManagerApi
     */
    public createDefaultClosetNamespace(options?: any) {
        return MetadataStoreManagerApiFp(this.configuration).createDefaultClosetNamespace(options)(this.fetch, this.basePath);
    }

    /**
     * Creates an asset supply and tags it with the tag_defaultCloset namespace for use as a default item.  **Important**: Before calling this endpoint, ensure the asset has been properly tagged with relevant metadata in the following namespaces: - `tag_name` (name) - `tag_description` (description, longDescription) - `tag_category` (category) - `tag_subcategories` (subcategories) - `tag_colors` or `tag_colorsHex` (colors array) - `tag_origin` (origin tag for filtering) - `tag_mood` (for AnimationLibrary assets) - `tag_protocol` (protocolTags for AnimationLibrary assets) - `pipeline_0` (pipeline version information)  This endpoint specifically tags the asset as a default item for the specified orgId/appId combination. 
     * @summary Create a default item
     * @param {CreateDefaultItemRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataStoreManagerApi
     */
    public createDefaultItem(body: CreateDefaultItemRequest, options?: any) {
        return MetadataStoreManagerApiFp(this.configuration).createDefaultItem(body, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves information about all available metadata stores and their configurations
     * @summary Get all metadata stores
     * @param {string} [type] Filter stores by type (core, app-specific, instance)
     * @param {string} [appId] Application ID to filter app-specific stores
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataStoreManagerApi
     */
    public getAllMetadataStores(type?: string, appId?: string, options?: any) {
        return MetadataStoreManagerApiFp(this.configuration).getAllMetadataStores(type, appId, options)(this.fetch, this.basePath);
    }

}
