/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Genies Devkit API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.1.21
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from 'url';
import * as isomorphicFetch from 'isomorphic-fetch';
import { Configuration } from './configuration';

const BASE_PATH =
  'https://virtserver.swaggerhub.com/Genies/Genies_Devkit_API/1.1.21'.replace(
    /\/+$/,
    '',
  );

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = isomorphicFetch,
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name = 'RequiredError';
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface AdminCloudSaveCreateRequest
 */
export interface AdminCloudSaveCreateRequest {
  /**
   * id of the user that the admin wants to create cloud save for
   * @type {string}
   * @memberof AdminCloudSaveCreateRequest
   */
  userId: string;
  /**
   *
   * @type {string}
   * @memberof AdminCloudSaveCreateRequest
   */
  instanceId: string;
  /**
   *
   * @type {string}
   * @memberof AdminCloudSaveCreateRequest
   */
  data: string;
  /**
   * Optional param. If the public is true, the data is shared in the experience. If the public is false, the data is only accessible with the personal access token.
   * @type {boolean}
   * @memberof AdminCloudSaveCreateRequest
   */
  _public?: boolean;
}
/**
 *
 * @export
 * @interface AdminCloudSaveUpdateRequest
 */
export interface AdminCloudSaveUpdateRequest {
  /**
   *
   * @type {string}
   * @memberof AdminCloudSaveUpdateRequest
   */
  cloudSaveUpdates: string;
  /**
   *
   * @type {string}
   * @memberof AdminCloudSaveUpdateRequest
   */
  userId: string;
}
/**
 *
 * @export
 * @interface AdminGetTraitStatusResponse
 */
export interface AdminGetTraitStatusResponse {
  /**
   *
   * @type {Array<MaxCountStatus>}
   * @memberof AdminGetTraitStatusResponse
   */
  maxCounts?: Array<MaxCountStatus>;
}
/**
 *
 * @export
 * @interface AdminSetTraitScoreRequest
 */
export interface AdminSetTraitScoreRequest {
  /**
   *
   * @type {string}
   * @memberof AdminSetTraitScoreRequest
   */
  traitId?: string;
  /**
   *
   * @type {number}
   * @memberof AdminSetTraitScoreRequest
   */
  score?: number;
}
/**
 *
 * @export
 * @interface CloudSaveCreateRequest
 */
export interface CloudSaveCreateRequest {
  /**
   *
   * @type {string}
   * @memberof CloudSaveCreateRequest
   */
  instanceId: string;
  /**
   *
   * @type {string}
   * @memberof CloudSaveCreateRequest
   */
  data: string;
  /**
   * Optional param. If the public is true, the data is shared in the experience. If the public is false, the data is only accessible with the personal access token.
   * @type {boolean}
   * @memberof CloudSaveCreateRequest
   */
  _public?: boolean;
}
/**
 *
 * @export
 * @interface CloudSaveGetResponse
 */
export interface CloudSaveGetResponse {
  /**
   *
   * @type {string}
   * @memberof CloudSaveGetResponse
   */
  experienceId?: string;
  /**
   *
   * @type {string}
   * @memberof CloudSaveGetResponse
   */
  instanceId?: string;
  /**
   *
   * @type {string}
   * @memberof CloudSaveGetResponse
   */
  data?: string;
}
/**
 *
 * @export
 * @interface CloudSaveUpdateRequest
 */
export interface CloudSaveUpdateRequest {
  /**
   *
   * @type {string}
   * @memberof CloudSaveUpdateRequest
   */
  cloudSaveUpdates: string;
}
/**
 *
 * @export
 * @interface CloudSaveUpdateResponse
 */
export interface CloudSaveUpdateResponse {
  /**
   *
   * @type {string}
   * @memberof CloudSaveUpdateResponse
   */
  experienceId?: string;
  /**
   *
   * @type {string}
   * @memberof CloudSaveUpdateResponse
   */
  instanceId?: string;
  /**
   *
   * @type {string}
   * @memberof CloudSaveUpdateResponse
   */
  data?: string;
}
/**
 *
 * @export
 * @interface ErrorMessage
 */
export interface ErrorMessage {
  /**
   *
   * @type {string}
   * @memberof ErrorMessage
   */
  error?: string;
}
/**
 * Object representation of a gear
 * @export
 * @interface Gear
 */
export interface Gear {
  /**
   *
   * @type {string}
   * @memberof Gear
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Gear
   */
  gearVersionId?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Gear
   */
  iconUrl?: Array<string>;
  /**
   *
   * @type {GearStatus}
   * @memberof Gear
   */
  status?: GearStatus;
  /**
   *
   * @type {number}
   * @memberof Gear
   */
  sdkVersion?: number;
  /**
   *
   * @type {string}
   * @memberof Gear
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Gear
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Gear
   */
  cmsId?: string;
  /**
   *
   * @type {string}
   * @memberof Gear
   */
  reviewerId?: string;
  /**
   *
   * @type {string}
   * @memberof Gear
   */
  reviewerComment?: string;
  /**
   *
   * @type {string}
   * @memberof Gear
   */
  s3Key?: string;
  /**
   *
   * @type {string}
   * @memberof Gear
   */
  fullSdkVersion?: string;
  /**
   *
   * @type {number}
   * @memberof Gear
   */
  createdAt?: number;
  /**
   *
   * @type {number}
   * @memberof Gear
   */
  lastModifiedAt?: number;
  /**
   *
   * @type {number}
   * @memberof Gear
   */
  contentVersion?: number;
  /**
   *
   * @type {GearCategory}
   * @memberof Gear
   */
  category?: GearCategory;
  /**
   *
   * @type {GearBuildStatus}
   * @memberof Gear
   */
  buildStatus?: GearBuildStatus;
  /**
   *
   * @type {string}
   * @memberof Gear
   */
  errorMessage?: string;
  /**
   *
   * @type {Array<RenderingUrl>}
   * @memberof Gear
   */
  renderingUrl?: Array<RenderingUrl>;
  /**
   *
   * @type {boolean}
   * @memberof Gear
   */
  nonConformed?: boolean;
  /**
   *
   * @type {string}
   * @memberof Gear
   */
  contentError?: string;
  /**
   *
   * @type {GearContentBuildStatus}
   * @memberof Gear
   */
  contentBuildStatus?: GearContentBuildStatus;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum GearBuildStatus {
  QUEUED = <any>'QUEUED',
  FAILED = <any>'FAILED',
  WARNING = <any>'WARNING',
  SUCCESS = <any>'SUCCESS',
  PREVIEWSRENDERED = <any>'PREVIEWS_RENDERED',
  PROCESSING = <any>'PROCESSING',
  ERROR = <any>'ERROR',
}
/**
 *
 * @export
 * @enum {string}
 */
export enum GearCategory {
  NOCATEGORY = <any>'NOCATEGORY',
  BRACELET = <any>'BRACELET',
  DRESS = <any>'DRESS',
  EARRINGS = <any>'EARRINGS',
  GLASSES = <any>'GLASSES',
  HAT = <any>'HAT',
  HOODIE = <any>'HOODIE',
  JACKET = <any>'JACKET',
  MASK = <any>'MASK',
  PANTS = <any>'PANTS',
  SHIRT = <any>'SHIRT',
  SHOES = <any>'SHOES',
  SHORTS = <any>'SHORTS',
  SKIRT = <any>'SKIRT',
  AVATAR = <any>'AVATAR',
}
/**
 *
 * @export
 * @enum {string}
 */
export enum GearContentBuildStatus {
  QUEUED = <any>'QUEUED',
  FAILED = <any>'FAILED',
  WARNING = <any>'WARNING',
  SUCCESS = <any>'SUCCESS',
}
/**
 * Representation of request body for create gear
 * @export
 * @interface GearCreateRequest
 */
export interface GearCreateRequest {
  /**
   *
   * @type {string}
   * @memberof GearCreateRequest
   */
  gearId?: string;
  /**
   *
   * @type {string}
   * @memberof GearCreateRequest
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof GearCreateRequest
   */
  description?: string;
  /**
   *
   * @type {GearCategory}
   * @memberof GearCreateRequest
   */
  category?: GearCategory;
  /**
   *
   * @type {boolean}
   * @memberof GearCreateRequest
   */
  nonConformed?: boolean;
}
/**
 * Representation of response body for create gear
 * @export
 * @interface GearCreateResponse
 */
export interface GearCreateResponse {
  /**
   *
   * @type {string}
   * @memberof GearCreateResponse
   */
  gearId?: string;
  /**
   *
   * @type {string}
   * @memberof GearCreateResponse
   */
  gearVersionId?: string;
  /**
   *
   * @type {string}
   * @memberof GearCreateResponse
   */
  presignedUrl?: string;
}
/**
 * Object representation of a gear
 * @export
 * @interface GearGetByIdResponse
 */
export interface GearGetByIdResponse {
  /**
   *
   * @type {Gear}
   * @memberof GearGetByIdResponse
   */
  gear?: Gear;
}
/**
 * List of gear objects
 * @export
 * @interface GearListResponse
 */
export interface GearListResponse {
  /**
   *
   * @type {Array<Gear>}
   * @memberof GearListResponse
   */
  gears?: Array<Gear>;
  /**
   *
   * @type {string}
   * @memberof GearListResponse
   */
  cursor?: string;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum GearStatus {
  UNDERREVIEW = <any>'UNDERREVIEW',
  PUBLISHED = <any>'PUBLISHED',
  REJECTED = <any>'REJECTED',
  APPROVED = <any>'APPROVED',
  FLAG = <any>'FLAG',
}
/**
 * Representation of request body for update gear
 * @export
 * @interface GearUpdateRequest
 */
export interface GearUpdateRequest {
  /**
   *
   * @type {string}
   * @memberof GearUpdateRequest
   */
  gearVersionId?: string;
  /**
   *
   * @type {GearStatus}
   * @memberof GearUpdateRequest
   */
  status?: GearStatus;
  /**
   *
   * @type {string}
   * @memberof GearUpdateRequest
   */
  cmsId?: string;
  /**
   *
   * @type {string}
   * @memberof GearUpdateRequest
   */
  reviewerId?: string;
  /**
   *
   * @type {string}
   * @memberof GearUpdateRequest
   */
  reviewerComment?: string;
  /**
   *
   * @type {string}
   * @memberof GearUpdateRequest
   */
  s3Key?: string;
  /**
   *
   * @type {number}
   * @memberof GearUpdateRequest
   */
  contentVersion?: number;
  /**
   *
   * @type {string}
   * @memberof GearUpdateRequest
   */
  errorMessage?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof GearUpdateRequest
   */
  iconUrl?: Array<string>;
  /**
   *
   * @type {GearBuildStatus}
   * @memberof GearUpdateRequest
   */
  buildStatus?: GearBuildStatus;
  /**
   *
   * @type {GearCategory}
   * @memberof GearUpdateRequest
   */
  category?: GearCategory;
  /**
   *
   * @type {Array<RenderingUrl>}
   * @memberof GearUpdateRequest
   */
  renderingUrl?: Array<RenderingUrl>;
  /**
   *
   * @type {GearContentBuildStatus}
   * @memberof GearUpdateRequest
   */
  contentBuildStatus?: GearContentBuildStatus;
  /**
   *
   * @type {string}
   * @memberof GearUpdateRequest
   */
  contentError?: string;
}
/**
 *
 * @export
 * @interface Leaderboard
 */
export interface Leaderboard {
  /**
   *
   * @type {string}
   * @memberof Leaderboard
   */
  experienceId?: string;
  /**
   *
   * @type {string}
   * @memberof Leaderboard
   */
  leaderboardId?: string;
  /**
   *
   * @type {string}
   * @memberof Leaderboard
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Leaderboard
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof Leaderboard
   */
  createAt?: number;
  /**
   *
   * @type {string}
   * @memberof Leaderboard
   */
  type?: Leaderboard.TypeEnum;
}

/**
 * @export
 * @namespace Leaderboard
 */
export namespace Leaderboard {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    CURRENTSCORE = <any>'CURRENT_SCORE',
    HIGHESTSCORE = <any>'HIGHEST_SCORE',
  }
}
/**
 *
 * @export
 * @interface LeaderboardCreateRequest
 */
export interface LeaderboardCreateRequest {
  /**
   *
   * @type {string}
   * @memberof LeaderboardCreateRequest
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof LeaderboardCreateRequest
   */
  description?: string;
  /**
   * leaderboard type, default is CURRENT_SCORE
   * @type {string}
   * @memberof LeaderboardCreateRequest
   */
  type?: LeaderboardCreateRequest.TypeEnum;
}

/**
 * @export
 * @namespace LeaderboardCreateRequest
 */
export namespace LeaderboardCreateRequest {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    CURRENTSCORE = <any>'CURRENT_SCORE',
    HIGHESTSCORE = <any>'HIGHEST_SCORE',
  }
}
/**
 *
 * @export
 * @interface LeaderboardCreateResponse
 */
export interface LeaderboardCreateResponse {
  /**
   *
   * @type {string}
   * @memberof LeaderboardCreateResponse
   */
  leaderboardId?: string;
}
/**
 *
 * @export
 * @interface LeaderboardGetRanksResponse
 */
export interface LeaderboardGetRanksResponse {
  /**
   *
   * @type {Array<LeaderboardUserRank>}
   * @memberof LeaderboardGetRanksResponse
   */
  userRanks?: Array<LeaderboardUserRank>;
  /**
   *
   * @type {number}
   * @memberof LeaderboardGetRanksResponse
   */
  offset?: number;
  /**
   *
   * @type {number}
   * @memberof LeaderboardGetRanksResponse
   */
  limit?: number;
}
/**
 *
 * @export
 * @interface LeaderboardGetResponse
 */
export interface LeaderboardGetResponse {
  /**
   *
   * @type {Array<Leaderboard>}
   * @memberof LeaderboardGetResponse
   */
  leaderboards?: Array<Leaderboard>;
  /**
   *
   * @type {string}
   * @memberof LeaderboardGetResponse
   */
  nextCursor?: string;
}
/**
 *
 * @export
 * @interface LeaderboardGetTopNRanksByGroupIdResponse
 */
export interface LeaderboardGetTopNRanksByGroupIdResponse {
  /**
   *
   * @type {Array<LeaderboardUserRank>}
   * @memberof LeaderboardGetTopNRanksByGroupIdResponse
   */
  userRanks?: Array<LeaderboardUserRank>;
}
/**
 *
 * @export
 * @interface LeaderboardGetTopNRanksResponse
 */
export interface LeaderboardGetTopNRanksResponse {
  /**
   *
   * @type {Array<LeaderboardUserRank>}
   * @memberof LeaderboardGetTopNRanksResponse
   */
  userRanks?: Array<LeaderboardUserRank>;
}
/**
 * Representation of request body for create gear
 * @export
 * @interface LeaderboardSubmitUserScoreRequest
 */
export interface LeaderboardSubmitUserScoreRequest {
  /**
   *
   * @type {string}
   * @memberof LeaderboardSubmitUserScoreRequest
   */
  userId?: string;
  /**
   *
   * @type {number}
   * @memberof LeaderboardSubmitUserScoreRequest
   */
  scoreIncrement?: number;
  /**
   *
   * @type {string}
   * @memberof LeaderboardSubmitUserScoreRequest
   */
  idempotencyKey?: string;
  /**
   *
   * @type {number}
   * @memberof LeaderboardSubmitUserScoreRequest
   */
  score?: number;
  /**
   *
   * @type {string}
   * @memberof LeaderboardSubmitUserScoreRequest
   */
  type?: LeaderboardSubmitUserScoreRequest.TypeEnum;
}

/**
 * @export
 * @namespace LeaderboardSubmitUserScoreRequest
 */
export namespace LeaderboardSubmitUserScoreRequest {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    INCREMENTAL = <any>'INCREMENTAL',
    DIRECT = <any>'DIRECT',
  }
}
/**
 *
 * @export
 * @interface LeaderboardSubmitUserScoreResponse
 */
export interface LeaderboardSubmitUserScoreResponse {
  /**
   *
   * @type {number}
   * @memberof LeaderboardSubmitUserScoreResponse
   */
  gameScore?: number;
  /**
   *
   * @type {number}
   * @memberof LeaderboardSubmitUserScoreResponse
   */
  highestScore?: number;
}
/**
 *
 * @export
 * @interface LeaderboardUserRank
 */
export interface LeaderboardUserRank {
  /**
   *
   * @type {string}
   * @memberof LeaderboardUserRank
   */
  userId?: string;
  /**
   *
   * @type {string}
   * @memberof LeaderboardUserRank
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof LeaderboardUserRank
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof LeaderboardUserRank
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof LeaderboardUserRank
   */
  prefUsername?: string;
  /**
   *
   * @type {string}
   * @memberof LeaderboardUserRank
   */
  profileUrl?: string;
  /**
   *
   * @type {number}
   * @memberof LeaderboardUserRank
   */
  gameScore?: number;
  /**
   *
   * @type {number}
   * @memberof LeaderboardUserRank
   */
  highestScore?: number;
  /**
   *
   * @type {number}
   * @memberof LeaderboardUserRank
   */
  rank?: number;
  /**
   *
   * @type {number}
   * @memberof LeaderboardUserRank
   */
  lastActivityAt?: number;
}
/**
 * List of store items that will be returned
 * @export
 * @interface ListStoreItemsResponse
 */
export interface ListStoreItemsResponse {
  /**
   *
   * @type {Array<StoreItem>}
   * @memberof ListStoreItemsResponse
   */
  items?: Array<StoreItem>;
}
/**
 * List of store identfiers that will be returned
 * @export
 * @interface ListStoresResponse
 */
export interface ListStoresResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof ListStoresResponse
   */
  storeIds?: Array<string>;
}
/**
 *
 * @export
 * @interface MaxCountStatus
 */
export interface MaxCountStatus {
  /**
   *
   * @type {string}
   * @memberof MaxCountStatus
   */
  traitId?: string;
  /**
   *
   * @type {string}
   * @memberof MaxCountStatus
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof MaxCountStatus
   */
  currentCount?: number;
  /**
   * Limit of max count for the associated trait
   * @type {number}
   * @memberof MaxCountStatus
   */
  maxCount?: number;
  /**
   *
   * @type {number}
   * @memberof MaxCountStatus
   */
  expiresAt?: number;
  /**
   *
   * @type {string}
   * @memberof MaxCountStatus
   */
  source?: string;
  /**
   *
   * @type {boolean}
   * @memberof MaxCountStatus
   */
  onCooldown?: boolean;
}
/**
 *
 * @export
 * @interface MessageResponse
 */
export interface MessageResponse {
  /**
   *
   * @type {string}
   * @memberof MessageResponse
   */
  message?: string;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  message?: string;
}
/**
 * Returns the store identifier for successful registration
 * @export
 * @interface RegisterStoreResponse
 */
export interface RegisterStoreResponse {
  /**
   *
   * @type {string}
   * @memberof RegisterStoreResponse
   */
  storeId?: string;
}
/**
 * Rendering animation videos and thumbnail images from pipeline
 * @export
 * @interface RenderingUrl
 */
export interface RenderingUrl {
  /**
   *
   * @type {string}
   * @memberof RenderingUrl
   */
  previewURL?: string;
  /**
   *
   * @type {string}
   * @memberof RenderingUrl
   */
  videoURL?: string;
}
/**
 * Representation of the properties that are in a store item
 * @export
 * @interface StoreItem
 */
export interface StoreItem {
  /**
   * Unique identifier for the item
   * @type {string}
   * @memberof StoreItem
   */
  itemId: string;
  /**
   * Defined type of the store item
   * @type {string}
   * @memberof StoreItem
   */
  itemType?: string;
  /**
   * Definition of the item
   * @type {string}
   * @memberof StoreItem
   */
  definition?: string;
}
/**
 * Representation of the singular object to update store
 * @export
 * @interface StoreItemUpdate
 */
export interface StoreItemUpdate {
  /**
   * Unique identifier for the item
   * @type {string}
   * @memberof StoreItemUpdate
   */
  itemId: string;
  /**
   * Defined type of the store item
   * @type {string}
   * @memberof StoreItemUpdate
   */
  itemType?: string;
  /**
   * Definition of the item
   * @type {string}
   * @memberof StoreItemUpdate
   */
  definition?: string;
}
/**
 * Representation of the properties to update store with items
 * @export
 * @interface StoreItemUpdates
 */
export interface StoreItemUpdates {
  /**
   * Operation to perform for this specified object
   * @type {string}
   * @memberof StoreItemUpdates
   */
  operation?: StoreItemUpdates.OperationEnum;
  /**
   *
   * @type {Array<StoreItemUpdate>}
   * @memberof StoreItemUpdates
   */
  items?: Array<StoreItemUpdate>;
}

/**
 * @export
 * @namespace StoreItemUpdates
 */
export namespace StoreItemUpdates {
  /**
   * @export
   * @enum {string}
   */
  export enum OperationEnum {
    ADD = <any>'ADD',
    REMOVE = <any>'REMOVE',
  }
}
/**
 *
 * @export
 * @interface Trait
 */
export interface Trait {
  /**
   *
   * @type {string}
   * @memberof Trait
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Trait
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Trait
   */
  type?: Trait.TypeEnum;
  /**
   *
   * @type {string}
   * @memberof Trait
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Trait
   */
  iconUrl?: string;
  /**
   *
   * @type {number}
   * @memberof Trait
   */
  version?: number;
  /**
   *
   * @type {string}
   * @memberof Trait
   */
  status?: Trait.StatusEnum;
  /**
   *
   * @type {string}
   * @memberof Trait
   */
  cmsId?: string;
  /**
   *
   * @type {string}
   * @memberof Trait
   */
  oppositeTraitId?: string;
  /**
   *
   * @type {string}
   * @memberof Trait
   */
  archetypeId?: string;
  /**
   *
   * @type {string}
   * @memberof Trait
   */
  archetypeName?: string;
  /**
   *
   * @type {string}
   * @memberof Trait
   */
  archetypeColor?: string;
  /**
   *
   * @type {string}
   * @memberof Trait
   */
  oppositeArchetypeId?: string;
  /**
   *
   * @type {string}
   * @memberof Trait
   */
  archetypeDescription?: string;
  /**
   *
   * @type {number}
   * @memberof Trait
   */
  lastModifiedAt?: number;
}

/**
 * @export
 * @namespace Trait
 */
export namespace Trait {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    EMOTIONAL = <any>'EMOTIONAL',
    MENTAL = <any>'MENTAL',
    EXPRESSIVE = <any>'EXPRESSIVE',
    SOCIAL = <any>'SOCIAL',
  }
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    ACTIVE = <any>'ACTIVE',
    INACTIVE = <any>'INACTIVE',
  }
}
/**
 *
 * @export
 * @interface TraitSignalRequest
 */
export interface TraitSignalRequest {
  /**
   *
   * @type {string}
   * @memberof TraitSignalRequest
   */
  source: TraitSignalRequest.SourceEnum;
  /**
   *
   * @type {string}
   * @memberof TraitSignalRequest
   */
  smartAssetId?: string;
  /**
   *
   * @type {boolean}
   * @memberof TraitSignalRequest
   */
  equip?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof TraitSignalRequest
   */
  traitIds: Array<string>;
  /**
   *
   * @type {string}
   * @memberof TraitSignalRequest
   */
  idempotencyKey: string;
  /**
   *
   * @type {string}
   * @memberof TraitSignalRequest
   */
  experienceId?: string;
}

/**
 * @export
 * @namespace TraitSignalRequest
 */
export namespace TraitSignalRequest {
  /**
   * @export
   * @enum {string}
   */
  export enum SourceEnum {
    EXPMICRO = <any>'SOURCE_EXP_MICRO',
    EXPCORE = <any>'SOURCE_EXP_CORE',
    EXPEMOTE = <any>'SOURCE_EXP_EMOTE',
    EXPSOCIAL = <any>'SOURCE_EXP_SOCIAL',
    EXPMETA = <any>'SOURCE_EXP_META',
    EXPCONDITIONLARGE = <any>'SOURCE_EXP_CONDITION_LARGE',
    EXPCONDITIONMEDIUM = <any>'SOURCE_EXP_CONDITION_MEDIUM',
    EXPCONDITIONSMALL = <any>'SOURCE_EXP_CONDITION_SMALL',
    EXPROLE = <any>'SOURCE_EXP_ROLE',
    SPACEEQUIPWEARABLE = <any>'SOURCE_SPACE_EQUIP_WEARABLE',
    SPACEEQUIPHANDPROP = <any>'SOURCE_SPACE_EQUIP_HAND_PROP',
    SPACEEQUIPAVATAR = <any>'SOURCE_SPACE_EQUIP_AVATAR',
    EXPEQUIPWEARABLE = <any>'SOURCE_EXP_EQUIP_WEARABLE',
    EXPEQUIPHANDPROP = <any>'SOURCE_EXP_EQUIP_HAND_PROP',
    EXPEQUIPAVATAR = <any>'SOURCE_EXP_EQUIP_AVATAR',
  }
}
/**
 *
 * @export
 * @interface TraitsGetResponse
 */
export interface TraitsGetResponse {
  /**
   *
   * @type {Array<Trait>}
   * @memberof TraitsGetResponse
   */
  traits?: Array<Trait>;
}
/**
 * Representation of the properties to update a user with store items
 * @export
 * @interface UserStoreItemUpdates
 */
export interface UserStoreItemUpdates {
  /**
   * Operation to perform for this specified object
   * @type {string}
   * @memberof UserStoreItemUpdates
   */
  operation?: UserStoreItemUpdates.OperationEnum;
  /**
   * Unique identifier that all of the store items belong to
   * @type {string}
   * @memberof UserStoreItemUpdates
   */
  storeId?: string;
  /**
   *
   * @type {Array<StoreItemUpdate>}
   * @memberof UserStoreItemUpdates
   */
  items?: Array<StoreItemUpdate>;
}

/**
 * @export
 * @namespace UserStoreItemUpdates
 */
export namespace UserStoreItemUpdates {
  /**
   * @export
   * @enum {string}
   */
  export enum OperationEnum {
    ADD = <any>'ADD',
    REMOVE = <any>'REMOVE',
  }
}
/**
 *
 * @export
 * @interface UserTraitsHistoryResponse
 */
export interface UserTraitsHistoryResponse {
  /**
   *
   * @type {Array<UserTraitsHistoryResponseProfile>}
   * @memberof UserTraitsHistoryResponse
   */
  profile: Array<UserTraitsHistoryResponseProfile>;
  /**
   *
   * @type {number}
   * @memberof UserTraitsHistoryResponse
   */
  lastModifiedAt: number;
}
/**
 *
 * @export
 * @interface UserTraitsHistoryResponseProfile
 */
export interface UserTraitsHistoryResponseProfile {
  /**
   *
   * @type {Trait}
   * @memberof UserTraitsHistoryResponseProfile
   */
  trait?: Trait;
  /**
   *
   * @type {number}
   * @memberof UserTraitsHistoryResponseProfile
   */
  value?: number;
  /**
   *
   * @type {number}
   * @memberof UserTraitsHistoryResponseProfile
   */
  lastModifiedAt?: number;
}
/**
 *
 * @export
 * @interface UserTraitsResponse
 */
export interface UserTraitsResponse {
  /**
   *
   * @type {Array<UserTraitsResponseProfile>}
   * @memberof UserTraitsResponse
   */
  profile: Array<UserTraitsResponseProfile>;
  /**
   *
   * @type {number}
   * @memberof UserTraitsResponse
   */
  lastModifiedAt: number;
}
/**
 *
 * @export
 * @interface UserTraitsResponseProfile
 */
export interface UserTraitsResponseProfile {
  /**
   *
   * @type {Trait}
   * @memberof UserTraitsResponseProfile
   */
  trait?: Trait;
  /**
   *
   * @type {number}
   * @memberof UserTraitsResponseProfile
   */
  value: number;
}
/**
 *
 * @export
 * @interface UserTraitsUpdate
 */
export interface UserTraitsUpdate {
  /**
   *
   * @type {Array<UserTraitsUpdateTraits>}
   * @memberof UserTraitsUpdate
   */
  traits?: Array<UserTraitsUpdateTraits>;
}
/**
 *
 * @export
 * @interface UserTraitsUpdateTraits
 */
export interface UserTraitsUpdateTraits {
  /**
   *
   * @type {string}
   * @memberof UserTraitsUpdateTraits
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof UserTraitsUpdateTraits
   */
  size?: UserTraitsUpdateTraits.SizeEnum;
}

/**
 * @export
 * @namespace UserTraitsUpdateTraits
 */
export namespace UserTraitsUpdateTraits {
  /**
   * @export
   * @enum {string}
   */
  export enum SizeEnum {
    S = <any>'S',
    M = <any>'M',
    L = <any>'L',
  }
}
/**
 * AdminTraitsApi - fetch parameter creator
 * @export
 */
export const AdminTraitsApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Get the traits status and other metadata (devkit where only developers will be able to access this). From shim API with trait service using devkit swaggerhub.
     * @param {string} userId UserId who will receive the items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTraitStatus(userId: string, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getTraitStatus.',
        );
      }
      const localVarPath = `/admin/user/{userId}/trait/status`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Resets the user's macro profile
     * @param {string} userId userId of the trait to set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetScore(userId: string, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling resetScore.',
        );
      }
      const localVarPath = `/admin/user/{userId}/trait`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set score for a traitId
     * @param {string} userId userId of the trait to set
     * @param {AdminSetTraitScoreRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setTraitScore(
      userId: string,
      body?: AdminSetTraitScoreRequest,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling setTraitScore.',
        );
      }
      const localVarPath = `/admin/user/{userId}/trait`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'AdminSetTraitScoreRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AdminTraitsApi - functional programming interface
 * @export
 */
export const AdminTraitsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get the traits status and other metadata (devkit where only developers will be able to access this). From shim API with trait service using devkit swaggerhub.
     * @param {string} userId UserId who will receive the items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTraitStatus(
      userId: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<AdminGetTraitStatusResponse> {
      const localVarFetchArgs = AdminTraitsApiFetchParamCreator(
        configuration,
      ).getTraitStatus(userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Resets the user's macro profile
     * @param {string} userId userId of the trait to set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetScore(
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = AdminTraitsApiFetchParamCreator(
        configuration,
      ).resetScore(userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Set score for a traitId
     * @param {string} userId userId of the trait to set
     * @param {AdminSetTraitScoreRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setTraitScore(
      userId: string,
      body?: AdminSetTraitScoreRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = AdminTraitsApiFetchParamCreator(
        configuration,
      ).setTraitScore(userId, body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * AdminTraitsApi - factory interface
 * @export
 */
export const AdminTraitsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Get the traits status and other metadata (devkit where only developers will be able to access this). From shim API with trait service using devkit swaggerhub.
     * @param {string} userId UserId who will receive the items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTraitStatus(userId: string, options?: any) {
      return AdminTraitsApiFp(configuration).getTraitStatus(userId, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Resets the user's macro profile
     * @param {string} userId userId of the trait to set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetScore(userId: string, options?: any) {
      return AdminTraitsApiFp(configuration).resetScore(userId, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Set score for a traitId
     * @param {string} userId userId of the trait to set
     * @param {AdminSetTraitScoreRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setTraitScore(
      userId: string,
      body?: AdminSetTraitScoreRequest,
      options?: any,
    ) {
      return AdminTraitsApiFp(configuration).setTraitScore(
        userId,
        body,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * AdminTraitsApi - object-oriented interface
 * @export
 * @class AdminTraitsApi
 * @extends {BaseAPI}
 */
export class AdminTraitsApi extends BaseAPI {
  /**
   *
   * @summary Get the traits status and other metadata (devkit where only developers will be able to access this). From shim API with trait service using devkit swaggerhub.
   * @param {string} userId UserId who will receive the items
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminTraitsApi
   */
  public getTraitStatus(userId: string, options?: any) {
    return AdminTraitsApiFp(this.configuration).getTraitStatus(userId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Resets the user's macro profile
   * @param {string} userId userId of the trait to set
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminTraitsApi
   */
  public resetScore(userId: string, options?: any) {
    return AdminTraitsApiFp(this.configuration).resetScore(userId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Set score for a traitId
   * @param {string} userId userId of the trait to set
   * @param {AdminSetTraitScoreRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminTraitsApi
   */
  public setTraitScore(
    userId: string,
    body?: AdminSetTraitScoreRequest,
    options?: any,
  ) {
    return AdminTraitsApiFp(this.configuration).setTraitScore(
      userId,
      body,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * CloudsaveApi - fetch parameter creator
 * @export
 */
export const CloudsaveApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Admin create cloud save for user
     * @param {AdminCloudSaveCreateRequest} body Create cloud save
     * @param {string} experienceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminCreateCloudSave(
      body: AdminCloudSaveCreateRequest,
      experienceId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling adminCreateCloudSave.',
        );
      }
      // verify required parameter 'experienceId' is not null or undefined
      if (experienceId === null || experienceId === undefined) {
        throw new RequiredError(
          'experienceId',
          'Required parameter experienceId was null or undefined when calling adminCreateCloudSave.',
        );
      }
      const localVarPath = `/admin/cloud-save/{experienceId}`.replace(
        `{${'experienceId'}}`,
        encodeURIComponent(String(experienceId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'AdminCloudSaveCreateRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Admin delete cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminDeleteCloudSave(
      experienceId: string,
      instanceId: string,
      userId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'experienceId' is not null or undefined
      if (experienceId === null || experienceId === undefined) {
        throw new RequiredError(
          'experienceId',
          'Required parameter experienceId was null or undefined when calling adminDeleteCloudSave.',
        );
      }
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          'instanceId',
          'Required parameter instanceId was null or undefined when calling adminDeleteCloudSave.',
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling adminDeleteCloudSave.',
        );
      }
      const localVarPath = `/admin/cloud-save/{experienceId}/{instanceId}`
        .replace(
          `{${'experienceId'}}`,
          encodeURIComponent(String(experienceId)),
        )
        .replace(`{${'instanceId'}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Admin get private cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {string} userId id of the user whose cloud save the admin wants to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminGetCloudSave(
      experienceId: string,
      instanceId: string,
      userId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'experienceId' is not null or undefined
      if (experienceId === null || experienceId === undefined) {
        throw new RequiredError(
          'experienceId',
          'Required parameter experienceId was null or undefined when calling adminGetCloudSave.',
        );
      }
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          'instanceId',
          'Required parameter instanceId was null or undefined when calling adminGetCloudSave.',
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling adminGetCloudSave.',
        );
      }
      const localVarPath = `/admin/cloud-save/{experienceId}/{instanceId}`
        .replace(
          `{${'experienceId'}}`,
          encodeURIComponent(String(experienceId)),
        )
        .replace(`{${'instanceId'}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Admin update cloud save
     * @param {AdminCloudSaveUpdateRequest} body Admin update cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUpdateCloudSave(
      body: AdminCloudSaveUpdateRequest,
      experienceId: string,
      instanceId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling adminUpdateCloudSave.',
        );
      }
      // verify required parameter 'experienceId' is not null or undefined
      if (experienceId === null || experienceId === undefined) {
        throw new RequiredError(
          'experienceId',
          'Required parameter experienceId was null or undefined when calling adminUpdateCloudSave.',
        );
      }
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          'instanceId',
          'Required parameter instanceId was null or undefined when calling adminUpdateCloudSave.',
        );
      }
      const localVarPath = `/admin/cloud-save/{experienceId}/{instanceId}`
        .replace(
          `{${'experienceId'}}`,
          encodeURIComponent(String(experienceId)),
        )
        .replace(`{${'instanceId'}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'AdminCloudSaveUpdateRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create cloud save
     * @param {CloudSaveCreateRequest} body Create cloud save
     * @param {string} experienceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCloudSave(
      body: CloudSaveCreateRequest,
      experienceId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createCloudSave.',
        );
      }
      // verify required parameter 'experienceId' is not null or undefined
      if (experienceId === null || experienceId === undefined) {
        throw new RequiredError(
          'experienceId',
          'Required parameter experienceId was null or undefined when calling createCloudSave.',
        );
      }
      const localVarPath = `/cloud-save/{experienceId}`.replace(
        `{${'experienceId'}}`,
        encodeURIComponent(String(experienceId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'CloudSaveCreateRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCloudSave(
      experienceId: string,
      instanceId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'experienceId' is not null or undefined
      if (experienceId === null || experienceId === undefined) {
        throw new RequiredError(
          'experienceId',
          'Required parameter experienceId was null or undefined when calling deleteCloudSave.',
        );
      }
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          'instanceId',
          'Required parameter instanceId was null or undefined when calling deleteCloudSave.',
        );
      }
      const localVarPath = `/cloud-save/{experienceId}/{instanceId}`
        .replace(
          `{${'experienceId'}}`,
          encodeURIComponent(String(experienceId)),
        )
        .replace(`{${'instanceId'}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete shared cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSharedCloudSave(
      experienceId: string,
      instanceId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'experienceId' is not null or undefined
      if (experienceId === null || experienceId === undefined) {
        throw new RequiredError(
          'experienceId',
          'Required parameter experienceId was null or undefined when calling deleteSharedCloudSave.',
        );
      }
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          'instanceId',
          'Required parameter instanceId was null or undefined when calling deleteSharedCloudSave.',
        );
      }
      const localVarPath = `/cloud-save/{experienceId}/{instanceId}/public`
        .replace(
          `{${'experienceId'}}`,
          encodeURIComponent(String(experienceId)),
        )
        .replace(`{${'instanceId'}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCloudSave(
      experienceId: string,
      instanceId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'experienceId' is not null or undefined
      if (experienceId === null || experienceId === undefined) {
        throw new RequiredError(
          'experienceId',
          'Required parameter experienceId was null or undefined when calling getCloudSave.',
        );
      }
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          'instanceId',
          'Required parameter instanceId was null or undefined when calling getCloudSave.',
        );
      }
      const localVarPath = `/cloud-save/{experienceId}/{instanceId}`
        .replace(
          `{${'experienceId'}}`,
          encodeURIComponent(String(experienceId)),
        )
        .replace(`{${'instanceId'}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the shared cloud save data
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSharedCloudSave(
      experienceId: string,
      instanceId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'experienceId' is not null or undefined
      if (experienceId === null || experienceId === undefined) {
        throw new RequiredError(
          'experienceId',
          'Required parameter experienceId was null or undefined when calling getSharedCloudSave.',
        );
      }
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          'instanceId',
          'Required parameter instanceId was null or undefined when calling getSharedCloudSave.',
        );
      }
      const localVarPath = `/cloud-save/{experienceId}/{instanceId}/public`
        .replace(
          `{${'experienceId'}}`,
          encodeURIComponent(String(experienceId)),
        )
        .replace(`{${'instanceId'}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Internal create cloud save
     * @param {CloudSaveCreateRequest} body Create cloud save
     * @param {string} experienceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    internalCreateCloudSave(
      body: CloudSaveCreateRequest,
      experienceId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling internalCreateCloudSave.',
        );
      }
      // verify required parameter 'experienceId' is not null or undefined
      if (experienceId === null || experienceId === undefined) {
        throw new RequiredError(
          'experienceId',
          'Required parameter experienceId was null or undefined when calling internalCreateCloudSave.',
        );
      }
      const localVarPath = `/internal/cloud-save/{experienceId}`.replace(
        `{${'experienceId'}}`,
        encodeURIComponent(String(experienceId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'CloudSaveCreateRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Internal delete cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    internalDeleteCloudSave(
      experienceId: string,
      instanceId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'experienceId' is not null or undefined
      if (experienceId === null || experienceId === undefined) {
        throw new RequiredError(
          'experienceId',
          'Required parameter experienceId was null or undefined when calling internalDeleteCloudSave.',
        );
      }
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          'instanceId',
          'Required parameter instanceId was null or undefined when calling internalDeleteCloudSave.',
        );
      }
      const localVarPath = `/internal/cloud-save/{experienceId}/{instanceId}`
        .replace(
          `{${'experienceId'}}`,
          encodeURIComponent(String(experienceId)),
        )
        .replace(`{${'instanceId'}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Internal get cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    internalGetCloudSave(
      experienceId: string,
      instanceId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'experienceId' is not null or undefined
      if (experienceId === null || experienceId === undefined) {
        throw new RequiredError(
          'experienceId',
          'Required parameter experienceId was null or undefined when calling internalGetCloudSave.',
        );
      }
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          'instanceId',
          'Required parameter instanceId was null or undefined when calling internalGetCloudSave.',
        );
      }
      const localVarPath = `/internal/cloud-save/{experienceId}/{instanceId}`
        .replace(
          `{${'experienceId'}}`,
          encodeURIComponent(String(experienceId)),
        )
        .replace(`{${'instanceId'}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Internal update cloud save
     * @param {CloudSaveUpdateRequest} body Admin update cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    internalUpdateCloudSave(
      body: CloudSaveUpdateRequest,
      experienceId: string,
      instanceId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling internalUpdateCloudSave.',
        );
      }
      // verify required parameter 'experienceId' is not null or undefined
      if (experienceId === null || experienceId === undefined) {
        throw new RequiredError(
          'experienceId',
          'Required parameter experienceId was null or undefined when calling internalUpdateCloudSave.',
        );
      }
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          'instanceId',
          'Required parameter instanceId was null or undefined when calling internalUpdateCloudSave.',
        );
      }
      const localVarPath = `/internal/cloud-save/{experienceId}/{instanceId}`
        .replace(
          `{${'experienceId'}}`,
          encodeURIComponent(String(experienceId)),
        )
        .replace(`{${'instanceId'}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'CloudSaveUpdateRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update cloud save
     * @param {CloudSaveUpdateRequest} body Admin update cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCloudSave(
      body: CloudSaveUpdateRequest,
      experienceId: string,
      instanceId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateCloudSave.',
        );
      }
      // verify required parameter 'experienceId' is not null or undefined
      if (experienceId === null || experienceId === undefined) {
        throw new RequiredError(
          'experienceId',
          'Required parameter experienceId was null or undefined when calling updateCloudSave.',
        );
      }
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          'instanceId',
          'Required parameter instanceId was null or undefined when calling updateCloudSave.',
        );
      }
      const localVarPath = `/cloud-save/{experienceId}/{instanceId}`
        .replace(
          `{${'experienceId'}}`,
          encodeURIComponent(String(experienceId)),
        )
        .replace(`{${'instanceId'}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'CloudSaveUpdateRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update shared cloud save
     * @param {CloudSaveUpdateRequest} body Admin update cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSharedCloudSave(
      body: CloudSaveUpdateRequest,
      experienceId: string,
      instanceId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateSharedCloudSave.',
        );
      }
      // verify required parameter 'experienceId' is not null or undefined
      if (experienceId === null || experienceId === undefined) {
        throw new RequiredError(
          'experienceId',
          'Required parameter experienceId was null or undefined when calling updateSharedCloudSave.',
        );
      }
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          'instanceId',
          'Required parameter instanceId was null or undefined when calling updateSharedCloudSave.',
        );
      }
      const localVarPath = `/cloud-save/{experienceId}/{instanceId}/public`
        .replace(
          `{${'experienceId'}}`,
          encodeURIComponent(String(experienceId)),
        )
        .replace(`{${'instanceId'}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'CloudSaveUpdateRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CloudsaveApi - functional programming interface
 * @export
 */
export const CloudsaveApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Admin create cloud save for user
     * @param {AdminCloudSaveCreateRequest} body Create cloud save
     * @param {string} experienceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminCreateCloudSave(
      body: AdminCloudSaveCreateRequest,
      experienceId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = CloudsaveApiFetchParamCreator(
        configuration,
      ).adminCreateCloudSave(body, experienceId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Admin delete cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminDeleteCloudSave(
      experienceId: string,
      instanceId: string,
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = CloudsaveApiFetchParamCreator(
        configuration,
      ).adminDeleteCloudSave(experienceId, instanceId, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Admin get private cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {string} userId id of the user whose cloud save the admin wants to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminGetCloudSave(
      experienceId: string,
      instanceId: string,
      userId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CloudSaveGetResponse> {
      const localVarFetchArgs = CloudsaveApiFetchParamCreator(
        configuration,
      ).adminGetCloudSave(experienceId, instanceId, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Admin update cloud save
     * @param {AdminCloudSaveUpdateRequest} body Admin update cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUpdateCloudSave(
      body: AdminCloudSaveUpdateRequest,
      experienceId: string,
      instanceId: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<CloudSaveUpdateResponse> {
      const localVarFetchArgs = CloudsaveApiFetchParamCreator(
        configuration,
      ).adminUpdateCloudSave(body, experienceId, instanceId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Create cloud save
     * @param {CloudSaveCreateRequest} body Create cloud save
     * @param {string} experienceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCloudSave(
      body: CloudSaveCreateRequest,
      experienceId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = CloudsaveApiFetchParamCreator(
        configuration,
      ).createCloudSave(body, experienceId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Delete cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCloudSave(
      experienceId: string,
      instanceId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = CloudsaveApiFetchParamCreator(
        configuration,
      ).deleteCloudSave(experienceId, instanceId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Delete shared cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSharedCloudSave(
      experienceId: string,
      instanceId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = CloudsaveApiFetchParamCreator(
        configuration,
      ).deleteSharedCloudSave(experienceId, instanceId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCloudSave(
      experienceId: string,
      instanceId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CloudSaveGetResponse> {
      const localVarFetchArgs = CloudsaveApiFetchParamCreator(
        configuration,
      ).getCloudSave(experienceId, instanceId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the shared cloud save data
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSharedCloudSave(
      experienceId: string,
      instanceId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CloudSaveGetResponse> {
      const localVarFetchArgs = CloudsaveApiFetchParamCreator(
        configuration,
      ).getSharedCloudSave(experienceId, instanceId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Internal create cloud save
     * @param {CloudSaveCreateRequest} body Create cloud save
     * @param {string} experienceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    internalCreateCloudSave(
      body: CloudSaveCreateRequest,
      experienceId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = CloudsaveApiFetchParamCreator(
        configuration,
      ).internalCreateCloudSave(body, experienceId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Internal delete cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    internalDeleteCloudSave(
      experienceId: string,
      instanceId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = CloudsaveApiFetchParamCreator(
        configuration,
      ).internalDeleteCloudSave(experienceId, instanceId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Internal get cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    internalGetCloudSave(
      experienceId: string,
      instanceId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CloudSaveGetResponse> {
      const localVarFetchArgs = CloudsaveApiFetchParamCreator(
        configuration,
      ).internalGetCloudSave(experienceId, instanceId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Internal update cloud save
     * @param {CloudSaveUpdateRequest} body Admin update cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    internalUpdateCloudSave(
      body: CloudSaveUpdateRequest,
      experienceId: string,
      instanceId: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<CloudSaveUpdateResponse> {
      const localVarFetchArgs = CloudsaveApiFetchParamCreator(
        configuration,
      ).internalUpdateCloudSave(body, experienceId, instanceId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update cloud save
     * @param {CloudSaveUpdateRequest} body Admin update cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCloudSave(
      body: CloudSaveUpdateRequest,
      experienceId: string,
      instanceId: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<CloudSaveUpdateResponse> {
      const localVarFetchArgs = CloudsaveApiFetchParamCreator(
        configuration,
      ).updateCloudSave(body, experienceId, instanceId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update shared cloud save
     * @param {CloudSaveUpdateRequest} body Admin update cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSharedCloudSave(
      body: CloudSaveUpdateRequest,
      experienceId: string,
      instanceId: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<CloudSaveUpdateResponse> {
      const localVarFetchArgs = CloudsaveApiFetchParamCreator(
        configuration,
      ).updateSharedCloudSave(body, experienceId, instanceId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * CloudsaveApi - factory interface
 * @export
 */
export const CloudsaveApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Admin create cloud save for user
     * @param {AdminCloudSaveCreateRequest} body Create cloud save
     * @param {string} experienceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminCreateCloudSave(
      body: AdminCloudSaveCreateRequest,
      experienceId: string,
      options?: any,
    ) {
      return CloudsaveApiFp(configuration).adminCreateCloudSave(
        body,
        experienceId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Admin delete cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminDeleteCloudSave(
      experienceId: string,
      instanceId: string,
      userId: string,
      options?: any,
    ) {
      return CloudsaveApiFp(configuration).adminDeleteCloudSave(
        experienceId,
        instanceId,
        userId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Admin get private cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {string} userId id of the user whose cloud save the admin wants to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminGetCloudSave(
      experienceId: string,
      instanceId: string,
      userId: string,
      options?: any,
    ) {
      return CloudsaveApiFp(configuration).adminGetCloudSave(
        experienceId,
        instanceId,
        userId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Admin update cloud save
     * @param {AdminCloudSaveUpdateRequest} body Admin update cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUpdateCloudSave(
      body: AdminCloudSaveUpdateRequest,
      experienceId: string,
      instanceId: string,
      options?: any,
    ) {
      return CloudsaveApiFp(configuration).adminUpdateCloudSave(
        body,
        experienceId,
        instanceId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Create cloud save
     * @param {CloudSaveCreateRequest} body Create cloud save
     * @param {string} experienceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCloudSave(
      body: CloudSaveCreateRequest,
      experienceId: string,
      options?: any,
    ) {
      return CloudsaveApiFp(configuration).createCloudSave(
        body,
        experienceId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Delete cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCloudSave(experienceId: string, instanceId: string, options?: any) {
      return CloudsaveApiFp(configuration).deleteCloudSave(
        experienceId,
        instanceId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Delete shared cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSharedCloudSave(
      experienceId: string,
      instanceId: string,
      options?: any,
    ) {
      return CloudsaveApiFp(configuration).deleteSharedCloudSave(
        experienceId,
        instanceId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCloudSave(experienceId: string, instanceId: string, options?: any) {
      return CloudsaveApiFp(configuration).getCloudSave(
        experienceId,
        instanceId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the shared cloud save data
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSharedCloudSave(
      experienceId: string,
      instanceId: string,
      options?: any,
    ) {
      return CloudsaveApiFp(configuration).getSharedCloudSave(
        experienceId,
        instanceId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Internal create cloud save
     * @param {CloudSaveCreateRequest} body Create cloud save
     * @param {string} experienceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    internalCreateCloudSave(
      body: CloudSaveCreateRequest,
      experienceId: string,
      options?: any,
    ) {
      return CloudsaveApiFp(configuration).internalCreateCloudSave(
        body,
        experienceId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Internal delete cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    internalDeleteCloudSave(
      experienceId: string,
      instanceId: string,
      options?: any,
    ) {
      return CloudsaveApiFp(configuration).internalDeleteCloudSave(
        experienceId,
        instanceId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Internal get cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    internalGetCloudSave(
      experienceId: string,
      instanceId: string,
      options?: any,
    ) {
      return CloudsaveApiFp(configuration).internalGetCloudSave(
        experienceId,
        instanceId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Internal update cloud save
     * @param {CloudSaveUpdateRequest} body Admin update cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    internalUpdateCloudSave(
      body: CloudSaveUpdateRequest,
      experienceId: string,
      instanceId: string,
      options?: any,
    ) {
      return CloudsaveApiFp(configuration).internalUpdateCloudSave(
        body,
        experienceId,
        instanceId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update cloud save
     * @param {CloudSaveUpdateRequest} body Admin update cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCloudSave(
      body: CloudSaveUpdateRequest,
      experienceId: string,
      instanceId: string,
      options?: any,
    ) {
      return CloudsaveApiFp(configuration).updateCloudSave(
        body,
        experienceId,
        instanceId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update shared cloud save
     * @param {CloudSaveUpdateRequest} body Admin update cloud save
     * @param {string} experienceId
     * @param {string} instanceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSharedCloudSave(
      body: CloudSaveUpdateRequest,
      experienceId: string,
      instanceId: string,
      options?: any,
    ) {
      return CloudsaveApiFp(configuration).updateSharedCloudSave(
        body,
        experienceId,
        instanceId,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * CloudsaveApi - object-oriented interface
 * @export
 * @class CloudsaveApi
 * @extends {BaseAPI}
 */
export class CloudsaveApi extends BaseAPI {
  /**
   *
   * @summary Admin create cloud save for user
   * @param {AdminCloudSaveCreateRequest} body Create cloud save
   * @param {string} experienceId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CloudsaveApi
   */
  public adminCreateCloudSave(
    body: AdminCloudSaveCreateRequest,
    experienceId: string,
    options?: any,
  ) {
    return CloudsaveApiFp(this.configuration).adminCreateCloudSave(
      body,
      experienceId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Admin delete cloud save
   * @param {string} experienceId
   * @param {string} instanceId
   * @param {string} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CloudsaveApi
   */
  public adminDeleteCloudSave(
    experienceId: string,
    instanceId: string,
    userId: string,
    options?: any,
  ) {
    return CloudsaveApiFp(this.configuration).adminDeleteCloudSave(
      experienceId,
      instanceId,
      userId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Admin get private cloud save
   * @param {string} experienceId
   * @param {string} instanceId
   * @param {string} userId id of the user whose cloud save the admin wants to get
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CloudsaveApi
   */
  public adminGetCloudSave(
    experienceId: string,
    instanceId: string,
    userId: string,
    options?: any,
  ) {
    return CloudsaveApiFp(this.configuration).adminGetCloudSave(
      experienceId,
      instanceId,
      userId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Admin update cloud save
   * @param {AdminCloudSaveUpdateRequest} body Admin update cloud save
   * @param {string} experienceId
   * @param {string} instanceId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CloudsaveApi
   */
  public adminUpdateCloudSave(
    body: AdminCloudSaveUpdateRequest,
    experienceId: string,
    instanceId: string,
    options?: any,
  ) {
    return CloudsaveApiFp(this.configuration).adminUpdateCloudSave(
      body,
      experienceId,
      instanceId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Create cloud save
   * @param {CloudSaveCreateRequest} body Create cloud save
   * @param {string} experienceId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CloudsaveApi
   */
  public createCloudSave(
    body: CloudSaveCreateRequest,
    experienceId: string,
    options?: any,
  ) {
    return CloudsaveApiFp(this.configuration).createCloudSave(
      body,
      experienceId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Delete cloud save
   * @param {string} experienceId
   * @param {string} instanceId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CloudsaveApi
   */
  public deleteCloudSave(
    experienceId: string,
    instanceId: string,
    options?: any,
  ) {
    return CloudsaveApiFp(this.configuration).deleteCloudSave(
      experienceId,
      instanceId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Delete shared cloud save
   * @param {string} experienceId
   * @param {string} instanceId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CloudsaveApi
   */
  public deleteSharedCloudSave(
    experienceId: string,
    instanceId: string,
    options?: any,
  ) {
    return CloudsaveApiFp(this.configuration).deleteSharedCloudSave(
      experienceId,
      instanceId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get cloud save
   * @param {string} experienceId
   * @param {string} instanceId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CloudsaveApi
   */
  public getCloudSave(experienceId: string, instanceId: string, options?: any) {
    return CloudsaveApiFp(this.configuration).getCloudSave(
      experienceId,
      instanceId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the shared cloud save data
   * @param {string} experienceId
   * @param {string} instanceId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CloudsaveApi
   */
  public getSharedCloudSave(
    experienceId: string,
    instanceId: string,
    options?: any,
  ) {
    return CloudsaveApiFp(this.configuration).getSharedCloudSave(
      experienceId,
      instanceId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Internal create cloud save
   * @param {CloudSaveCreateRequest} body Create cloud save
   * @param {string} experienceId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CloudsaveApi
   */
  public internalCreateCloudSave(
    body: CloudSaveCreateRequest,
    experienceId: string,
    options?: any,
  ) {
    return CloudsaveApiFp(this.configuration).internalCreateCloudSave(
      body,
      experienceId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Internal delete cloud save
   * @param {string} experienceId
   * @param {string} instanceId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CloudsaveApi
   */
  public internalDeleteCloudSave(
    experienceId: string,
    instanceId: string,
    options?: any,
  ) {
    return CloudsaveApiFp(this.configuration).internalDeleteCloudSave(
      experienceId,
      instanceId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Internal get cloud save
   * @param {string} experienceId
   * @param {string} instanceId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CloudsaveApi
   */
  public internalGetCloudSave(
    experienceId: string,
    instanceId: string,
    options?: any,
  ) {
    return CloudsaveApiFp(this.configuration).internalGetCloudSave(
      experienceId,
      instanceId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Internal update cloud save
   * @param {CloudSaveUpdateRequest} body Admin update cloud save
   * @param {string} experienceId
   * @param {string} instanceId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CloudsaveApi
   */
  public internalUpdateCloudSave(
    body: CloudSaveUpdateRequest,
    experienceId: string,
    instanceId: string,
    options?: any,
  ) {
    return CloudsaveApiFp(this.configuration).internalUpdateCloudSave(
      body,
      experienceId,
      instanceId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update cloud save
   * @param {CloudSaveUpdateRequest} body Admin update cloud save
   * @param {string} experienceId
   * @param {string} instanceId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CloudsaveApi
   */
  public updateCloudSave(
    body: CloudSaveUpdateRequest,
    experienceId: string,
    instanceId: string,
    options?: any,
  ) {
    return CloudsaveApiFp(this.configuration).updateCloudSave(
      body,
      experienceId,
      instanceId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update shared cloud save
   * @param {CloudSaveUpdateRequest} body Admin update cloud save
   * @param {string} experienceId
   * @param {string} instanceId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CloudsaveApi
   */
  public updateSharedCloudSave(
    body: CloudSaveUpdateRequest,
    experienceId: string,
    instanceId: string,
    options?: any,
  ) {
    return CloudsaveApiFp(this.configuration).updateSharedCloudSave(
      body,
      experienceId,
      instanceId,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * GearApi - fetch parameter creator
 * @export
 */
export const GearApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Get a list of gears
     * @param {string} [cursor] the pagination cursor
     * @param {number} [limit] the pagination size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminGetGears(
      cursor?: string,
      limit?: number,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/admin/gears`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (cursor !== undefined) {
        localVarQueryParameter['cursor'] = cursor;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a gear
     * @param {GearCreateRequest} body Create gear
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGear(body: GearCreateRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createGear.',
        );
      }
      const localVarPath = `/gear`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'GearCreateRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a list of gears
     * @param {string} [cursor] the pagination cursor
     * @param {number} [limit] the pagination size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGearList(cursor?: string, limit?: number, options: any = {}): FetchArgs {
      const localVarPath = `/gear`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (cursor !== undefined) {
        localVarQueryParameter['cursor'] = cursor;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Pipeline get a gear
     * @param {string} gearId Identifier of the gear
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineGetGear(gearId: string, options: any = {}): FetchArgs {
      // verify required parameter 'gearId' is not null or undefined
      if (gearId === null || gearId === undefined) {
        throw new RequiredError(
          'gearId',
          'Required parameter gearId was null or undefined when calling pipelineGetGear.',
        );
      }
      const localVarPath = `/pipeline/gear/{gearId}`.replace(
        `{${'gearId'}}`,
        encodeURIComponent(String(gearId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication privateToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-private-token')
            : configuration.apiKey;
        localVarHeaderParameter['x-private-token'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Pipeline update a gear
     * @param {GearUpdateRequest} body Create gear
     * @param {string} gearId Identifier of the gear
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineUpdateGear(
      body: GearUpdateRequest,
      gearId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling pipelineUpdateGear.',
        );
      }
      // verify required parameter 'gearId' is not null or undefined
      if (gearId === null || gearId === undefined) {
        throw new RequiredError(
          'gearId',
          'Required parameter gearId was null or undefined when calling pipelineUpdateGear.',
        );
      }
      const localVarPath = `/pipeline/gear/{gearId}`.replace(
        `{${'gearId'}}`,
        encodeURIComponent(String(gearId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication privateToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-private-token')
            : configuration.apiKey;
        localVarHeaderParameter['x-private-token'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'GearUpdateRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a gear
     * @param {GearUpdateRequest} body Create gear
     * @param {string} gearId Identifier of the gear
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGear(
      body: GearUpdateRequest,
      gearId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateGear.',
        );
      }
      // verify required parameter 'gearId' is not null or undefined
      if (gearId === null || gearId === undefined) {
        throw new RequiredError(
          'gearId',
          'Required parameter gearId was null or undefined when calling updateGear.',
        );
      }
      const localVarPath = `/gear/{gearId}`.replace(
        `{${'gearId'}}`,
        encodeURIComponent(String(gearId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'GearUpdateRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GearApi - functional programming interface
 * @export
 */
export const GearApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get a list of gears
     * @param {string} [cursor] the pagination cursor
     * @param {number} [limit] the pagination size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminGetGears(
      cursor?: string,
      limit?: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GearListResponse> {
      const localVarFetchArgs = GearApiFetchParamCreator(
        configuration,
      ).adminGetGears(cursor, limit, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Create a gear
     * @param {GearCreateRequest} body Create gear
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGear(
      body: GearCreateRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GearCreateResponse> {
      const localVarFetchArgs = GearApiFetchParamCreator(
        configuration,
      ).createGear(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get a list of gears
     * @param {string} [cursor] the pagination cursor
     * @param {number} [limit] the pagination size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGearList(
      cursor?: string,
      limit?: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GearListResponse> {
      const localVarFetchArgs = GearApiFetchParamCreator(
        configuration,
      ).getGearList(cursor, limit, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Pipeline get a gear
     * @param {string} gearId Identifier of the gear
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineGetGear(
      gearId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GearGetByIdResponse> {
      const localVarFetchArgs = GearApiFetchParamCreator(
        configuration,
      ).pipelineGetGear(gearId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Pipeline update a gear
     * @param {GearUpdateRequest} body Create gear
     * @param {string} gearId Identifier of the gear
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineUpdateGear(
      body: GearUpdateRequest,
      gearId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = GearApiFetchParamCreator(
        configuration,
      ).pipelineUpdateGear(body, gearId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update a gear
     * @param {GearUpdateRequest} body Create gear
     * @param {string} gearId Identifier of the gear
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGear(
      body: GearUpdateRequest,
      gearId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = GearApiFetchParamCreator(
        configuration,
      ).updateGear(body, gearId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * GearApi - factory interface
 * @export
 */
export const GearApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Get a list of gears
     * @param {string} [cursor] the pagination cursor
     * @param {number} [limit] the pagination size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminGetGears(cursor?: string, limit?: number, options?: any) {
      return GearApiFp(configuration).adminGetGears(
        cursor,
        limit,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Create a gear
     * @param {GearCreateRequest} body Create gear
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGear(body: GearCreateRequest, options?: any) {
      return GearApiFp(configuration).createGear(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Get a list of gears
     * @param {string} [cursor] the pagination cursor
     * @param {number} [limit] the pagination size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGearList(cursor?: string, limit?: number, options?: any) {
      return GearApiFp(configuration).getGearList(
        cursor,
        limit,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Pipeline get a gear
     * @param {string} gearId Identifier of the gear
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineGetGear(gearId: string, options?: any) {
      return GearApiFp(configuration).pipelineGetGear(gearId, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Pipeline update a gear
     * @param {GearUpdateRequest} body Create gear
     * @param {string} gearId Identifier of the gear
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineUpdateGear(body: GearUpdateRequest, gearId: string, options?: any) {
      return GearApiFp(configuration).pipelineUpdateGear(
        body,
        gearId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update a gear
     * @param {GearUpdateRequest} body Create gear
     * @param {string} gearId Identifier of the gear
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGear(body: GearUpdateRequest, gearId: string, options?: any) {
      return GearApiFp(configuration).updateGear(
        body,
        gearId,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * GearApi - object-oriented interface
 * @export
 * @class GearApi
 * @extends {BaseAPI}
 */
export class GearApi extends BaseAPI {
  /**
   *
   * @summary Get a list of gears
   * @param {string} [cursor] the pagination cursor
   * @param {number} [limit] the pagination size
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GearApi
   */
  public adminGetGears(cursor?: string, limit?: number, options?: any) {
    return GearApiFp(this.configuration).adminGetGears(
      cursor,
      limit,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Create a gear
   * @param {GearCreateRequest} body Create gear
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GearApi
   */
  public createGear(body: GearCreateRequest, options?: any) {
    return GearApiFp(this.configuration).createGear(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Get a list of gears
   * @param {string} [cursor] the pagination cursor
   * @param {number} [limit] the pagination size
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GearApi
   */
  public getGearList(cursor?: string, limit?: number, options?: any) {
    return GearApiFp(this.configuration).getGearList(
      cursor,
      limit,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Pipeline get a gear
   * @param {string} gearId Identifier of the gear
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GearApi
   */
  public pipelineGetGear(gearId: string, options?: any) {
    return GearApiFp(this.configuration).pipelineGetGear(gearId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Pipeline update a gear
   * @param {GearUpdateRequest} body Create gear
   * @param {string} gearId Identifier of the gear
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GearApi
   */
  public pipelineUpdateGear(
    body: GearUpdateRequest,
    gearId: string,
    options?: any,
  ) {
    return GearApiFp(this.configuration).pipelineUpdateGear(
      body,
      gearId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update a gear
   * @param {GearUpdateRequest} body Create gear
   * @param {string} gearId Identifier of the gear
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GearApi
   */
  public updateGear(body: GearUpdateRequest, gearId: string, options?: any) {
    return GearApiFp(this.configuration).updateGear(
      body,
      gearId,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * LeaderboardApi - fetch parameter creator
 * @export
 */
export const LeaderboardApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Create a leaderboard for an experience.
     * @summary Create Leaderboard
     * @param {LeaderboardCreateRequest} body Create a leaderboard
     * @param {string} experienceId The experience ID for which the leaderboard is being created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLeaderboard(
      body: LeaderboardCreateRequest,
      experienceId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createLeaderboard.',
        );
      }
      // verify required parameter 'experienceId' is not null or undefined
      if (experienceId === null || experienceId === undefined) {
        throw new RequiredError(
          'experienceId',
          'Required parameter experienceId was null or undefined when calling createLeaderboard.',
        );
      }
      const localVarPath =
        `/admin/leaderboard/experience/{experienceId}`.replace(
          `{${'experienceId'}}`,
          encodeURIComponent(String(experienceId)),
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'LeaderboardCreateRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete Leaderboard
     * @param {string} leaderboardId leaderboard ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLeaderboard(leaderboardId: string, options: any = {}): FetchArgs {
      // verify required parameter 'leaderboardId' is not null or undefined
      if (leaderboardId === null || leaderboardId === undefined) {
        throw new RequiredError(
          'leaderboardId',
          'Required parameter leaderboardId was null or undefined when calling deleteLeaderboard.',
        );
      }
      const localVarPath = `/admin/leaderboard/{leaderboardId}`.replace(
        `{${'leaderboardId'}}`,
        encodeURIComponent(String(leaderboardId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get TOP N user ranks of a leaderboard. Support time window filter.
     * @summary Get Top N Ranks by Leaderboard Id
     * @param {string} leaderboardId leaderboard ID
     * @param {number} [limit] The number of top user ranks to retrieve. Must be between 1 and 50.
     * @param {string} [timeWindow] Filter for the time window.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLeaderboardTopUserRanks(
      leaderboardId: string,
      limit?: number,
      timeWindow?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'leaderboardId' is not null or undefined
      if (leaderboardId === null || leaderboardId === undefined) {
        throw new RequiredError(
          'leaderboardId',
          'Required parameter leaderboardId was null or undefined when calling getLeaderboardTopUserRanks.',
        );
      }
      const localVarPath = `/leaderboard/{leaderboardId}`.replace(
        `{${'leaderboardId'}}`,
        encodeURIComponent(String(leaderboardId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (timeWindow !== undefined) {
        localVarQueryParameter['timeWindow'] = timeWindow;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get TOP N user ranks of a leaderboard in the specific group.
     * @param {string} leaderboardId
     * @param {string} groupId
     * @param {number} [limit] the pagination size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLeaderboardTopUserRanksByGroupId(
      leaderboardId: string,
      groupId: string,
      limit?: number,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'leaderboardId' is not null or undefined
      if (leaderboardId === null || leaderboardId === undefined) {
        throw new RequiredError(
          'leaderboardId',
          'Required parameter leaderboardId was null or undefined when calling getLeaderboardTopUserRanksByGroupId.',
        );
      }
      // verify required parameter 'groupId' is not null or undefined
      if (groupId === null || groupId === undefined) {
        throw new RequiredError(
          'groupId',
          'Required parameter groupId was null or undefined when calling getLeaderboardTopUserRanksByGroupId.',
        );
      }
      const localVarPath = `/leaderboard/{leaderboardId}/group/{groupId}`
        .replace(
          `{${'leaderboardId'}}`,
          encodeURIComponent(String(leaderboardId)),
        )
        .replace(`{${'groupId'}}`, encodeURIComponent(String(groupId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the user's rank and optionally the above and below ranks around the user.
     * @summary Get Ranks around User by Leaderboard Id
     * @param {string} leaderboardId leaderboard ID
     * @param {number} [limit] The maximum number of user ranks to retrieve. Must be between 1 and 50. Default is 1, which only retrieves the requested user&#x27;s rank.
     * @param {number} [offset] The index in the returned user ranks array where the requested user should appear.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLeaderboardUserRanks(
      leaderboardId: string,
      limit?: number,
      offset?: number,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'leaderboardId' is not null or undefined
      if (leaderboardId === null || leaderboardId === undefined) {
        throw new RequiredError(
          'leaderboardId',
          'Required parameter leaderboardId was null or undefined when calling getLeaderboardUserRanks.',
        );
      }
      const localVarPath = `/leaderboard/user/{leaderboardId}`.replace(
        `{${'leaderboardId'}}`,
        encodeURIComponent(String(leaderboardId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all leaderboard information by pagination.
     * @summary Get All Leaderboards by Pagination
     * @param {string} [experienceId] If experience ID is not provided, an aggregate of overall leaderboards across experiences will be retrieved.
     * @param {string} [cursor] the pagination cursor
     * @param {number} [limit] the pagination size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLeaderboards(
      experienceId?: string,
      cursor?: string,
      limit?: number,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/leaderboard/experience`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (experienceId !== undefined) {
        localVarQueryParameter['experienceId'] = experienceId;
      }

      if (cursor !== undefined) {
        localVarQueryParameter['cursor'] = cursor;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Reset Leaderboard
     * @param {string} leaderboardId leaderboard ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetLeaderboard(leaderboardId: string, options: any = {}): FetchArgs {
      // verify required parameter 'leaderboardId' is not null or undefined
      if (leaderboardId === null || leaderboardId === undefined) {
        throw new RequiredError(
          'leaderboardId',
          'Required parameter leaderboardId was null or undefined when calling resetLeaderboard.',
        );
      }
      const localVarPath = `/admin/leaderboard/{leaderboardId}`.replace(
        `{${'leaderboardId'}}`,
        encodeURIComponent(String(leaderboardId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Submit user score by user ID to a leaderboard.
     * @summary Submit User Score to a Leaderboard
     * @param {LeaderboardSubmitUserScoreRequest} body Leaderboard submit user score
     * @param {string} leaderboardId leaderboard ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitLeaderboardUserScore(
      body: LeaderboardSubmitUserScoreRequest,
      leaderboardId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling submitLeaderboardUserScore.',
        );
      }
      // verify required parameter 'leaderboardId' is not null or undefined
      if (leaderboardId === null || leaderboardId === undefined) {
        throw new RequiredError(
          'leaderboardId',
          'Required parameter leaderboardId was null or undefined when calling submitLeaderboardUserScore.',
        );
      }
      const localVarPath = `/leaderboard/{leaderboardId}`.replace(
        `{${'leaderboardId'}}`,
        encodeURIComponent(String(leaderboardId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'LeaderboardSubmitUserScoreRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LeaderboardApi - functional programming interface
 * @export
 */
export const LeaderboardApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Create a leaderboard for an experience.
     * @summary Create Leaderboard
     * @param {LeaderboardCreateRequest} body Create a leaderboard
     * @param {string} experienceId The experience ID for which the leaderboard is being created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLeaderboard(
      body: LeaderboardCreateRequest,
      experienceId: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<LeaderboardCreateResponse> {
      const localVarFetchArgs = LeaderboardApiFetchParamCreator(
        configuration,
      ).createLeaderboard(body, experienceId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Delete Leaderboard
     * @param {string} leaderboardId leaderboard ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLeaderboard(
      leaderboardId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = LeaderboardApiFetchParamCreator(
        configuration,
      ).deleteLeaderboard(leaderboardId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get TOP N user ranks of a leaderboard. Support time window filter.
     * @summary Get Top N Ranks by Leaderboard Id
     * @param {string} leaderboardId leaderboard ID
     * @param {number} [limit] The number of top user ranks to retrieve. Must be between 1 and 50.
     * @param {string} [timeWindow] Filter for the time window.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLeaderboardTopUserRanks(
      leaderboardId: string,
      limit?: number,
      timeWindow?: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<LeaderboardGetTopNRanksResponse> {
      const localVarFetchArgs = LeaderboardApiFetchParamCreator(
        configuration,
      ).getLeaderboardTopUserRanks(leaderboardId, limit, timeWindow, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get TOP N user ranks of a leaderboard in the specific group.
     * @param {string} leaderboardId
     * @param {string} groupId
     * @param {number} [limit] the pagination size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLeaderboardTopUserRanksByGroupId(
      leaderboardId: string,
      groupId: string,
      limit?: number,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<LeaderboardGetTopNRanksByGroupIdResponse> {
      const localVarFetchArgs = LeaderboardApiFetchParamCreator(
        configuration,
      ).getLeaderboardTopUserRanksByGroupId(
        leaderboardId,
        groupId,
        limit,
        options,
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get the user's rank and optionally the above and below ranks around the user.
     * @summary Get Ranks around User by Leaderboard Id
     * @param {string} leaderboardId leaderboard ID
     * @param {number} [limit] The maximum number of user ranks to retrieve. Must be between 1 and 50. Default is 1, which only retrieves the requested user&#x27;s rank.
     * @param {number} [offset] The index in the returned user ranks array where the requested user should appear.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLeaderboardUserRanks(
      leaderboardId: string,
      limit?: number,
      offset?: number,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<LeaderboardGetRanksResponse> {
      const localVarFetchArgs = LeaderboardApiFetchParamCreator(
        configuration,
      ).getLeaderboardUserRanks(leaderboardId, limit, offset, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get all leaderboard information by pagination.
     * @summary Get All Leaderboards by Pagination
     * @param {string} [experienceId] If experience ID is not provided, an aggregate of overall leaderboards across experiences will be retrieved.
     * @param {string} [cursor] the pagination cursor
     * @param {number} [limit] the pagination size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLeaderboards(
      experienceId?: string,
      cursor?: string,
      limit?: number,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<LeaderboardGetResponse> {
      const localVarFetchArgs = LeaderboardApiFetchParamCreator(
        configuration,
      ).getLeaderboards(experienceId, cursor, limit, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Reset Leaderboard
     * @param {string} leaderboardId leaderboard ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetLeaderboard(
      leaderboardId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = LeaderboardApiFetchParamCreator(
        configuration,
      ).resetLeaderboard(leaderboardId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Submit user score by user ID to a leaderboard.
     * @summary Submit User Score to a Leaderboard
     * @param {LeaderboardSubmitUserScoreRequest} body Leaderboard submit user score
     * @param {string} leaderboardId leaderboard ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitLeaderboardUserScore(
      body: LeaderboardSubmitUserScoreRequest,
      leaderboardId: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<LeaderboardSubmitUserScoreResponse> {
      const localVarFetchArgs = LeaderboardApiFetchParamCreator(
        configuration,
      ).submitLeaderboardUserScore(body, leaderboardId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * LeaderboardApi - factory interface
 * @export
 */
export const LeaderboardApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Create a leaderboard for an experience.
     * @summary Create Leaderboard
     * @param {LeaderboardCreateRequest} body Create a leaderboard
     * @param {string} experienceId The experience ID for which the leaderboard is being created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLeaderboard(
      body: LeaderboardCreateRequest,
      experienceId: string,
      options?: any,
    ) {
      return LeaderboardApiFp(configuration).createLeaderboard(
        body,
        experienceId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Delete Leaderboard
     * @param {string} leaderboardId leaderboard ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLeaderboard(leaderboardId: string, options?: any) {
      return LeaderboardApiFp(configuration).deleteLeaderboard(
        leaderboardId,
        options,
      )(fetch, basePath);
    },
    /**
     * Get TOP N user ranks of a leaderboard. Support time window filter.
     * @summary Get Top N Ranks by Leaderboard Id
     * @param {string} leaderboardId leaderboard ID
     * @param {number} [limit] The number of top user ranks to retrieve. Must be between 1 and 50.
     * @param {string} [timeWindow] Filter for the time window.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLeaderboardTopUserRanks(
      leaderboardId: string,
      limit?: number,
      timeWindow?: string,
      options?: any,
    ) {
      return LeaderboardApiFp(configuration).getLeaderboardTopUserRanks(
        leaderboardId,
        limit,
        timeWindow,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get TOP N user ranks of a leaderboard in the specific group.
     * @param {string} leaderboardId
     * @param {string} groupId
     * @param {number} [limit] the pagination size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLeaderboardTopUserRanksByGroupId(
      leaderboardId: string,
      groupId: string,
      limit?: number,
      options?: any,
    ) {
      return LeaderboardApiFp(
        configuration,
      ).getLeaderboardTopUserRanksByGroupId(
        leaderboardId,
        groupId,
        limit,
        options,
      )(fetch, basePath);
    },
    /**
     * Get the user's rank and optionally the above and below ranks around the user.
     * @summary Get Ranks around User by Leaderboard Id
     * @param {string} leaderboardId leaderboard ID
     * @param {number} [limit] The maximum number of user ranks to retrieve. Must be between 1 and 50. Default is 1, which only retrieves the requested user&#x27;s rank.
     * @param {number} [offset] The index in the returned user ranks array where the requested user should appear.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLeaderboardUserRanks(
      leaderboardId: string,
      limit?: number,
      offset?: number,
      options?: any,
    ) {
      return LeaderboardApiFp(configuration).getLeaderboardUserRanks(
        leaderboardId,
        limit,
        offset,
        options,
      )(fetch, basePath);
    },
    /**
     * Get all leaderboard information by pagination.
     * @summary Get All Leaderboards by Pagination
     * @param {string} [experienceId] If experience ID is not provided, an aggregate of overall leaderboards across experiences will be retrieved.
     * @param {string} [cursor] the pagination cursor
     * @param {number} [limit] the pagination size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLeaderboards(
      experienceId?: string,
      cursor?: string,
      limit?: number,
      options?: any,
    ) {
      return LeaderboardApiFp(configuration).getLeaderboards(
        experienceId,
        cursor,
        limit,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Reset Leaderboard
     * @param {string} leaderboardId leaderboard ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetLeaderboard(leaderboardId: string, options?: any) {
      return LeaderboardApiFp(configuration).resetLeaderboard(
        leaderboardId,
        options,
      )(fetch, basePath);
    },
    /**
     * Submit user score by user ID to a leaderboard.
     * @summary Submit User Score to a Leaderboard
     * @param {LeaderboardSubmitUserScoreRequest} body Leaderboard submit user score
     * @param {string} leaderboardId leaderboard ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitLeaderboardUserScore(
      body: LeaderboardSubmitUserScoreRequest,
      leaderboardId: string,
      options?: any,
    ) {
      return LeaderboardApiFp(configuration).submitLeaderboardUserScore(
        body,
        leaderboardId,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * LeaderboardApi - object-oriented interface
 * @export
 * @class LeaderboardApi
 * @extends {BaseAPI}
 */
export class LeaderboardApi extends BaseAPI {
  /**
   * Create a leaderboard for an experience.
   * @summary Create Leaderboard
   * @param {LeaderboardCreateRequest} body Create a leaderboard
   * @param {string} experienceId The experience ID for which the leaderboard is being created.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LeaderboardApi
   */
  public createLeaderboard(
    body: LeaderboardCreateRequest,
    experienceId: string,
    options?: any,
  ) {
    return LeaderboardApiFp(this.configuration).createLeaderboard(
      body,
      experienceId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Delete Leaderboard
   * @param {string} leaderboardId leaderboard ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LeaderboardApi
   */
  public deleteLeaderboard(leaderboardId: string, options?: any) {
    return LeaderboardApiFp(this.configuration).deleteLeaderboard(
      leaderboardId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Get TOP N user ranks of a leaderboard. Support time window filter.
   * @summary Get Top N Ranks by Leaderboard Id
   * @param {string} leaderboardId leaderboard ID
   * @param {number} [limit] The number of top user ranks to retrieve. Must be between 1 and 50.
   * @param {string} [timeWindow] Filter for the time window.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LeaderboardApi
   */
  public getLeaderboardTopUserRanks(
    leaderboardId: string,
    limit?: number,
    timeWindow?: string,
    options?: any,
  ) {
    return LeaderboardApiFp(this.configuration).getLeaderboardTopUserRanks(
      leaderboardId,
      limit,
      timeWindow,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get TOP N user ranks of a leaderboard in the specific group.
   * @param {string} leaderboardId
   * @param {string} groupId
   * @param {number} [limit] the pagination size
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LeaderboardApi
   */
  public getLeaderboardTopUserRanksByGroupId(
    leaderboardId: string,
    groupId: string,
    limit?: number,
    options?: any,
  ) {
    return LeaderboardApiFp(
      this.configuration,
    ).getLeaderboardTopUserRanksByGroupId(
      leaderboardId,
      groupId,
      limit,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Get the user's rank and optionally the above and below ranks around the user.
   * @summary Get Ranks around User by Leaderboard Id
   * @param {string} leaderboardId leaderboard ID
   * @param {number} [limit] The maximum number of user ranks to retrieve. Must be between 1 and 50. Default is 1, which only retrieves the requested user&#x27;s rank.
   * @param {number} [offset] The index in the returned user ranks array where the requested user should appear.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LeaderboardApi
   */
  public getLeaderboardUserRanks(
    leaderboardId: string,
    limit?: number,
    offset?: number,
    options?: any,
  ) {
    return LeaderboardApiFp(this.configuration).getLeaderboardUserRanks(
      leaderboardId,
      limit,
      offset,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Get all leaderboard information by pagination.
   * @summary Get All Leaderboards by Pagination
   * @param {string} [experienceId] If experience ID is not provided, an aggregate of overall leaderboards across experiences will be retrieved.
   * @param {string} [cursor] the pagination cursor
   * @param {number} [limit] the pagination size
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LeaderboardApi
   */
  public getLeaderboards(
    experienceId?: string,
    cursor?: string,
    limit?: number,
    options?: any,
  ) {
    return LeaderboardApiFp(this.configuration).getLeaderboards(
      experienceId,
      cursor,
      limit,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Reset Leaderboard
   * @param {string} leaderboardId leaderboard ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LeaderboardApi
   */
  public resetLeaderboard(leaderboardId: string, options?: any) {
    return LeaderboardApiFp(this.configuration).resetLeaderboard(
      leaderboardId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Submit user score by user ID to a leaderboard.
   * @summary Submit User Score to a Leaderboard
   * @param {LeaderboardSubmitUserScoreRequest} body Leaderboard submit user score
   * @param {string} leaderboardId leaderboard ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LeaderboardApi
   */
  public submitLeaderboardUserScore(
    body: LeaderboardSubmitUserScoreRequest,
    leaderboardId: string,
    options?: any,
  ) {
    return LeaderboardApiFp(this.configuration).submitLeaderboardUserScore(
      body,
      leaderboardId,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * StoreApi - fetch parameter creator
 * @export
 */
export const StoreApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Delete a store
     * @param {string} storeId Identifier of the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteStore(storeId: string, options: any = {}): FetchArgs {
      // verify required parameter 'storeId' is not null or undefined
      if (storeId === null || storeId === undefined) {
        throw new RequiredError(
          'storeId',
          'Required parameter storeId was null or undefined when calling deleteStore.',
        );
      }
      const localVarPath = `/store/{storeId}`.replace(
        `{${'storeId'}}`,
        encodeURIComponent(String(storeId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of stores
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getListStores(options: any = {}): FetchArgs {
      const localVarPath = `/store`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of store items
     * @param {string} storeId Identifier of the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStoreItems(storeId: string, options: any = {}): FetchArgs {
      // verify required parameter 'storeId' is not null or undefined
      if (storeId === null || storeId === undefined) {
        throw new RequiredError(
          'storeId',
          'Required parameter storeId was null or undefined when calling getStoreItems.',
        );
      }
      const localVarPath = `/store/{storeId}`.replace(
        `{${'storeId'}}`,
        encodeURIComponent(String(storeId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gift store items to a user by adding a list of store items
     * @param {UserStoreItemUpdates} body Update Store
     * @param {string} userId UserId who will receive the items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    giftStoreItems(
      body: UserStoreItemUpdates,
      userId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling giftStoreItems.',
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling giftStoreItems.',
        );
      }
      const localVarPath = `/user/{userId}/store`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'UserStoreItemUpdates' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Register a store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerStore(options: any = {}): FetchArgs {
      const localVarPath = `/store`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a store by adding a list of store items
     * @param {StoreItemUpdates} body Update Store
     * @param {string} storeId Identifier of the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStoreItems(
      body: StoreItemUpdates,
      storeId: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateStoreItems.',
        );
      }
      // verify required parameter 'storeId' is not null or undefined
      if (storeId === null || storeId === undefined) {
        throw new RequiredError(
          'storeId',
          'Required parameter storeId was null or undefined when calling updateStoreItems.',
        );
      }
      const localVarPath = `/store/{storeId}`.replace(
        `{${'storeId'}}`,
        encodeURIComponent(String(storeId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'PATCH' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'StoreItemUpdates' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StoreApi - functional programming interface
 * @export
 */
export const StoreApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete a store
     * @param {string} storeId Identifier of the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteStore(
      storeId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = StoreApiFetchParamCreator(
        configuration,
      ).deleteStore(storeId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get list of stores
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getListStores(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListStoresResponse> {
      const localVarFetchArgs =
        StoreApiFetchParamCreator(configuration).getListStores(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get list of store items
     * @param {string} storeId Identifier of the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStoreItems(
      storeId: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<ListStoreItemsResponse> {
      const localVarFetchArgs = StoreApiFetchParamCreator(
        configuration,
      ).getStoreItems(storeId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gift store items to a user by adding a list of store items
     * @param {UserStoreItemUpdates} body Update Store
     * @param {string} userId UserId who will receive the items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    giftStoreItems(
      body: UserStoreItemUpdates,
      userId: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<ListStoreItemsResponse> {
      const localVarFetchArgs = StoreApiFetchParamCreator(
        configuration,
      ).giftStoreItems(body, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Register a store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerStore(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RegisterStoreResponse> {
      const localVarFetchArgs =
        StoreApiFetchParamCreator(configuration).registerStore(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update a store by adding a list of store items
     * @param {StoreItemUpdates} body Update Store
     * @param {string} storeId Identifier of the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStoreItems(
      body: StoreItemUpdates,
      storeId: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<ListStoreItemsResponse> {
      const localVarFetchArgs = StoreApiFetchParamCreator(
        configuration,
      ).updateStoreItems(body, storeId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * StoreApi - factory interface
 * @export
 */
export const StoreApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Delete a store
     * @param {string} storeId Identifier of the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteStore(storeId: string, options?: any) {
      return StoreApiFp(configuration).deleteStore(storeId, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Get list of stores
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getListStores(options?: any) {
      return StoreApiFp(configuration).getListStores(options)(fetch, basePath);
    },
    /**
     *
     * @summary Get list of store items
     * @param {string} storeId Identifier of the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStoreItems(storeId: string, options?: any) {
      return StoreApiFp(configuration).getStoreItems(storeId, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Gift store items to a user by adding a list of store items
     * @param {UserStoreItemUpdates} body Update Store
     * @param {string} userId UserId who will receive the items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    giftStoreItems(body: UserStoreItemUpdates, userId: string, options?: any) {
      return StoreApiFp(configuration).giftStoreItems(
        body,
        userId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Register a store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerStore(options?: any) {
      return StoreApiFp(configuration).registerStore(options)(fetch, basePath);
    },
    /**
     *
     * @summary Update a store by adding a list of store items
     * @param {StoreItemUpdates} body Update Store
     * @param {string} storeId Identifier of the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStoreItems(body: StoreItemUpdates, storeId: string, options?: any) {
      return StoreApiFp(configuration).updateStoreItems(
        body,
        storeId,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * StoreApi - object-oriented interface
 * @export
 * @class StoreApi
 * @extends {BaseAPI}
 */
export class StoreApi extends BaseAPI {
  /**
   *
   * @summary Delete a store
   * @param {string} storeId Identifier of the store
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StoreApi
   */
  public deleteStore(storeId: string, options?: any) {
    return StoreApiFp(this.configuration).deleteStore(storeId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Get list of stores
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StoreApi
   */
  public getListStores(options?: any) {
    return StoreApiFp(this.configuration).getListStores(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Get list of store items
   * @param {string} storeId Identifier of the store
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StoreApi
   */
  public getStoreItems(storeId: string, options?: any) {
    return StoreApiFp(this.configuration).getStoreItems(storeId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Gift store items to a user by adding a list of store items
   * @param {UserStoreItemUpdates} body Update Store
   * @param {string} userId UserId who will receive the items
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StoreApi
   */
  public giftStoreItems(
    body: UserStoreItemUpdates,
    userId: string,
    options?: any,
  ) {
    return StoreApiFp(this.configuration).giftStoreItems(
      body,
      userId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Register a store
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StoreApi
   */
  public registerStore(options?: any) {
    return StoreApiFp(this.configuration).registerStore(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Update a store by adding a list of store items
   * @param {StoreItemUpdates} body Update Store
   * @param {string} storeId Identifier of the store
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StoreApi
   */
  public updateStoreItems(
    body: StoreItemUpdates,
    storeId: string,
    options?: any,
  ) {
    return StoreApiFp(this.configuration).updateStoreItems(
      body,
      storeId,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * TraitsApi - fetch parameter creator
 * @export
 */
export const TraitsApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Get the traits status and other metadata (devkit where only developers will be able to access this). From shim API with trait service using devkit swaggerhub.
     * @param {string} status Status of the traits to get
     * @param {string} [traitId] TraitId to get only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTraits(status: string, traitId?: string, options: any = {}): FetchArgs {
      // verify required parameter 'status' is not null or undefined
      if (status === null || status === undefined) {
        throw new RequiredError(
          'status',
          'Required parameter status was null or undefined when calling getTraits.',
        );
      }
      const localVarPath = `/v1/trait`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      if (traitId !== undefined) {
        localVarQueryParameter['traitId'] = traitId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Only one type of category can be sent with one request, but there can be multiple traitIds associated with it.
     * @summary Send a signal to request a change to traits
     * @param {TraitSignalRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendSignal(body?: TraitSignalRequest, options: any = {}): FetchArgs {
      const localVarPath = `/v1/trait/signal`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'TraitSignalRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TraitsApi - functional programming interface
 * @export
 */
export const TraitsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get the traits status and other metadata (devkit where only developers will be able to access this). From shim API with trait service using devkit swaggerhub.
     * @param {string} status Status of the traits to get
     * @param {string} [traitId] TraitId to get only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTraits(
      status: string,
      traitId?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<TraitsGetResponse> {
      const localVarFetchArgs = TraitsApiFetchParamCreator(
        configuration,
      ).getTraits(status, traitId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Only one type of category can be sent with one request, but there can be multiple traitIds associated with it.
     * @summary Send a signal to request a change to traits
     * @param {TraitSignalRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendSignal(
      body?: TraitSignalRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageResponse> {
      const localVarFetchArgs = TraitsApiFetchParamCreator(
        configuration,
      ).sendSignal(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * TraitsApi - factory interface
 * @export
 */
export const TraitsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Get the traits status and other metadata (devkit where only developers will be able to access this). From shim API with trait service using devkit swaggerhub.
     * @param {string} status Status of the traits to get
     * @param {string} [traitId] TraitId to get only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTraits(status: string, traitId?: string, options?: any) {
      return TraitsApiFp(configuration).getTraits(
        status,
        traitId,
        options,
      )(fetch, basePath);
    },
    /**
     * Only one type of category can be sent with one request, but there can be multiple traitIds associated with it.
     * @summary Send a signal to request a change to traits
     * @param {TraitSignalRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendSignal(body?: TraitSignalRequest, options?: any) {
      return TraitsApiFp(configuration).sendSignal(body, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * TraitsApi - object-oriented interface
 * @export
 * @class TraitsApi
 * @extends {BaseAPI}
 */
export class TraitsApi extends BaseAPI {
  /**
   *
   * @summary Get the traits status and other metadata (devkit where only developers will be able to access this). From shim API with trait service using devkit swaggerhub.
   * @param {string} status Status of the traits to get
   * @param {string} [traitId] TraitId to get only
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TraitsApi
   */
  public getTraits(status: string, traitId?: string, options?: any) {
    return TraitsApiFp(this.configuration).getTraits(
      status,
      traitId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Only one type of category can be sent with one request, but there can be multiple traitIds associated with it.
   * @summary Send a signal to request a change to traits
   * @param {TraitSignalRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TraitsApi
   */
  public sendSignal(body?: TraitSignalRequest, options?: any) {
    return TraitsApiFp(this.configuration).sendSignal(body, options)(
      this.fetch,
      this.basePath,
    );
  }
}
/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * if traitId is not present, it will return the macro profile that includes all of the traits.
     * @summary Get user trait profile for the traits
     * @param {string} userId UserId of the requestor
     * @param {string} [traitId] traitId to get score of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserTraitProfile(
      userId: string,
      traitId?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getUserTraitProfile.',
        );
      }
      const localVarPath = `/v1/user/{userId}/profile`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (traitId !== undefined) {
        localVarQueryParameter['traitId'] = traitId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get history of changes made to trait profile
     * @summary Get history between time range of user trait profile
     * @param {string} userId UserId of the requestor
     * @param {number} [startTime] start time to query
     * @param {number} [endTime] end time to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserTraitProfileHistory(
      userId: string,
      startTime?: number,
      endTime?: number,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getUserTraitProfileHistory.',
        );
      }
      const localVarPath = `/v1/user/{userId}/profile/history`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      // authentication clientHash required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('x-client-hash')
            : configuration.apiKey;
        localVarHeaderParameter['x-client-hash'] = localVarApiKeyValue;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] = endTime;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  return {
    /**
     * if traitId is not present, it will return the macro profile that includes all of the traits.
     * @summary Get user trait profile for the traits
     * @param {string} userId UserId of the requestor
     * @param {string} [traitId] traitId to get score of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserTraitProfile(
      userId: string,
      traitId?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserTraitsResponse> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration,
      ).getUserTraitProfile(userId, traitId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get history of changes made to trait profile
     * @summary Get history between time range of user trait profile
     * @param {string} userId UserId of the requestor
     * @param {number} [startTime] start time to query
     * @param {number} [endTime] end time to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserTraitProfileHistory(
      userId: string,
      startTime?: number,
      endTime?: number,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<UserTraitsHistoryResponse> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration,
      ).getUserTraitProfileHistory(userId, startTime, endTime, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * if traitId is not present, it will return the macro profile that includes all of the traits.
     * @summary Get user trait profile for the traits
     * @param {string} userId UserId of the requestor
     * @param {string} [traitId] traitId to get score of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserTraitProfile(userId: string, traitId?: string, options?: any) {
      return UserApiFp(configuration).getUserTraitProfile(
        userId,
        traitId,
        options,
      )(fetch, basePath);
    },
    /**
     * Get history of changes made to trait profile
     * @summary Get history between time range of user trait profile
     * @param {string} userId UserId of the requestor
     * @param {number} [startTime] start time to query
     * @param {number} [endTime] end time to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserTraitProfileHistory(
      userId: string,
      startTime?: number,
      endTime?: number,
      options?: any,
    ) {
      return UserApiFp(configuration).getUserTraitProfileHistory(
        userId,
        startTime,
        endTime,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   * if traitId is not present, it will return the macro profile that includes all of the traits.
   * @summary Get user trait profile for the traits
   * @param {string} userId UserId of the requestor
   * @param {string} [traitId] traitId to get score of
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUserTraitProfile(userId: string, traitId?: string, options?: any) {
    return UserApiFp(this.configuration).getUserTraitProfile(
      userId,
      traitId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Get history of changes made to trait profile
   * @summary Get history between time range of user trait profile
   * @param {string} userId UserId of the requestor
   * @param {number} [startTime] start time to query
   * @param {number} [endTime] end time to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUserTraitProfileHistory(
    userId: string,
    startTime?: number,
    endTime?: number,
    options?: any,
  ) {
    return UserApiFp(this.configuration).getUserTraitProfileHistory(
      userId,
      startTime,
      endTime,
      options,
    )(this.fetch, this.basePath);
  }
}
